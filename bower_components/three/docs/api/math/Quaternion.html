<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<div class="desc">
			Implementation of a [link:http://en.wikipedia.org/wiki/Quaternion quaternion].
			This is used for [link:https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation rotating things]
			without encountering the dreaded
			[link:http://en.wikipedia.org/wiki/Gimbal_lock gimbal lock] issue, amongst other
			advantages.
		</div>


		<h2>Example</h2>

		<code>
		var quaternion = new THREE.Quaternion();
		quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );

		var vector = new THREE.Vector3( 1, 0, 0 );
		vector.applyQuaternion( quaternion );
		</code>


		<h2>Constructor</h2>


		<h3>[name]( [page:Float x], [page:Float y], [page:Float z], [page:Float w] )</h3>
		<div>
		[page:Float x] - x coordinate<br />
		[page:Float y] - y coordinate<br />
		[page:Float z] - z coordinate<br />
		[page:Float w] - w coordinate
		</div>


		<h2>Properties</h2>

		<h3>[property:Float x]</h3>
		<div>Changing this property will result in [page:.onChangeCallback onChangeCallback] being called.</div>

		<h3>[property:Float y]</h3>
		<div>Changing this property will result in [page:.onChangeCallback onChangeCallback] being called.</div>

		<h3>[property:Float z]</h3>
		<div>Changing this property will result in [page:.onChangeCallback onChangeCallback] being called.</div>

		<h3>[property:Float w]</h3>
		<div>Changing this property will result in [page:.onChangeCallback onChangeCallback] being called.</div>


		<h2>Methods</h2>

		<h3>[method:Quaternion clone]()</h3>
		<div>
			Creates a new Quaternion with identical [page:.x x], [page:.y y],
			[page:.z z] and [page:.w w] properties to this one.
		</div>


		<h3>[method:Quaternion conjugate]()</h3>
		<div>
		Returns the rotational conjugate of this quaternion. The conjugate of a quaternion
		represents the same rotation in the opposite direction about the rotational axis.
		</div>

		<h3>[method:Quaternion copy]( [page:Quaternion q] )</h3>
		<div>
			Copies the [page:.x x], [page:.y y],	[page:.z z] and [page:.w w] properties
			of [page:Quaternion q] into this quaternion.
		</div>

		<h3>[method:Boolean equals]( [page:Quaternion v] )</h3>
		<div>
		[page:Quaternion v] - Quaternion that this quaternion will be compared to.<br /><br />

		Compares the [page:.x x], [page:.y y],	[page:.z z] and [page:.w w] properties of
		[page:Quaternion v] to the equivalent properties of this quaternion to determine if they
		represent the same rotation.
		</div>

		<h3>[method:Float dot]( [page:Quaternion v] )</h3>
		<div>
			Calculate the [link:https://en.wikipedia.org/wiki/Dot_product dot product] of
			quaternions [page:Quaternion v] and this one.
		</div>

		<h3>[method:Quaternion fromArray]( [page:Array array], [page:Integer offset] )</h3>
		<div>
		[page:Array array] - array of format (x, y, z, w) used to construct the quaternion.<br />
		[page:Integer offset] - (optional) an offset into the array.<br /><br />

		Sets this quaternion's [page:.x x], [page:.y y],	[page:.z z] and [page:.w w] properties
		from an array.
		</div>

		<h3>[method:Quaternion inverse]()</h3>
		<div>
			Inverts this quaternion - calculate the [page:.conjugate conjugate] and then
			[page:.normalize normalizes] the result.
		</div>

		<h3>[method:Float length]()</h3>
		<div>Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]
		(straight-line length) of this quaternion, considered as a 4 dimensional vector.</div>

		<h3>[method:Float lengthSq]()</h3>
		<div>
			Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]
			(straight-line length) of this quaternion, considered as a 4 dimensional
			vector. This can be useful if you are comparing the lengths of two quaternions,
			as this is a slightly more efficient calculation than [page:.length length]().
		</div>

		<h3>[method:Quaternion normalize]()</h3>
		<div>
			[link:https://en.wikipedia.org/wiki/Normalized_vector Normalizes] this quaternion - that is,
		calculated the quaternion that performs the same rotation as this one, but has  [page:.length length]
		equal to *1*.
		</div>

		<h3>[method:Quaternion multiply]( [page:Quaternion q] )</h3>
		<div>Multiplies this quaternion by [page:Quaternion q].</div>

		<h3>[method:Quaternion multiplyQuaternions]( [page:Quaternion a], [page:Quaternion b] )</h3>
		<div>
		Sets this quaternion to [page:Quaternion a] x [page:Quaternion b].<br />
		Adapted from the method outlined [link:http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm here].
		</div>

		<h3>[method:Quaternion onChange]( [page:Function onChangeCallback] )</h3>
		<div>Set the [page:.onChangeCallback onChangeCallback]() method.</div>

		<h3>[method:Quaternion onChangeCallback]( )</h3>
		<div>
			This function is called whenever and of the following occur:
			<ul>
				<li>
					The [page:.x x], [page:.y y], [page:.z z] or
				  [page:.w w] properties are changed.
				</li>
				<li>
					The [page:.set set](), [page:.copy copy](), [page:.clone clone](),
					[page:.setFromAxisAngle setFromAxisAngle](),  [page:.setFromRotationMatrix setFromRotationMatrix](),
					[page:.conjugate conjugate](), [page:.normalize normalize](),
					[page:.multiplyQuaternions multiplyQuaternions](), [page:.slerp slerp]() or [page:.fromArray fromArray]()
					functions are called.
				</li>
				<li>
					[page:.setFromEuler setFromEuler]() function is called with its *update* argument set to true.
				</li>
			</ul>
			By default it is the empty function, however you can change it if needed using [page:.onChange onChange]( [page:Function onChangeCallback] ).
		</div>


		<h3>[method:Quaternion premultiply]( [page:Quaternion q] )</h3>
		<div>Pre-multiplies this quaternion by [page:Quaternion q].</div>

		<h3>[method:Quaternion slerp]( [page:Quaternion qb], [page:float t] )</h3>
		<div>
			[page:Quaternion qb] - The other quaternion rotation<br />
			[page:float t] - interpolation factor in the closed interval [0, 1].<br /><br />

			Handles the spherical linear interpolation between quaternions. [page:float t] represents the
			amount of rotation between this quaternion (where [page:float t] is 0) and [page:Quaternion qb] (where
			[page:float t] is 1). This quaternion is set to the result. Also see the static version of the
			*slerp* below.

			<code>
			// rotate a mesh towards a target quaternion
			mesh.quaternion.slerp( endQuaternion, 0.01 );
			</code>
		</div>

		<h3>[method:Quaternion set]( [page:Float x], [page:Float y], [page:Float z], [page:Float w] )</h3>
		<div>Sets [page:.x x], [page:.y y], [page:.z z], [page:.w w] properties of this quaternion.</div>

		<h3>[method:Quaternion setFromAxisAngle]( [page:Vector3 axis], [page:Float angle] )</h3>
		<div>
		Sets this quaternion from rotation specified by [page:Vector3 axis] and [page:Float angle].<br />
		Adapted from the method [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm here].<br />
		*Axis* is asumed to be normalized, *angle* is in radians.
		</div>

		<h3>[method:Quaternion setFromEuler]( [page:Euler euler] )</h3>
		<div>Sets this quaternion from the rotation specified by [page:Euler] angle.</div>

		<h3>[method:Quaternion setFromRotationMatrix]( [page:Matrix4 m] )</h3>
		<div>
		Sets this quaternion from rotation component of [page:Matrix4 m].<br />
		Adapted from the method [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm here].
		</div>

		<h3>[method:Quaternion setFromUnitVectors]( [page:Vector3 vFrom], [page:Vector3 vTo] )</h3>
		<div>
		Sets this quaternion to the rotation required to rotate direction vector [page:Vector3 vFrom] to
		direction vector [page:Vector3 vTo].<br />
		Adapted from the method [link:http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors here].<br />
		[page:Vector3 vFrom] and [page:Vector3 vTo] are assumed to be normalized.
		</div>

		<h3>[method:Array toArray]( [page:Array array], [page:Integer offset] )</h3>
		<div>
		[page:Array array] - An optional array to store the quaternion. If not specified a new array will be created.<br/>
		[page:Integer offset] - optional) if specified, the result will be copied
		into this [page:Array].<br /><br />

		Returns the numerical elements of this quaternion in an array of format [x, y, z, w].
		</div>

		<h2>Static Methods</h2>

		<div>
			Static methods (as opposed to instance methods) are designed to be called directly from the class,
			rather than from a specific instance. So to use the static version of, call it like so:
			<code>
THREE.Quaternion.slerp( qStart, qEnd, qTarget, t );
			</code>
			By contrast, to call the 'normal' or instanced slerp method, you would do the following:
			<code>
//instantiate a quaternion with default values
var q = new THREE.Quaternion();

//call the instanced slerp method
q.slerp( qb, t )
			</code>

		</div>

		<h3>[method:Quaternion slerp]( [page:Quaternion qStart], [page:Quaternion qEnd], [page:Quaternion qTarget], [page:Float t] )</h3>
		<div>
			[page:Quaternion qStart] - The starting quaternion (where [page:Float t] is 0)<br />
			[page:Quaternion qEnd] - The ending quaternion (where [page:Float t] is 1)<br />
			[page:Quaternion qTarget] - The target quaternion that gets set with the result<br />
			[page:float t] - interpolation factor in the closed interval [0, 1].<br /><br />

			Unlike the normal method, the static version of slerp sets a target quaternion to the result of the slerp operation.
			<code>
			// Code setup
			var startQuaternion = new THREE.Quaternion().set( 0, 0, 0, 1 ).normalize();
			var endQuaternion = new THREE.Quaternion().set( 1, 1, 1, 1 ).normalize();
			var t = 0;

			// Update a mesh's rotation in the loop
			t = ( t + 0.01 ) % 1; // constant angular momentum
			THREE.Quaternion.slerp( startQuaternion, endQuaternion, mesh.quaternion, t );
			</code>
		</div>


		<h3>
		[method:null slerpFlat](
			[page:Array dst],
			[page:Integer dstOffset],
			[page:Array src0],
			[page:Integer srcOffset0],
			[page:Array src1],
			[page:Integer srcOffset1],
			[page:Float t]
		)
		</h3>
		<div>
		[page:Array dst] - The output array.<br />
		[page:Integer dstOffset] - An offset into the output array.<br />
		[page:Array src0] - The source array of the starting quaternion.<br />
		[page:Integer srcOffset0] - An offset into the array *src0*.<br />
		[page:Array src1] - The source array of the target quatnerion.<br />
		[page:Integer srcOffset1] - An offset into the array *src1*.<br />
		[page:float t] - Normalized interpolation factor (between 0 and 1).<br /><br />
		<div>
		Like the static *slerp* method above, but operates directly on flat arrays of numbers.
		</div>

		<!-- Note: Do not add non-static methods to the bottom of this page. Put them above the <h2>Static Methods</h2> -->

		<h2>Source</h2>

		[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
	</body>
</html>
