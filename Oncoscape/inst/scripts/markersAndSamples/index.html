




<!DOCTYPE html> 
<html>

<head>
   <meta charset="UTF-8">
   <meta property="og:title" content="Oncoscape" />

   <title> OncoDev 1.4</title>

   <script src="http://code.jquery.com/qunit/qunit-1.18.0.js"></script>
   <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.18.0.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-2.1.3.min.js"></script>
   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-1.11.2.min.js"></script-->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-ui-1.11.4.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.7/themes/smoothness/jquery-ui.css">

   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.4.4.min.js"></script-->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.5.1.min.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.cytoscape.js-panzoom.js"></script>
   <link   href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.cytoscape.js-panzoom.css" 
           rel="stylesheet" 
           type="text/css">


   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/d3.min.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.dataTables-1.10.5.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.dataTables-1.10.5.min.css">

   <script src="http://cdn.datatables.net/colvis/1.1.0/js/dataTable.colVis.js"></script>

   <link   rel="stylesheet" type="text/css"
           href="http://cdn.datatables.net/colvis/1.1.0/css/dataTables.colVis.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.multi-select.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/multi-select.css" media="screen" rel="stylesheet" type="text/css">
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/chosen.jquery.min.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/chosen.min.css" media="screen" rel="stylesheet" type="text/css">

    <link rel="SHORTCUT ICON" type="image/x-icon" href="http://oncoscape.sttrcancer.org/oncoscape/images/favicon.ico"/>
    <link rel="ICON" type="image/x-icon" href="http://oncoscape.sttrcancer.org/oncoscape/images/favicon.ico"/>


<script> 
//--------------------------------------------------------------------------------------------------
// hooks for google analytics

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 
  ga('create', 'UA-528883-29', 'auto');
  ga('send', 'pageview');
//--------------------------------------------------------------------------------------------------
</script> 

<script>
navigator.sayswho= (function(){
    var ua= navigator.userAgent, tem,
    M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
    }
    if(M[1]!== 'Chrome'){
       alert("Oncoscape is currently developed and tested under Chrome.  For best results, please use Chrome version 45.0 and later.")
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
    }
    M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();
</script>

</head>

<style>

.flex-container {
  display: -webkit-flex;
  display: flex;
  }

.ui-slider-range {
   background-image: none;
   background: lightgrey;
   }

th,td {
   font-size:12px;
   }

.patientDataFilterSliderReadout{
   font-size: 10px;
   height:16px;
   }

.ui-tabs .ui-tabs-nav li a{
   font-size:10pt !important;
   }

.ui-button .ui-button-text{
   font-size:10pt !important;
   }

.ui-dialog .ui-dialog-titlebar-close span{ margin:0 }

.SelectionMenu{
color: rgb(0, 0, 0); 
background-color: rgb(255, 255, 255);
}

</style>



<script>

//----------------------------------------------------------------------------------------------------
// These javascript functions and variables are arranged into a simple module so that
// implementation details are kept private from the public API other oncoscape 
// browser modules will use.  common services and utility functions are provided here
//----------------------------------------------------------------------------------------------------
var HubModule = (function () {

  var name = "HubModule";
     // keys are module names, their outermost divs are the values.
     // providing these outermost divs allows was inspired by 
     // the need to allow raising of tabs by the sending tab.
     // TODO: not sure that's still needed

  var selectionDestinations = {};
  var dispatchOptions = {};
  var socketIsConnected = false;
  var socketConnectedFunctions = [];
  var onDocumentReadyFunctions = [];
  var socketURI = window.location.href.replace("http://", "ws://");
  var socket;
  
  var  messagingRestrictedToLogin = false;

  var modules = {};
//----------------------------------------------------------------------------------------------------
function registerModule(name, moduleObject)
{
   modules[name] = moduleObject;

} // registerModule
//----------------------------------------------------------------------------------------------------
function getModuleNames()
{
   return(Object.getOwnPropertyNames(modules));

} // getModuleNames
//----------------------------------------------------------------------------------------------------
function getModules()
{
   return modules;

} // getModules
//----------------------------------------------------------------------------------------------------
// TODO: add 3rd argument: acceptsIncomingMessages
//       datasets, for instance, seems to have no need for incoming json/websocket messages
function registerSelectionDestination(names, outermostDivID)
{
  if(typeof(names) == "string")
    names = [names];

  for(var i=0; i < names.length; i++)
     selectionDestinations[names[i]] = outermostDivID;

} // registerSelectionDestination
//----------------------------------------------------------------------------------------------------
function getRegisteredSelectionDestinations()
{
  return(selectionDestinations);

} // getRegisteredSelectionDestinations
//----------------------------------------------------------------------------------------------------
function setupSocket(socket)
{
  console.log("=== Module.hub setupSocket");

  try {
     socket.onopen = function() {
        console.log("websocket connection now open");
        socketIsConnected = true;
        for(var f=0; f < socketConnectedFunctions.length; f++){
           console.log("calling the next sockectConnectedFunction");
           socketConnectedFunctions[f]();
           } // for f
        } // socked.onopen

     socket.onmessage = function got_packet(msg) {
        var msg = JSON.parse(msg.data)
        dispatchMessage(msg)
        } // socket.onmessage, got_packet

     socket.onclose = function(){
        alert("Web socket connection to server has closed");
        } // socket.onclose
     } // try
  catch(exception) {
    console.log("Error: " + exception);
    }
 
  return(socket);

} // setupSocket
//----------------------------------------------------------------------------------------------------
function socketConnected()
{
   return(socketIsConnected);

} // socketConnected
//----------------------------------------------------------------------------------------------------
function addSocketConnectedFunction(func)
{
   socketConnectedFunctions.push(func)

} // addSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function getSocketConnectedFunctions()
{
   return(socketConnectedFunctions)

} // getSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function addOnDocumentReadyFunction(func)
{
   onDocumentReadyFunctions.push(func)

} // addOnDocumentReadyFunction
//----------------------------------------------------------------------------------------------------
function getOnDocumentReadyFunctions()
{
   return(onDocumentReadyFunctions)

} // getOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
// the nginx proxy server, used by fhcrc IT for the publicly-visible version of Oncoscape
// times out web sockets at 90 seconds.
// this function, when called more often that that, will keep the websocket open.
keepAlive = function()
{   
    //console.log("keep alive"); 
    msg = {cmd: "keepAlive", callback: "", status:"request", payload:""}
    socket.send(JSON.stringify(msg));

} // keepAlive
//--------------------------------------------------------------------------------------------------
function runOnDocumentReadyFunctions()
{
  setInterval(keepAlive, 10000);  // 10 seconds
  var funcs = getOnDocumentReadyFunctions()
  console.log("==== Module.hub: " + funcs.length + " onDocumentReadyFunctions");

  for (var f = 0; f < funcs.length; f++) {
     console.log("calling on ready function");
     funcs[f]();
     }

} // runOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
function runningInNode()
{
    // a not very sophisticated test, but adequate for our purposes thus far
  return(typeof(window) == "undefined")

} // functionRunningInNode
//----------------------------------------------------------------------------------------------------
function initializeWebSocket()
{
   if(runningInNode()){
     console.log("--- web socket not currently available when runing in Node");
     process.exit(code=1)
     }

   socket = new WebSocket(socketURI);
   socket = setupSocket(socket);

} // initializeWebSocket
//----------------------------------------------------------------------------------------------------
function getSocket()
{
  return(socket);

} // getSocket
//----------------------------------------------------------------------------------------------------
function addMessageHandler(cmd, func)
{
  if(cmd in dispatchOptions){
     dispatchOptions[cmd].push(func)
     }
  else{
     dispatchOptions[cmd] = [func]
     }
  
} // addMessageHandler
//----------------------------------------------------------------------------------------------------
function getRegisteredMessageNames()
{
   return(Object.keys(dispatchOptions));
  
} // getRegisteredMessageNames
//----------------------------------------------------------------------------------------------------
function getDispatchOptions()
{
   return(dispatchOptions);
  
} // getDispatchOptions
//----------------------------------------------------------------------------------------------------
function dispatchMessage(msg)
{
   var cmd = msg.cmd;
   var status = msg.status;
   console.log("====== Module.hub dispatchMessage '" + cmd + "' [" + Date() + "]" );

   var dispatchKeys = Object.keys(dispatchOptions);
   var cmdIndex = dispatchKeys.indexOf(cmd);
   console.log("hub.dispatchMessage(" + cmd + "): " + cmdIndex);

   if(cmdIndex === -1){
      console.log("unrecognized socket request: " + msg.cmd);
      console.log(" --- msg:");
      console.log(msg);
      console.log(" --- dispatchOptions");
      console.log(dispatchOptions);
      }
   else{
     var funcs = dispatchOptions[cmd];
     //console.log(" func count for msg cmd " + cmd + ": " + funcs.length);
      for(var i=0; i < funcs.length; i++){
         //console.log("--- Module.hub executing func # " + i + " for cmd " + msg.cmd);
         funcs[i](msg); // dispatchOptions[msg.cmd](msg)
         } // for i
      }

}  // dispatchMessage
//----------------------------------------------------------------------------------------------------
function restrictMessagingToLogin(newState)
{
   messagingRestrictedToLogin = newState;

} // restrictMessagingToLogin
//----------------------------------------------------------------------------------------------------
function send(msg)
{
   var cmd = JSON.parse(msg).cmd;
   if(messagingRestrictedToLogin && cmd === "checkPassword"){
      console.log("hub.send drops non-login msg");
      return;
      }

   var browserLocalCommand = Object.keys(dispatchOptions).indexOf(cmd) >= 0;
   var mode = "server";
   if(browserLocalCommand)
      mode = "browser local";

   console.log("--- hub.send: '" + cmd + "' (" + mode + ")");

   if(browserLocalCommand)
      dispatchMessage(JSON.parse(msg));
   else{
      socket.send(msg);
      }

}  // send
//----------------------------------------------------------------------------------------------------
function setTitle (newTitle)
{
  window.document.title = newTitle;

}  // setTitle
//----------------------------------------------------------------------------------------------------
// add a pulldown menu to the specified menuSelector, which has been provided by the caller, which
// is assumed to be an Oncoscape module.  append the names of all previously-registered divs, 
// except for those explicitly excluded in the incoming argument "excludedModules".
// This supports the usual (but not universal) case: a module does not want to send selections
// to itself.
// this argument will often be an array of one element, the name of the calling module.
// some modules may have multiple send destinations (eg, "PCA" & "PCA (highlight)".
function configureSendSelectionMenu(menuSelector, excludedModules, changeFunction, menuTitle)
{
  var menu = $(menuSelector);
  menu.append("<option>" + menuTitle + "</option>");
  menu.change(changeFunction);
  var otherModules = Object.keys(hub.getRegisteredSelectionDestinations());

  for(var i=0; i < otherModules.length; i++){
     var moduleName = otherModules[i];
     var excluded = excludedModules.indexOf(moduleName) >= 0;
     if(!excluded){
        menu.append("<option>" + moduleName + "</option>");
        }
     } // for i

  return(menu);

} // createSendSelectionMenu
//--------------------------------------------------------------------------------------------
// from http://stackoverflow.com/questions/4068373/center-a-popup-window-on-screen
function openCenteredBrowserWindow(url, title, w, h, replaceAnyExistingPopup) {
      // Fixes dual-screen position                       Most browsers      Firefox
    var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
    var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
    width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
    height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;

    var left = ((width / 2) - (w / 2)) + dualScreenLeft;
    var top = ((height / 2) - (h / 2)) + dualScreenTop;
    var options = 'scrollbars=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left;

    var newWindow;

      // warning, a bug: when multiple popup windows are created, they
      // all have the same content -- not what we want.  fix this
      // by severing their relationship, and/or switching to jQuery dialog

    if(replaceAnyExistingPopup)
      newWindow = window.open(url, title, options);
    else // leave any existing popup windows untouched
      newWindow = window.open(url, "_blank", options);

    if (window.focus) {
       newWindow.focus();
       }
       
    return newWindow;

} // openCenteredBrowserWindow
//--------------------------------------------------------------------------------------------
function disableButton(button)
{
   button.prop("disabled", true);
   button.css({"background-color": "lightgray", "color": "gray"});

} // disableButton
//--------------------------------------------------------------------------------------------
function enableButton(button)
{
   button.prop("disabled", false);
   //button.css({ 'color': 'black'})
   button.css({"background-color": "white", "color": "black"});

} // enableButton
//--------------------------------------------------------------------------------------------
function disableAllTabsExcept(tabIDstring)
{
  if(typeof tabIDstring == "string") tabIDstring = [tabIDstring]
  var allDivIDs = getTabDivIDs()
  allDivIDs = allDivIDs.filter(function(i, id){ return(tabIDstring.indexOf(id) == -1) })
  for(var i=0;i<allDivIDs.length; i++){  	disableTab(allDivIDs[i]) }
  
  return allDivIDs;  //returns divIDs that have been disabled
  
} // disableTab
//--------------------------------------------------------------------------------------------
function disableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "disable", "#" + tabIDstring  )

} // disableTab
//--------------------------------------------------------------------------------------------
function enableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "enable", "#" + tabIDstring   )
} // enableTab

//--------------------------------------------------------------------------------------------
// if jQuery-style tabs are in use with Oncoscape, this function raised the named tab to the
// the front (visible) position in the tabset
// the argument, "tabIDString" is the tab id used in the module's widget.html, reproduced exactly
// in tabsApp/widget.html, with some current examples being
//  pcaDiv, patientTimeLinesDiv, gbmPathwaysDiv
//
function raiseTab(tabIDString)
{
  var tabsWidget = $("#oncoscapeTabs");

  if(tabsWidget.length > 0){
     var selectionString = '#oncoscapeTabs a[href="#' + tabIDString + '"]';
     var tabIndex = $(selectionString).parent().index ();
     if(tabIndex < 0) throw "Module.hub does not recognize tabIDString '" + tabIDString + "'";
     console.log("Module.hub:raiseTab for '" + tabIDString + "' (" + tabIndex + ") set to active'");
     setTimeout(function(){tabsWidget.tabs( "option", "active", tabIndex);}, 0);
     } // if tabs exist

} // raiseTab
//----------------------------------------------------------------------------------------------------
// each of our tabs is a div, nested directly within $("oncoscapeTabs").  
// this function returns an array of each of the div ids
function getTabNames()
{
  var tabNames = $("#oncoscapeTabs").children()[0].textContent.trim().split("\n")
  for (i=0;i< tabNames.length; i++){ tabNames[i] = tabNames[i].trim()}
  tabNames =tabNames.filter(function(name){return name != ""})

	return tabNames;

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// each of our tabs has a title within the $("oncoscapeTabs") nav bar
// this function returns an array of each tab Title
function getTabDivIDs()
{
   return ($("#oncoscapeTabs").children("div").map(function(index,dom){return dom.id}));

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTab("Login", "#loginDiv");
function hideTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideTab
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTabNav("Login");
function hideTabNav(tabTitle)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()

} // hideTab
//----------------------------------------------------------------------------------------------------
function hideAllTabsButOne(tabTitle, tabDivIDstring)
{
  var divIDs = getTabDivIDs();
  
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideAllTabsButOne
//----------------------------------------------------------------------------------------------------
function showTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").show()
  $(tabDivIDstring).show();

} // showTab
//----------------------------------------------------------------------------------------------------
function addTab(tabTitle, tabDivIDstring,  content)
{
  var tabs = $("#oncoscapeTabs").tabs()
  var listItem = "<li><a href='#" + tabDivIDstring + "}'>" + tabTitle + "</a>";

  tabs.find(".ui-tabs-nav").append(listItem);
  tabs.append("<div id='" + tabDivIDstring + "'><p>" + content + "</p></div>");
  tabs.tabs("refresh");

} // addTab
//----------------------------------------------------------------------------------------------------
function getRandomFloat (min, max)
{
    return Math.random() * (max - min) + min;
}
//----------------------------------------------------------------------------------------------------
function getRandomInt (min, max) 
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
//----------------------------------------------------------------------------------------------------
String.prototype.beginsWith = function (string) 
{
    return(this.toLowerCase().indexOf(string.toLowerCase()) === 0);
};
//----------------------------------------------------------------------------------------------------
uniqueElementsOfArray = function(vector)
{
  var u = {}, a = [];

  for(var i = 0, l = vector.length; i < l; ++i){
     if(u.hasOwnProperty(vector[i])){
       continue;
       }
     a.push(vector[i]);
     u[vector[i]] = 1;
     } // for i

   return a;

} // uniqueElementsOfArray
//----------------------------------------------------------------------------------------------------
// return the targets matched by the candidates, where match is tolerant of differences by suffix
// thus incoming id "TCGA.06.0649.01" matches existing id "TCGA.06.0649" and
//      incoming id "TCGA.06.0649"    matches existing id "TCGA.06.0649.01" 
// this may cause problems with gene names, eg, MYC would mach MYCL and MYCA
// todo: make this suffix-tolerant match suffix-specific 
function intersectionOfArrays(candidates, targets) {

  hits=[]; 

  for(var i=0; i < candidates.length; i++){
    for (var j=0; j < targets.length; j++){
       candidate = candidates[i];
       target = targets[j];
       index1 = candidate.indexOf(target);   // "abc".indexOf("ab") -> 0
       index2 = target.indexOf(candidate); 
       //console.log("c(t): " + candidate + " contains " + target + ": " + index1);
       //console.log("t(c): " + target + " contains " + candidate + ": " + index2);
       if (index1 == 0)
          hits.push(target)
       else if (index2 == 0)
          hits.push(target)
         } // for j
     } // for i

  return(hits)

} // intersectionOfArays
//----------------------------------------------------------------------------------------------------
function setupGlobalExceptionHandler()
{
   window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {

      var title = "Oncoscape Error";
      var options = {buttons: { "Ok": function () { $(this).dialog("close"); } },
                     title: title};
      var text = "<i>" + errorMsg + "</i><br>" +
                 "<br><b>Script</b>: " + url + 
                 "<br><b>Line:</b> " + lineNumber + 
                 "<br><b>Column:</b> " + column + 
                 "<br><b>StackTrace:</b> " +  errorObj;
      $("<div></div>").dialog(options).html(text);
      };
 
} // setupGlobalExceptionHandler
//----------------------------------------------------------------------------------------------------
function start()
{
  setupGlobalExceptionHandler();
  initializeWebSocket();
  $(document).ready(runOnDocumentReadyFunctions);
  QUnit.config.altertitle = false;

}  // start
//----------------------------------------------------------------------------------------------------
function logEventOnServer(moduleOfOrigin, eventName, eventStatus, comment)
{
   console.log("about to logEvent: " + eventName);
   payload= {eventName: eventName, eventStatus: eventStatus, 
             moduleOfOrigin: moduleOfOrigin, comment: comment};

   hub.send(JSON.stringify({cmd: "logEvent", callback: "", status: "request", payload: payload}));

} // logEventOnServer
//----------------------------------------------------------------------------------------------------
function test_intersectionOfArrays()
{
   console.log("---  test_intersectionOfArrays");
   var targets = ["TCGA.02.0006"];
   var candidates = ["TCGA.02.0006"];

   QUnit.test("test_intersectionOfArrays 1", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   targets = ["TCGA.02.0006"];
   candidates = ["bogus"];
   QUnit.test("test_intersectionOfArrays 2", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });

   targets = ["bogus"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 3", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });


   targets = ["TCGA.02.0006.01"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 4", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   //targets = ["MAP2"];   this test will fail because sometimes we want incomplete matches:
   //  see test4 just above
   //candidates = ["MAP2K4", "abc"];
   //QUnit.test("test_intersectionOfArrays 5", function(assert) {
   //   assert.equal(hub.intersectionOfArrays(candidates, targets), []);
   //   });


} //  test_intersectionOfArrays
//----------------------------------------------------------------------------------------------------
function standAloneTest()
{
   test_intersectionOfArrays();

}  // standaloneTest
//----------------------------------------------------------------------------------------------------

  return({
     getName: function() {return(name)},
     restrictMessagingToLogin: restrictMessagingToLogin,
     registerModule: registerModule,
     getModules: getModules,
     registerSelectionDestination: registerSelectionDestination,
     getRegisteredSelectionDestinations: getRegisteredSelectionDestinations,
     socketConnected: socketConnected,
     addSocketConnectedFunction: addSocketConnectedFunction,
     getSocketConnectedFunctions: getSocketConnectedFunctions,
     addOnDocumentReadyFunction: addOnDocumentReadyFunction,
     getOnDocumentReadyFunctions: getOnDocumentReadyFunctions,
     runningInNode: runningInNode,
     initializeWebSocket: initializeWebSocket,
     getSocket: getSocket,
     addMessageHandler: addMessageHandler,
     getRegisteredMessageNames: getRegisteredMessageNames,
     getDispatchOptions: getDispatchOptions,
     dispatchMessage: dispatchMessage,
     configureSendSelectionMenu: configureSendSelectionMenu,
     openCenteredBrowserWindow: openCenteredBrowserWindow,
     enableButton: enableButton,
     disableButton: disableButton,
     enableTab: enableTab,
     disableTab: disableTab,
     disableAllTabsExcept: disableAllTabsExcept,
     getRandomInt: getRandomInt,
     getRandomFloat: getRandomFloat,
     intersectionOfArrays: intersectionOfArrays,
     uniqueElementsOfArray: uniqueElementsOfArray,
     send: send,
     setTitle: setTitle,
     getTabDivIDs: getTabDivIDs,
     getTabNames: getTabNames,
     raiseTab: raiseTab,
     hideTab: hideTab,
     hideTabNav: hideTabNav,
     showTab: showTab,
     addTab: addTab,
     sat: standAloneTest,
     start: start,
     logEventOnServer: logEventOnServer
     });

}); // HubModule
//----------------------------------------------------------------------------------------------------


var hub = HubModule();
hub.start();

// testManager/Module.js
//----------------------------------------------------------------------------------------------------
var moduleTests = [];
//----------------------------------------------------------------------------------------------------
var TestManagerModule = (function () {

   var loopStatusObserver = null;

   var loopStatusDiv = "#testManagerLoopStatusDiv";

//----------------------------------------------------------------------------------------------------
function initializeModule()
{
  console.log("--- entering Module.testManager.initializeModule");
  
  hub.addMessageHandler("testManagerAssessUserIdForTesting", assessUserIdForTesting);

  if(hub.socketConnected())
     runAutomatedTestsIfAppropriate();
  else
     hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);
    
} // initializeModule
//----------------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
function runAutomatedTestsIfAppropriate()
{
   var msg = {cmd: "getUserInfo",  callback: "testManagerAssessUserIdForTesting", status: "request", payload: ""};
   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   console.log("---- Module.testManager, payload: ");
   console.log(JSON.stringify(msg.payload));
   
   var userID = msg.payload.userID;
   userID = userID.toLowerCase();

   var datasetNames = msg.payload.datasets;
   if(typeof(datasetNames) === "string")
      datasetNames = [datasetNames];

     // currently restricted to just one module:
     // mutation observer pacing not yet worked out with multiple modules tested successively
     
   console.log("testManager/Module.js assessUserIdForTesting: " + userID);
   if(userID.indexOf("autotest") === 0){
      console.log("testManager/Module.js running tests for user " + userID);
      var start = userID.indexOf(".");
      var end = userID.indexOf("@");
      var reps = 1;
      if(start > 0 && end > 0)
        reps = parseInt(userID.slice(start+1, end));
      var exitOnCompletion = false;
      if(userID.indexOf("exitoncompletion") > 0)
          exitOnCompletion = true;

      console.log("runTests: " + JSON.stringify(datasetNames));
      console.log("reps: " + reps);
      console.log("exitOnCompletion: " + exitOnCompletion);
      //runTests(datasetNames, reps, exitOnCompletion);

        // the individual modules should not exitOnCompletion
      var modulesExitOnCompletion = false;
      for(var i=0; i < moduleTests.length; i++){
         console.log("about to run <module>Tester.run(), loop " + i);
         moduleTests[0].run(datasetNames, reps, exitOnCompletion);
         } // var i
       
      //if(exitOnCompletion){
      //   var payload = {errorCount: Object.keys(sessionStorage).length,
      //                  errors: JSON.stringify(sessionStorage)};
      //   var exitMsg = {cmd: "exitAfterTesting", callback: "", status: "request", payload: payload};
      //   console.log("about to send exitAfterTesting msg to server");
      //   hub.send(JSON.stringify(exitMsg));
      //   } // if exitOnCompletion
      } // if userID == autotest

} // assessUserIdForTesting
//----------------------------------------------------------------------------------------------------
function runTests(datasetNames, reps, exitOnCompletion)
{

   var config = {attributes: true, childList: true, characterData: true};
   var target =  document.querySelector(loopStatusDiv);

   var testIndex = -1;

   var onMutation = function(mutations){
      mutation = mutations[0];
      loopStatusObserver.disconnect();
      loopStatusObserver = null;
      var id = mutation.target.id;
      var msg = $(loopStatusDiv).text();
      console.log("test status changed, text: " + msg);
      testIndex++;
      if(testIndex < moduleTests.length){
         console.log("about to test module " + testIndex);
	 loopStatusObserver = new MutationObserver(onMutation);
         loopStatusObserver.observe(target, config);
         var moduleExitOnCompletion = false;
         moduleTests[testIndex].run(datasetNames, reps, moduleExitOnCompletion);
	 }
      else{
         console.log("mutation observer function detected end of moduleTests array");
         if(exitOnCompletion){
            var payload = {errorCount: Object.keys(sessionStorage).length,
	                   errors: JSON.stringify(sessionStorage)};
            var exitMsg = {cmd: "exitAfterTesting", callback: "", status: "request", payload: payload};
            console.log("about to send exitAfterTesting msg to server");
            hub.send(JSON.stringify(exitMsg));
	    } // if exitOnCompletion
	 } // else: datasets exhaused
      }; // onMutation function

   loopStatusObserver = new MutationObserver(onMutation);
   loopStatusObserver.observe(target, config);

   $(loopStatusDiv).text("start testing");   // mutate the target

} // runTests
//----------------------------------------------------------------------------------------------------

  return({
     init: initializeModule,
     run: runTests
     });

});  // TestManagerMdoule
//----------------------------------------------------------------------------------------------------
testManager = TestManagerModule();
hub.addOnDocumentReadyFunction(testManager.init);
hub.addOnDocumentReadyFunction(function() {
    console.log("====== tabapps document ready");
    window.tabsAppRunning = true
    $("#oncoscapeTabs").tabs({
         // todo: distinguish between tabs, only do needed resets
       activate: function(event, ui) {
            console.log(" tabsApp/code.js:activate");
            var tableRef = $("#historyTable").dataTable();
            var tableRef2 = $("#userDataStoreTable").dataTable();
            if (tableRef.length > 0) {
               console.log("   adjusting patient history table");
               tableRef.fnAdjustColumnSizing();
               } // if
            if (tableRef2.length > 0) {
               console.log("   skipping! - adjusting user data store table");
               tableRef2.fnAdjustColumnSizing();
               } // if
            //console.log(" ==== tab.activate, possible cyjs resize and fit");
            if(typeof(cwMarkers) != "undefined") {
              console.log("adjusting cwMarkers? " + cwMarkers.width() + " * " + cwMarkers.height());
               if(cwMarkers.width() > 0){
                  cwMarkers.resize(); 
                  console.log("after resize");
                  cwMarkers.fit(50);
                  console.log("done adjusting cwMarkers");
		  }
               }
            if(typeof(cyGbm) != "undefined") {
               //console.log("adjusting cwGbm");
               cyGbm.resize();
               cyGbm.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cwAngio) != "undefined") {
               //console.log("adjusting cwAngio");
               cwAngio.resize();
               cwAngio.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cyPathway) != "undefined") {
               cyPathway.resize();
               cyPathway.fit(50);
               }
            } // activate
        }); // tabs
    });  // ready



//----------------------------------------------------------------------------------------------------
var DataSummaryModule = (function () {

  var dataSummaryDiv;

  var outputDiv;
  var dataSetNamesOutputDiv;
  var thisModulesName = "Datasets";
  var thisModulesOutermostDiv = "datasetsDiv";

  var tableElement;
  var tableRef;
  var datasetMenu;
  var selectedDataSet;
  var useThisDatasetButton;

  var sendSelectionsMenu;
  var sendSelectionsMenuTitle = "Send selection...";
  var passwordProtected = false;

//----------------------------------------------------------------------------------------------------
function initializeUI()
{
  sendSelectionsMenu = hub.configureSendSelectionMenu("#datasetsSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                       sendSelectionsMenuTitle);

  hub.disableButton(sendSelectionsMenu);

  $(window).resize(handleWindowResize);
  datasetMenu = $("#datasetMenu");
  datasetMenu.change(selectManifest);

  dataSetNamesOutputDiv = $("#dataSetNamesOutputDiv");
  dataSummaryDiv = $("#dataSummaryOutputDiv");

  useThisDatasetButton = $("#selectDatasetButton");
  useThisDatasetButton.button();
  hub.disableButton(useThisDatasetButton);
  useThisDatasetButton.click(specifyCurrentDataset);

  outputDiv = $("#dataSummaryOutputDiv");
  tableElement = $("#datasetsManifestTable");
      
    // if no login tab is present, then allow unrestricted choice of datasets.
    // if it IS present, then that tab will control this.

  var loginRequired = $("#loginDiv").length === 1;
  console.log("loginRequired? " + loginRequired);

  if(!loginRequired){
    console.log(" enabling datasetMenu");
    hub.enableButton($("#datasetMenu"));
    }
  else{
    console.log(" disabling datasetMenu");
    hub.disableButton($("#datasetMenu"));
    }

   if(hub.socketConnected())
      populateDataSetMenu();
   else
     hub.addSocketConnectedFunction(populateDataSetMenu);

} // initializeUI
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
   $("#datasetsStatusDiv").text(msg);   // todo: this is obsolete
   $("#datasetsMinorStatusDiv").text(msg);
   
} // postStatus
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  $("#"+thisModulesOutermostDiv).width($(window).width() * 0.95);
//  $("#"+thisModulesOutermostDiv).height($(window).height() * 0.95);

//  console.log("  div: " + outputDiv.width());
//  console.log("  tbl before: " + tableElement.width());
//  tableElement.width($(window).width() * 0.50);
//  console.log("  tbl after: " + tableElement.width());

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   var cmd = "sendSelectionTo_" + destination;
   payload = "dummy payload";
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//----------------------------------------------------------------------------------------------------
function selectManifest(event)
{
   selectedDataSet = datasetMenu.val();
   console.log("dataset '" + selectedDataSet + "'");

   if(selectedDataSet === ""){
      $("#datasetInstructions").css("display", "block");
      $("#datasetsManifestTable").css("display", "none");
      hub.disableButton(useThisDatasetButton);
      }
    else{
      $("#datasetInstructions").css("display", "none");
      $("#datasetsManifestTable").css("display", "block");
      requestDataSetSummary(selectedDataSet);
    }

} // selectManifest
//----------------------------------------------------------------------------------------------------
function populateDataSetMenu()
{
   console.log("Module.datasets, entering populateDataSetMenu");

   console.log("      socket connected? " + hub.socketConnected());
   console.log("=== datasetMenu ready, now issuing populateDataSetMenu request to server");
   var msg = {cmd: "getDataSetNames",  callback: "handleDataSetNames", status: "request", payload: ""};
   hub.send(JSON.stringify(msg));

} // populateDataSetMenu
//----------------------------------------------------------------------------------------------------
function handleDataSetNames(msg)
{
   console.log("=== handleDataSetNames");
   
   var dataSetNames = msg.payload.datasets;
   console.log("dataSetNames length: " + dataSetNames.length);
   console.log("dataSetNames: " + JSON.stringify(dataSetNames));

   var passwordProtected = msg.payload.passwordProtected;

   if(!Array.isArray(dataSetNames))
      dataSetNames = [dataSetNames];

   for(var i=0; i < dataSetNames.length; i++){
      var s = dataSetNames[i];
      datasetMenu.append("<option value='" + s + "'>" + s + "</option>");
      }

  $("#datasetsMinorStatusDiv").text("datasetMenu loaded");

} // handleDataSetNames
//----------------------------------------------------------------------------------------------------
function requestDataSetSummary(dataSetName)
{
   console.log("=== requestDataSetSummary");

   var msg = {cmd: "getDataManifest",  callback: "displayDataManifest", status: "request", 
              payload: dataSetName};
   hub.logEventOnServer(thisModulesName, "datasets requestDataSummary", "request", dataSetName);

   hub.send(JSON.stringify(msg));

} // requestDataSetSummary
//----------------------------------------------------------------------------------------------------
function displayDataManifest(msg)
{
   var payload = msg.payload;
   var tblColumnNames = payload.colnames;

   var columnTitles = [];
     // convert simple strings to array of objects, each an sTitle
   for(var i=0; i < tblColumnNames.length; i++){
      columnTitles.push({sTitle: tblColumnNames[i]});
      }
     
   if(typeof(tableRef) != "undefined"){
      tableRef.destroy();
      tableElement.empty();
      }


   $(tableElement).ready(function() {
      tableRef = tableElement.DataTable({
        //sDom: 't',
        aoColumns: columnTitles,
        //scrollX: true,
        bPaginate: false,
        bFilter: false, 
        bAutoWidth: true,
        bSort: false,
        bInfo: false
        }); // dataTable

     tableRef = $("#datasetsManifestTable").DataTable();

     tableRef.rows.add(payload.mtx).draw();
     // tableRef.fnAddData(payload.mtx);

     $('#datasetsManifestTable tbody').on( 'click', 'tr', function (){ 
         console.log("=== click");
         var category = $('td', this).eq(0).text();
         var subcategory = $('td', this).eq(1).text();
         if($(this).hasClass("selected")){
            $(this).removeClass('selected');
            hub.disableButton(sendSelectionsMenu);
            }
         else{
            tableRef.$('tr.selected').removeClass('selected');
            $(this).addClass('selected');
            hub.enableButton(sendSelectionsMenu);
            console.log("selected " + category + ", " + subcategory);
            }
         });

     handleWindowResize();
     hub.enableButton(useThisDatasetButton);
     postStatus("manifest table displayed");
     hub.logEventOnServer(thisModulesName, "datasets requestDataSummary", "complete", "");
     }); // tableElement.ready

} // displayDataManifest
//----------------------------------------------------------------------------------------------------
function specifyCurrentDataset()
{
   console.log("Module.datasets 'Use Dataset' button clicked, specifyCurrentDataset: " + selectedDataSet);
 
   hub.disableAllTabsExcept([thisModulesOutermostDiv, "userDataStoreDiv", "ericTestDiv"]);
   $("#loadingDatasetMessage").css("display", "inline");
	
   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: selectedDataSet};

   hub.send(JSON.stringify(msg));

} // specifyCurrentDataset
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   $("#loadingDatasetMessage").css("display", "none");
   console.log("--- Module.datasets:  datasetSpecified");

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function test(dataSetName)
{
   console.log("Module.datasets test, on datasetName: '" + dataSetName + "'");

   QUnit.test("choose dataset '" + dataSetName + "'", function(assert) {
      hub.raiseTab("datasetsDiv");
      var desiredDataset = dataSetName;
      var dzNames = $("#datasetMenu option").map(function(opt){return this.value;});

      if($.inArray(desiredDataset, dzNames) < 0){
         alert("cannot run tests:  " + desiredDataset + " dataset not loaded");
         return;
         }

      $("#datasetMenu").val(desiredDataset);
      $("#datasetMenu").trigger("change");

      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      assert.expect(3);

      setTimeout(function(){
         assert.equal($("#datasetMenu").val(), desiredDataset);  done1();
         assert.ok($("#datasetsManifestTable tr").length >= 10); done2();
         assert.equal($("#datasetsManifestTable tbody tr").eq(0).find("td").eq(0).text(), 
                      "mRNA expression"); done3();
         //testLoadPatientHistoryTable();
         }, 5000);
      });


} // test
//----------------------------------------------------------------------------------------------------
function moduleInit()
{
  hub.addOnDocumentReadyFunction(initializeUI);
  //hub.addSocketConnectedFunction(populateDataSetMenu);
  hub.addMessageHandler("handleDataSetNames", handleDataSetNames);
  hub.addMessageHandler("displayDataManifest", displayDataManifest);
  hub.addMessageHandler("datasetSpecified", datasetSpecified);

} // moduleInit
//----------------------------------------------------------------------------------------------------
return{
   init: moduleInit,
   test: test
   }; // DataSummaryModule return value

//----------------------------------------------------------------------------------------------------
}); // DataSummaryModule

var dataSummaryModule = DataSummaryModule();
dataSummaryModule.init();
hub.registerModule("Datasets", dataSummaryModule);

//----------------------------------------------------------------------------------------------------
// move these all back inside module scope when debugging is done

var cwMarkers;
var markersTester;

//----------------------------------------------------------------------------------------------------
var markersAndTissuesModule = (function () {

  var statusDiv; 
  var cyDiv;
  var searchBox;
  var hideEdgesButton, showEdgesButton, showAllEdgesButton, clearSelectionButton, sfnButton;
  var markersFitViewButton, markersHideEdgesButton, markersShowEdgesButton;

  var nodeRestriction = [];
  var subSelectButton;
  var helpButton;
  var infoMenu;
  var zoomMode = "Spread";
  var initialZoom;
  var oldZoom;
  var edgeTypeSelector;
  var mouseOverReadout;
  var graphOperationsMenu;
  var tumorCategorizationsMenu;
  var tumorCategorizationsMenuTitle = "Tumor Groups...";
  var sendSelectionsMenu;
  var layoutMenu;
  var thisModulesName = "MarkersAndPatients";
  var thisModulesOutermostDiv = "markersAndPatientsDiv";
  var userID = "NA";

      // sometimes a module offers multiple selection destinations.
      // usually there is just one:

  var selectionDestinations = [thisModulesName];


  var sendSelectionsMenuTitle = "Send selection...";

     // the user may specify that only certain tumors, and/or certain genes
     // are to be used in any subsequent network operations -- especially
     // "show edges from selected nodes"
     // to experiment with this capability, there are two new net ops menu
     // options, which assign zero or more selected nodes to these variables,
     // which are then used (if defined) to limit the subsequent network
     // operation


//--------------------------------------------------------------------------------------------
function initializeUI ()
{

  cyDiv = $("#cyMarkersDiv");
  statusDiv = $("#markersAndPatientsStatusDiv");

  sendSelectionsMenu = hub.configureSendSelectionMenu("#cyMarkersSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                      sendSelectionsMenuTitle);

  markersFitViewButton = $("#markersFitViewButton");
  markersFitViewButton.click(function(){cwMarkers.fit(50);});
  //hub.disableButton(markersFitViewButton);
  
  markersHideEdgesButton = $("#markersHideEdgesButton");
  markersHideEdgesButton.click(hideAllEdges);
  hub.disableButton(markersHideEdgesButton);
  
  markersShowEdgesFromButton = $("#markersShowEdgesFromSelectedButton");
  markersShowEdgesFromButton.click(showEdgesFromSelectedNodes);
  hub.disableButton(markersShowEdgesFromButton);

  //$("#markersFitViewButton").click(function(){cwMarkers.fit();});
  //$("#markersHideEdgesButton").click(hideAllEdges);
  //$("#markersShowEdgesFromSelectedButton").click(showEdgesFromSelectedNodes);

  tumorCategorizationsMenu = $("#cyMarkersTumorCategorizationsMenu");
  tumorCategorizationsMenu.empty();
  tumorCategorizationsMenu.append("<option>" + tumorCategorizationsMenuTitle + "</option>");
  tumorCategorizationsMenu.change(requestTumorCategorization);

  graphOperationsMenu = $("#cyMarkersOperationsMenu");
  graphOperationsMenu.change(doGraphOperation);
  graphOperationsMenu.empty();
  graphOperationsMenu.append("<option>Network Operations...</option>");

  var operations = ["Show All Edges",
                    "Show Edges from Selected Nodes",
                    "Hide All Edges",
                    //"Connect to First Neighbors",
                    "Invert Node Selection",
                    "Clear Selections",
                    "Select All Connected Nodes",
                    "Select All Nodes with Selected Edges",
                    "Hide Unselected Nodes",
                    "Show All Nodes",
                    "Restrict Next Ops to Selected Nodes"];

  for(var i=0;i< operations.length; i++){
     var optionMarkup = "<option>" + operations[i] + "</option>";
     graphOperationsMenu.append(optionMarkup);
     } // for 


   layoutMenu = $("#markerLayouts");
   layoutMenu.change(performLayout);

   showEdgesButton = $("#cyMarkersShowEdgesButton");
   showEdgesButton.click(showEdges);
   
   showAllEdgesButton = $("#cyMarkersShowAllEdgesButton");
   showAllEdgesButton.click(showAllEdges);

   sfnButton = $("#cyMarkersSFNButton");
   sfnButton.click(selectFirstNeighbors);
   clearSelectionButton = $("#cyMarkersClearSelectionButton");
   clearSelectionButton.click(clearSelection);

   hideEdgesButton = $("#cyMarkersHideEdgesButton");
   hideEdgesButton.click(hideAllEdges);


   searchBox = $("#markersAndTissuesSearchBox");

   edgeTypeSelector = $("#markersEdgeTypeSelector");
   edgeTypeSelector.chosen();

   mouseOverReadout = $("#markersAndTissuesMouseOverReadout");
   configureCytoscape();
   $(window).resize(handleWindowResize);

   subSelectButton = $("#markersSubSelectButton");
   subSelectButton.click(subSelectNodes);

   setInterval(buttonAndMenuStatusSetter, 500);
      
   hub.disableTab(thisModulesOutermostDiv);
 
} // initializeUI
//----------------------------------------------------------------------------------------------------
// some buttons and menu are live or disabled depending on the presence of e.g., selected nodes
// or visible (non-chromosome) edges.   check those things and set their states appropriately

function buttonAndMenuStatusSetter()
{
   var selectedNodeCount = cwMarkers.nodes("node:selected").length;
   if(selectedNodeCount === 0){
      hub.disableButton(sendSelectionsMenu);
      hub.disableButton(subSelectButton);
      hub.disableButton(markersShowEdgesFromButton);
      }
   else{
      hub.enableButton(sendSelectionsMenu);
      hub.enableButton(subSelectButton);
      hub.enableButton(markersShowEdgesFromButton);
      }
      
   var visibleEdges = cwMarkers.edges().fnFilter(function(e){return(e.visible());})
                                       .fnFilter(function(e){return(e.data("edgeType") != "chromosome");}).length;
   if(visibleEdges > 0)
       hub.enableButton(markersHideEdgesButton);
   else
       hub.disableButton(markersHideEdgesButton);

} // buttonAndMenuStatusSetter
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("CyMarkers send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: nodeNames, count: nodeNames.length, source: "markers and patients module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function configureLayoutsMenu(layoutMenu){

   console.log("--- configureLayoutsMenu");
   layoutMenu.append("<option>Layouts...</option>");
   layoutMenu.append("<option> Save Current</option>");

   var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
          var result = {id:n.id(), position:n.position()};
          return (result);  
          }) // map
       ); // stringify

   localStorage.markersDefault = defaultLayout;

   var existingLayouts = Object.keys(localStorage);
   for(var i=0; i < existingLayouts.length; i++){
      if(existingLayouts[i].match("markers") !== null){
        layoutMenu.append("<option>" + existingLayouts[i] + "</option>");
        }
      } // for i

} // configureLayoutsMenu
//----------------------------------------------------------------------------------------------------
function performLayout(event){

  var chosenLayoutName = layoutMenu.val();

  if(chosenLayoutName == "Save Current"){
     var uniqueNumber = Math.floor(new Date().getTime()/1000);   // number of seconds since 1970
     newName = "markers." + (uniqueNumber - 1420414900);    // since today, very roughly
     var positions = cwMarkers.nodes().map(function(n){
           var result = {id:n.id(), position:n.position()};
           return(result);
           }); // map
     currentLayout = JSON.stringify(positions);
     localStorage[newName] = currentLayout;
     layoutMenu.append("<option>" + newName + "</option>");
     layoutMenu.val(newName);
     return;
     } // if "Save Current"

  if(Object.keys(localStorage).indexOf(chosenLayoutName) >= 0){
     var newLayout;
     newLayout = JSON.parse(localStorage[chosenLayoutName]);
     cwMarkers.nodes().positions(function(i, node){
        return{x: newLayout[i].position.x, y:newLayout[i].position.y};
         });
     } // if requested layout name is recognized
  
  layoutMenu.val("Layouts...");   // restore the title

} // performLayout
//--------------------------------------------------------------------------------------------
function sendSelection()
{
   destinationModule = sendSelectionsMenu.val();
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }
   metadata = {};
   sendSelectionToModule(destinationModule, nodeNames, metadata);
   sendSelectionsMenu.val("Send Selection...");

} // sendSelectionsMenuChanged
//--------------------------------------------------------------------------------------------
function configureCytoscape ()
{
  cwMarkers = $("#cyMarkersDiv");
  cwMarkers.cytoscape({
     hideEdgesOnViewport: true,
     hideLabelsOnViewport: true,
     boxSelectionEnabled: true,
     showOverlay: false,
     minZoom: 0.001,
     maxZoom: 1000.0,
     layout: {
       name: "preset",
       fit: true
       },
   ready: function() {
      console.log("cwMarkers ready");
      cwMarkers = this;
      initialZoom = cwMarkers.zoom();
      var debouncedSmartZoom = debounce(smartZoom, 100);
      cwMarkers.on('zoom', debouncedSmartZoom);
      cwMarkers.on('pan', debouncedSmartZoom);

      cwMarkers.on('mouseover', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val(node.id());
         });
      cwMarkers.on('mouseout', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val("");
         });
      cwMarkers.on('mouseover', 'edge', function(evt){
         var edge = evt.cyTarget;
         var d = edge.data();
         var msg = d.edgeType + ": " + d.source + " - " + d.target;
         var mutation = d.mutation;
         if(typeof(mutation) == "string")
            msg = mutation + " " + msg;
         mouseOverReadout.val(msg);
         });

      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      searchBox.keydown(doSearch);

      console.log("cwMarkers.reset");
      cwMarkers.reset();
      handleWindowResize();
      cwMarkers.edges().selectify(); // this seems to hold through session, visibility notwithstanding
      //hideAllEdges();
      configureLayoutsMenu(layoutMenu);
      cwMarkers.fit(50);
      }, // cwMarkers.ready
     }); // .cytoscape

} // configureCytoscape
//----------------------------------------------------------------------------------------------------
function handleWindowResize ()
{
   cyDiv.width(0.95 * $(window).width());
   cyDiv.height(0.8 * $(window).height());
   cwMarkers.resize();
   cwMarkers.fit(50);

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate)
{
   var timeout;
   return function() {
      var context = this, args = arguments;
      var later = function() {
         timeout = null;
         if (!immediate) func.apply(context, args);
          };
       var callNow = immediate && !timeout;
       clearTimeout(timeout);
       timeout = setTimeout(later, wait);
       if (callNow) func.apply(context, args);
       };
}
//----------------------------------------------------------------------------------------------------
// expand node size and display node labels when:
//   1) the user's coordinate space, due to zooming, has shrunk to < 600 pixels
//   2) the zoom factor is so large relative to the initial zoom (a global variable, set on startup)
// 
function smartZoom(event)
{
   //console.log("smartZoom");
   var queuedEvents = $("#cyMarkersDiv").queue();
   
   var zoomRatio = cwMarkers.zoom()/initialZoom;
   console.log("zoomRatio: " + zoomRatio);

   if(zoomRatio < 1.0){
      defaultStyle();
      return;
      }
      
   var visibleCoords = cwMarkers.extent();
   var visibleOnScreen = function(node){
      if(node.data("landmark"))
         return(false);
      //var x = node.position().x;
      //var y = node.position().y;
      var bbox = node.boundingBox();
      var visibleX = (bbox.x1 >= visibleCoords.x1 && bbox.x1 <= visibleCoords.x2) |
                     (bbox.x2 >= visibleCoords.x1 && bbox.x2 <= visibleCoords.x2);
      if(!visibleX)
        return false;
      var visibleY = (bbox.y1 >= visibleCoords.y1 && bbox.y1 <= visibleCoords.y2) |
                     (bbox.y2 >= visibleCoords.y1 && bbox.y2 <= visibleCoords.y2);
      return(visibleY);
      //return(x >= visibleCoords.x1 && x <= visibleCoords.x2 &&
      //       y >= visibleCoords.y1 && y <= visibleCoords.y2);
      };
      
   //console.log("starting calculation of visibleNodes");
   var visibleNodes = cwMarkers.nodes().fnFilter(function(node){return(visibleOnScreen(node));});		
   console.log("visibleNode count: " + visibleNodes.length);
   if(visibleNodes.length > 400){
      defaultStyle();
      //console.log("returning, visibleNode count: " + visibleNodes.length);
      return;
      }
   //console.log("need to smartZoom, setting hanlder off to discard queued events");
   //cwMarkers.off(zoom', smartZoom);

   //console.log(event);
   var newZoom = 1.0 + cwMarkers.zoom() - oldZoom;
   oldZoom = cwMarkers.zoom(); // keep this for next time

   //console.log("complete");

      // TODO: these two ratios might be reduced to just one
      
   var windowRatio = cwMarkers.width()/cwMarkers.extent().h;
   
   var fontSize = cwMarkers.extent().h/60;
   if(fontSize < 0.6)
     fontSize = 0.6;
     
   var fontSizeString = fontSize + "px";
   var borderWidthString = cwMarkers.extent().h/600 + "px";
   //console.log("--- new fontsize: " + fontSizeString);
   //console.log("--- new borderWidth: " + borderWidthString);
   cwMarkers.edges().style({"width": borderWidthString});
   
   var newWidth, newHeight, id;
   visibleNodes.map(function(node){
      newWidth = 3 *  node.data("trueWidth") / zoomRatio;
      newHeight = 3 *  node.data("trueHeight") / zoomRatio;
      id = node.id();
      node.data({zoomed: true});
      node.style({width: newWidth, height: newHeight, label: id, "font-size": fontSizeString,
                 "border-width": borderWidthString});
      });

  //console.log("visibleNode mapping complete, adding smartZoom handler back");
  //cwMarkers.on('zoom', smartZoom);


} // smartZoom
//----------------------------------------------------------------------------------------------------
function defaultStyle()
{
   var zoomedNodes = cwMarkers.nodes("[zoomed]");
   // console.log("restoring default style, zoomed node count: " + zoomedNodes.length);
   cwMarkers.edges().style({"width": "1px"});
   
   zoomedNodes.map(function(node){node.style({width: node.data('trueWidth'),
                                              height: node.data('trueHeight'),
                                              zoomed: false,
                                             'border-width': "1px",
                                             'font-size': "3px"});});

} // defaultStyle
//--------------------------------------------------------------------------------
// there are often subgroups among a selected node.
// here we opreate only on those distinguished by different node border color
// the dialog posted here provided interactive select/deselect of those originally
// selected nodes, by color.
// this function could be made smarter by being made avaialble (via the subselect button) only
// if multiple border colors are found within the currently selected nodes
//
function subSelectNodes()
{
  var selectedNodes = cwMarkers.nodes("node:selected");
  var borderColors =  jQuery.unique(selectedNodes.map(function(node){return (node.style("border-color"));}));
  console.log(JSON.stringify(borderColors));

  var content = "<form action=''>";
  for(i=0; i < borderColors.length; i++){
     var color = borderColors[i];
     var e = "<input type='checkbox' class='markersSubSelectRadioButton' name='" + color + "' checked> " + color + "<br>";
     content = content + e;
     }
  content = content + "</form>";
  button = "<br><br><button id='markersSubSelectCloseButton'>Close</button>";

  content = content + button;

  var dialog =  $('<div id="markersSubSelectDialog" />').html(content).dialog();

  $("#markersSubSelectCloseButton").click(function(){
     console.log("close dialog");
     $("#markersSubSelectDialog").remove();
     });

  $(".markersSubSelectRadioButton").click(function(e) {
      console.log("radio!"); 
      console.log(this.name + " " + this.checked);
      var color = this.name;
      var selectSubset = this.checked;
      var subsetNodes = selectedNodes.filterFn(function(node) {return(node.style("border-color") == color);});
      if(selectSubset)
         subsetNodes.select();
      else
         subsetNodes.unselect();
      }); // radio button click

} // subSelectNodes
//----------------------------------------------------------------------------------------------------
function requestTumorCategorization()
{
  var allCategoryNames = tumorCategorizationsMenu.children().map(function() {return $(this).val();}).get();
  var menuTitle = allCategoryNames[0];
  var categorizationName = tumorCategorizationsMenu.val();

  if(categorizationName === menuTitle)
     return;

  if(categorizationName === "Clear"){  // handle this case here directly
    var tumorsInGraph = cwMarkers.nodes("[nodeType='patient']");
    tumorsInGraph.forEach(function(node, index){
       node.data({subType: "unassigned"});
       node.style({'border-color': "black"});
       });
     return;
     } // clear
     
  console.log("apply " + categorizationName);
  hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "request", "");

  var msg = {cmd: "getSampleCategorization", callback: "markersApplyTumorCategorization",
             status: "request", payload: categorizationName};

  hub.send(JSON.stringify(msg));

} // requestTumorCategorization
//----------------------------------------------------------------------------------------------------
function applyTumorCategorization(msg)
{
   console.log("=== applyTumorCategorization");
   var tumorsInGraph = cwMarkers.nodes("[nodeType='patient']");
   var tumorsInTable = msg.payload.rownames;
   var tbl = msg.payload.tbl;
   hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "data received", "");

   tumorsInGraph.forEach(function(node, index){
      var nodeID = node.id();  // our convention is that this is the tumor name, eg, "TCGA.02.0014"
      var indexInTable = tumorsInTable.indexOf(nodeID);
      if(indexInTable >= 0){
         var cluster = tbl[indexInTable][0];
         var color = tbl[indexInTable][1];
         node.data({subType: cluster});
         node.style({'border-color': color});
         }
      else{
         node.data({subType: "unassigned"});
         node.style({'border-color': "black"});
         }
       }); // forEach

  cwMarkers.style().update();
  postStatus("applyTumorCategorization complete");
  hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "node subType assigned", "");

} // applyTumorCategorization
//----------------------------------------------------------------------------------------------------
function doGraphOperation()
{
   var operation = graphOperationsMenu.val();

   switch(operation){
      case "Show All Edges":
         showAllEdges();
         break;
      case "Show Edges from Selected Nodes":
         //showEdgesFromSelectedNodes();
         showEdgesFromSelectedNodes();
         break;
      case "Hide All Edges":
         hideAllEdges();
         break;
      case "Invert Node Selection":
         invertSelection();
         break;
      case "Clear Selections":
         cwMarkers.filter('node:selected').unselect();
         break;
      case "Select All Connected Nodes":
         selectAllConnectedNodes();
         break;
      case "Select All Nodes with Selected Edges":
        selectAllNodesConnectedBySelectedEdges();
        break;
      case "Hide Unselected Nodes":
         cwMarkers.filter("node:unselected").hide();
         break;
      case "Show All Nodes":
         cwMarkers.filter('node:hidden').show();
         break;
      case "Restrict Next Ops to Selected Nodes":
         restrictNextOpsToSelectedNodes();
         break;
      default:
         console.log("unrecoginized graph operation requested from menu: " + operation);
      } // switch

      // restore menu to initial condition, with only title showing
   graphOperationsMenu.val("Network Operations...");

} // doGraphOperation
//----------------------------------------------------------------------------------------------------
function clearSelection ()
{
   cwMarkers.elements().unselect();
}
//----------------------------------------------------------------------------------------------------
function selectFirstNeighbors ()
{
  selectedNodes = cwMarkers.filter('node:selected');
  showEdgesForNodes(cwMarkers, selectedNodes);
}
//----------------------------------------------------------------------------------------------------
function invertSelection ()
{
   selected = cwMarkers.filter("node:selected");
   unselected = cwMarkers.filter("node:unselected");
   selected.unselect();
   unselected.select();
}
//----------------------------------------------------------------------------------------------------
function hideAllEdges ()
{
     // hide all edges besides chromsome edges
  cwMarkers.edges().fnFilter(function(edge) {
     return(edge.data("edgeType") != "chromosome");
     }).hide();

} // hideAllEdges
//----------------------------------------------------------------------------------------------------
function showAllEdges ()
{
   var edgeTypesToDisplay = edgeTypeSelector.val();

   console.log("edgeTypeToDisplay: " + edgeTypesToDisplay);

   if(edgeTypesToDisplay === null){
      return;
      }

   for(var e=0; e < edgeTypesToDisplay.length; e++){
      var type =  edgeTypesToDisplay[e];
      selectionString = '[edgeType="' + type + '"]';
      //console.log(" showAllEdges selection string: " + selectionString);
      cwMarkers.edges(selectionString).show();
      } // for e

} // showAllEdges
//----------------------------------------------------------------------------------------------------
function zoomSelected()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 100);
}
//----------------------------------------------------------------------------------------------------
function handleIncomingIdentifiers(msg)
{
   console.log("Module.markers, handleIncomingIdentifiers");
      // expect 3 payload fields: value, count, source
   var ids = msg.payload.value; 
   if(typeof(ids) == "string")
      ids = [ids];
   //intersectingIDs = hub.intersectionOfArrays(ids, nodeNames())
   intersectingIDs = hub.intersectionOfArrays(ids, nodeIDs());
   console.log("found ids: " + intersectingIDs.length);

   if(intersectingIDs.length > 0){
      selectNodesByID(intersectingIDs);
      }
   else{
      errorMessage = "No overlap with genes or tissue sample IDs:  <br><br>" +
                      ids.join(", ");
      title = ids.length + " unrecognized identifiers";
      console.log("+++++++++++ creating error div");
      $('<div id="markersIncomingIdentifiersErrorDialog" />').html(errorMessage).dialog({title: title, width:600, height:300});
      }

   console.log("about to post status from incoming identifiers");
   postStatus("incoming identifiers: " + ids.length);

   hub.raiseTab(thisModulesOutermostDiv);

} // handleIncomingIdentifiers
//----------------------------------------------------------------------------------------------------
  // run all that should happen when this module receives an incoming selection of patientIDs
function demoMarkersIncomingSelectionOfIDs()
{

   names = ["TCGA.06.0210", "TCGA.02.0106", "TCGA.02.0111",
            "TCGA.06.0194", "TCGA.06.0164", "TCGA.06.0409", "TCGA.02.0004",
            "TCGA.02.0051", "TCGA.08.0390", "TCGA.02.0025", "TCGA.08.0392",
            "TCGA.02.0079", "TCGA.12.0620", "TCGA.08.0373", "TCGA.06.0645",
            "TCGA.06.0192", "TCGA.12.0776", "TCGA.12.0778", "TCGA.06.0750",
            "TCGA.06.0878", "TCGA.14.0789", "TCGA.06.0881", "BCL11A",
            "BRCA1", "MDM2", "PIK3R1", "ABCA1", "CDK6", "CNTRL", "FH",
            "IFNA1", "LMO2", "PRKCA", "RELA", "STK11", "ZEB1", "CCNB1IP1",
            "CREB3L1", "GDF2", "OR4K2", "PRKCH", "WAS"];

   subset = [];
   for(var i=0; i < 10; i++)
     subset.push(names[getRandomInt(0, names.length -1)]);

   selectNodes(subset);

} // demoIncomingSelectionOfPatientIDs
//----------------------------------------------------------------------------------------------------
function allNodeIDs()
{
   ids = [];
   allNodes = cwMarkers.nodes();

   for(i=0; i < allNodes.length; i++)
       ids.push(allNodes[i].data("id"));

   return(ids);

} // allNodeIDs
//----------------------------------------------------------------------------------------------------
function showEdges()
{
   hideAllEdges();   // is this wise?

   var edgeTypesToDisplay = edgeTypeSelector.val();
   if(edgeTypesToDisplay === null){
      hideAllEdges();
      return;
      }

   var selectedNodes = selectedNodeIDs(cwMarkers);

   //console.log(" newEdgeTypeSelection (" + edgeTypesToDisplay.length + 
   //            "), selectedNodes: " + selectedNodes.length);

   if(selectedNodes.length > 0) { // show edges to and from all selected nodes
     showEdgesForNodes(cwMarkers, selectedNodes);
     }

} // showEdges
//----------------------------------------------------------------------------------------------------
function zoomSelection()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 50);
}
//----------------------------------------------------------------------------------------------------
function selectedNodeIDs(cw)
{
   ids = [];
   noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     ids.push(noi[n].data('id'));
     }
  return(ids);

} // selectedNodeIDs
//----------------------------------------------------------------------------------------------------
function selectedNodeNames(cw)
{
   var names = [];
   var noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }

  return(names);

} // selectedNodeNames
//----------------------------------------------------------------------------------------------------
function showEdgesFromSelectedNodes()
{
   var targets = nodeRestriction;
   var selectedNodes = cwMarkers.nodes("node:selected");
   var neighbors = selectedNodes.neighborhood();
   var candidateEdges = neighbors.filterFn(function(e){
       if(e.isEdge()) return (e);
       });

   candidateEdges = candidateEdges.fnFilter(function(edge){
      return(edgeTypeSelector.val().indexOf(edge.data("edgeType")) >= 0);
      });

   if(targets.length === 0){
      candidateEdges.show();
      return;
      }

   function intersects(array1, array2){
      var size = array1.filter(function(n) {return (array2.indexOf(n) != -1);}).length;
      return(size > 0);
      }

   candidateEdges.filterFn(function(edge){
      var actual=edge.connectedNodes().map(function(node){return node.id();});
      return(intersects(actual, targets));
       }).show();

} // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function selectSourceAndTargetNodesOfEdges(cw, edges)
{
  //var eoi = cwMarkers.filter('edge:visible');
  var notChromosomal = function(edge){return(edge.data("edgeType") !== "chromosome");};
  eoi = edges.filterFn(notChromosomal);

  var filterStrings = [];

  for(var i=0; i < eoi.length; i++){
     edge = eoi[i];
     targetID = edge.target().data("id");
     sourceID = edge.source().data("id");
     var sourceFilterString = '[id="' + sourceID + '"]';
     var targetFilterString = '[id="' + targetID + '"]';
     filterStrings.push(sourceFilterString);
     filterStrings.push(targetFilterString);
     } // for i

   var nodesToSelect = cw.nodes(filterStrings.join());
   nodesToSelect.select();

} // selecteSourceAndTargetNodesOfEdge
//----------------------------------------------------------------------------------------------------
// todo: massive inefficiencies here
function showEdgesForNodes(cw, nodes)
{

  var edgeTypes = edgeTypeSelector.val();
  console.log("=== showEdgesForNodes, edgeType count: " + edgeTypes.length);
  //console.log(edgeTypes);

  if(edgeTypes.length === 0)
      return;

  var filterStrings = [];

  setTimeout(function(){
     for(var e=0; e < edgeTypes.length; e++){
        var edgeType = edgeTypes[e];
        for(var n=0; n < nodes.length; n++){
          var nodeID = nodes[n].data("id");
          var sourceFilterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
          var targetFilterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
          filterStrings.push(sourceFilterString);
          filterStrings.push(targetFilterString);
          } // for n
        } // for e

      //console.log("filterString count: " + filterStrings.length);
      filter = filterStrings.join();
      //console.log("filter created, about to apply...");
      var existingEdges = cw.edges(filter);
      //console.log("filtering complete");
      if(existingEdges.length > 0) {
         //console.log("about to show edges");
         existingEdges.show();
         //console.log("edges shown...");
         }
     }, 0); // setTimeout

} // showEdgesForNodes
//----------------------------------------------------------------------------------------------------
function selectAllConnectedNodes()
{
    var selectedEdges = cwMarkers.filter("edge:visible");
    selectedEdges = selectedEdges.filterFn(function(e){return (e.data("edgeType") !== "chromosome");});
    if(selectedEdges.length > 0)
       selectSourceAndTargetNodesOfEdges(cwMarkers, selectedEdges);

} // selectAllConnectedNodes
//----------------------------------------------------------------------------------------------------
function selectAllNodesConnectedBySelectedEdges()
{
    edges = cwMarkers.filter("edge:selected");
    console.log(" selected edge count: " + edges.length);
    if(edges.length === 0)
      return;
    for(var e=0; e < edges.length; e++){
       selectNodes(edges[e].target().data("name"));
       selectNodes(edges[e].source().data("name"));
       } // for e

} //selectAllNodesConnectedBySelectedEdges
//----------------------------------------------------------------------------------------------------
function showEdgesForSelectedNodes(cw, edgeTypes)
{
   var nodeIDs = selectedNodeIDs(cw);
   for(var n=0; n < nodeIDs.length; n++){
      nodeID = nodeIDs[n];
      for(var e=0; e < edgeTypes.length; e++){
         edgeType = edgeTypes[e];
         filterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         filterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         } // for e
      } // for n

} // showEdgesForSelectedNodes
//----------------------------------------------------------------------------------------------------
function restrictNextOpsToSelectedNodes()
{
  var nodes = cwMarkers.nodes("node:selected"); // .filter("[nodeType='gene']");
  if(nodes.length === 0){
     nodeRestriction = [];
     }
  else{
     nodeRestriction = nodes.map(function(node){return (node.id());});
     }

} // restrictNextOpsToSelectedNodes
//----------------------------------------------------------------------------------------------------
function nodeNames()
{
  var nodes = cwMarkers.filter("node:visible");
  var result = [];
  for(var i=0; i < nodes.length; i++){
    result.push(nodes[i].data().label);
    } // for i

  return(result);

} // nodeNames
//----------------------------------------------------------------------------------------------------
function nodeIDs()
{
   return(cwMarkers.nodes().map(function(node){return (node.id());}));
}
//----------------------------------------------------------------------------------------------------
function upperCaseNodeIDs()
{
   return(nodeIDs().map(function(node){return(node.toUpperCase());}));
}
//----------------------------------------------------------------------------------------------------
// todo: build up the filter string first, then send it all at once
function selectNodes(nodeNames)
{
  console.log("Module.markers::selectNodes");
  //console.log(nodeNames);

  if(typeof(nodeNames) == "string")   // trap scalar, but expect and support arrays
     nodeNames = [nodeNames];

  var allNodes = cwMarkers.nodes().map(function(n){return (n.id());});
  var allNodesUpperCase = allNodes.map(function(name){return (name.toUpperCase());});

  for(var i=0; i < nodeNames.length; i++){
    var nodeName = nodeNames[i].toUpperCase();  // depends upon this conv
    var index = allNodesUpperCase.indexOf(nodeName);
    if(index >= 0){
      var actualNodeID = allNodes[index];
      var s = "cwMarkers.filter('node[id=\"" + actualNodeID + "\"]').select()";
       //console.log("markers selectNodes: " + s);
       eval (s);
       } // if found, index >= 0
    } // for i

} // selectNodes
//----------------------------------------------------------------------------------------------------
   // todo: build up the filter string first, then send it all at once
function selectNodesByID(nodeIDs) {

  if(typeof(nodeIDs) == "string")   // trap scalar, but expect and support arrays
     nodeIDs = [nodeIDs];

  console.log("about to select nodes by id: " + nodeIDs.length);
  console.log(nodeIDs);

  for(var i=0; i < nodeIDs.length; i++){
    s = "cwMarkers.filter('node[id=\"" + nodeIDs[i] + "\"]').select()";
    console.log(s);
    eval (s);
    } // for i

} // selectNodesByID
//----------------------------------------------------------------------------------------------------
function doSearch(e)
{
   var keyCode = e.keyCode || e.which;

   if (keyCode == 13) {
      var searchString = searchBox.val().toUpperCase();
      console.log("searchString: " + searchString);
      var idsActual = nodeIDs();
      var idsUpper = upperCaseNodeIDs();
      var hits = idsUpper.filter(function(id) {return(id.indexOf(searchString) === 0);});
      var hitIndices = hits.map(function(hit) {return(idsUpper.indexOf(hit));});
      var hitsActual = hitIndices.map(function(hit) {return(idsActual[hit]);});
      selectNodes(hitsActual);
      } // if 13 (return key)

} // doSearch
//----------------------------------------------------------------------------------------------------
function displayMarkersNetwork(msg)
{
   console.log("--- Module.markers: displayMarkersNetwork");

   hub.logEventOnServer(thisModulesName, "display markers network", "data received", "");

   if(msg.status == "success"){
      console.log("nchar(network): " + msg.payload.length);
      var json = JSON.parse(msg.payload);
      cwMarkers.remove(cwMarkers.edges());
      cwMarkers.remove(cwMarkers.nodes());
      console.log(" after JSON.parse, json.length: " + json.length);
      console.log("  about to add json.elements");
      cwMarkers.add(json.elements);
      console.log("  about to add  json.style");
      cwMarkers.style(json.style);
      console.log("   hiding edges");
      cwMarkers.edges().hide();
      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      cwMarkers.nodes().unselect();
        // map current node degree into a node attribute of that name
      cwMarkers.nodes().map(function(node){node.data({degree: node.degree(), trueWidth: node.width(), trueHeight: node.height()});});

      var edgeTypes = hub.uniqueElementsOfArray(cwMarkers.edges().map(function(edge){
                               return(edge.data("edgeType"));}
                               ));
      updateEdgeSelectionWidget(edgeTypes);  // preserve only known edgeTypes
      cwMarkers.fit(20);
      var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
                                         return({id:n.id(), position:n.position()});}));
      localStorage.markersDefault = defaultLayout;
      hub.logEventOnServer(thisModulesName, "display markers network", "complete", "");

        //postStatus("markers network displayed");  // deferred; set when the category menu is configured

      hub.logEventOnServer(thisModulesName, "getSampleCategorizationNames", "request", "");

      var msg2 = {cmd: "getSampleCategorizationNames", callback: "configureSampleCategorizationMenu",
                  status: "request", payload: ""};
      hub.send(JSON.stringify(msg2));
      }
   else{
     console.log("displayMarkersNetwork error: " + msg.payload);
     }

} // displayMarkersNetwork
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// ensure that only edgeTypes in current network are offered in the selection widget
function updateEdgeSelectionWidget(edgeTypes)
{
     // loop over currently offered edge types
   var options = $("#markersEdgeTypeSelector").children();
   for(var i=0; i < options.length; i++){
      var optionElement = options[i];
      var optionValue = optionElement.value;
      var found = jQuery.inArray(optionValue, edgeTypes) >= 0;
      console.log("checking option '" + optionValue + "':  " + found);
      if(!found){
         console.log("  deleting selector option " + optionValue);
         $("#markersEdgeTypeSelector option[value='" + optionValue + "']").remove();
         } // unrecognized edge type
      }
   $("#markersEdgeTypeSelector").trigger("chosen:updated");

} // updateEdgeSelectionWidget
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the g.markers.json network from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

   hub.logEventOnServer(thisModulesName, "display markers network", "request", "");

   var newMsg = {cmd: "getMarkersNetwork",  callback: "displayMarkersNetwork", status: "request", payload: datasetName};
   hub.send(JSON.stringify(newMsg));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function configureSampleCategorizationMenu(msg)
{
   console.log("=== configureSampleCategorizationMenu");
   //console.log(msg.payload);
   tumorCategorizationsMenu.empty();
   var categorizations = msg.payload;

   if(typeof categorizations == "string") 
   	 categorizations = [categorizations];

   var titleOption = "Tumor Groups...";

   tumorCategorizationsMenu.append("<option>" + titleOption + "</option>");
   tumorCategorizationsMenu.append("<option>Clear</option>");

   for(var i=0; i < categorizations.length; i++){
     tumorCategorizationsMenu.append("<option>" + categorizations[i] + "</option>");
     } // for i

   tumorCategorizationsMenu.val(titleOption);
   hub.logEventOnServer(thisModulesName, "getSampleCategorizationNames",  "complete", "");
   
   hub.enableTab(thisModulesOutermostDiv);
   postStatus("markers network displayed");

} // configureSampleCategorizationMenu
//----------------------------------------------------------------------------------------------------

 return{
     init: function(){
        hub.addMessageHandler("sendSelectionTo_MarkersAndPatients", handleIncomingIdentifiers);
        hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
        hub.addMessageHandler("datasetSpecified", datasetSpecified);
        hub.addMessageHandler("displayMarkersNetwork", displayMarkersNetwork);
        hub.addMessageHandler("configureSampleCategorizationMenu", configureSampleCategorizationMenu);
        hub.addMessageHandler("markersApplyTumorCategorization", applyTumorCategorization);
        hub.addOnDocumentReadyFunction(initializeUI);
       }
     };

   }); // markersAndTissuesModule
//----------------------------------------------------------------------------------------------------
markersModule = markersAndTissuesModule();
markersModule.init();

// markersAndSamples/Test.js
//------------------------------------------------------------------------------------------------------------------------
var MarkersAndSamplesTestModule = (function () {

       // for observing relatively small scale status changes: i.e., network loaded and displayed
       // the div watched here is in widget.html

    var markersAndSamplesStatusObserver = null;
    var testStatusObserver = null;   // modified at the end of each dataset test

    var minorStatusDiv = "#markersAndPatientsStatusDiv";
    var majorStatusDiv = "#markersTestStatusDiv";

       // to detect when the full test of a dataset is complete, so that the next dataset can be tested
       // the div watched here is in test.html


//------------------------------------------------------------------------------------------------------------------------
function runTests(datasetNames, reps, exitOnCompletion)
{
     // run through <reps> repetitions of the test
     // condition the next test upon the completion of the preceeding one,
     // which is detected by a change to the majorStatusDiv
     // minorStatusDiv is used to gate successive tests applied -within-
     // a dataset
     
      
   console.log("===================================== Test.markers: runTests");
   console.log("Test.markers: runTests: " + JSON.stringify(datasetNames));
   console.log("reps: " + reps);
   console.log("exitOnCompletion: " + exitOnCompletion);
   
   var datasetIndex = -1;
   
   var config = {attributes: true, childList: true, characterData: true};
   var target =  document.querySelector(majorStatusDiv);

      // define a function to be called whenever the testStatusDiv changes,
      // which is our signal that the next test is ready to run.
      // the first test is kicked off when we -- after setting up and
      // configuring the observer -- manually (see below: "start testing")
      // change the target which the observer watches.
      // there may be a better way, but for now we delete and recreate
      // the observer at the end of each test.
      // note also that the next dataset is determined inside this function
      // and that the function refers to itself.

   var onMutation = function(mutations){
      mutation = mutations[0];
      testStatusObserver.disconnect();
      testStatusObserver = null;
      var id = mutation.target.id;
      var msg = $(majorStatusDiv).text();
      console.log("test status changed, text: " + msg);
      datasetIndex++;
      if(datasetIndex < (datasetNames.length * reps)){
         console.log("about to test dataset " + datasetNames[datasetIndex]);      
         testStatusObserver = new MutationObserver(onMutation);
         testStatusObserver.observe(target, config);
         if(datasetIndex < (datasetNames.length * reps))
            testLoadDataSetDisplayNetworkSendIDs(datasetNames[datasetIndex % datasetNames.length]);
         }
      else{
         console.log("mutation observer function detected end of datasets");
         if(exitOnCompletion){
            var payload = {errorCount: Object.keys(sessionStorage).length,
                           errors: JSON.stringify(sessionStorage)};
            var exitMsg = {cmd: "exitAfterTesting", callback: "", status: "request", payload: payload};
            console.log("about to send exitAfterTesting msg to server");
            hub.send(JSON.stringify(exitMsg));
            } // if exitOnCompletion
         } // else: datasets exhaused
      };

   testStatusObserver = new MutationObserver(onMutation);
   testStatusObserver.observe(target, config);

   $(majorStatusDiv).text("start testing");

} // runTests
//------------------------------------------------------------------------------------------------------------------------
function testLoadDataSetDisplayNetworkSendIDs(dataSetName)
{
   var testTitle = "testLoadDataSetDisplayNetworkSendIDs";
   console.log(testTitle);

      // when our module receives the resulting 'datasetSpecified' msg, which includes the dataset's manifest
      // in its payload, it requests 
      //   - the markers network: to be displayed by cyjs
      //   - sampleCategorizationNames, to populate the dropdown menu
      // when the network is loaded, the statusDiv is updated, which is detected here, and we
      // check to see that a reasonable number of nodes are contained in the loaded graph.
      // when those tests are over, we then cascade through a number of gui operations: search, node selections
      // network operations

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        hub.raiseTab("markersAndPatientsDiv");
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var msg = $("#markersAndSamplesStatusDiv").text();
        QUnit.test("markersAndSamples loaded: " + dataSetName, function(assert) {
           var nodeCount = cwMarkers.nodes().length;
           var edgeCount = cwMarkers.edges().length;
           console.log("markersAndSamples loaded, with " + nodeCount + " nodes and " + edgeCount + " edges.");
           assert.ok(nodeCount > 10, dataSetName + " nodeCount > 10");
           assert.ok(edgeCount > 10, dataSetName + " edgeCount > 10");
           testSearch();
           });
        }); // new MutationObserver
      } // if null mutation observer


   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   var msg = {cmd: "specifyCurrentDataset", callback: "datasetSpecified", status: "request", payload:  dataSetName};

   console.log("about to send specifyCurrentDataset msg to server: " + dataSetName);
   hub.send(JSON.stringify(msg));

} // testLoadDataSetDisplayNetworkSendIDs
//------------------------------------------------------------------------------------------------------------------------
//   1) clear selection
//   2) find the node with highest degree
//   3) select that node
//   4) show edges, select all connected
//   5) make sure selected node count minus one is equal to degree of the original node
function testSearch()
{
   console.log("--- Test.markers testSearch");
   var searchBox = $("#markersAndTissuesSearchBox");
   setTimeout(function(){searchBox.val("");}, 0);
   cwMarkers.nodes().unselect();
   var netOpsMenu = $("#cyMarkersOperationsMenu");
   var nodes = cwMarkers.nodes().filterFn(function(node){return (node.data("nodeType") === "patient");});
   var nodesByDegree = nodes.map(function(node){return {id:node.data("id"), degree:node.degree()};});
   var mySort = function(a,b) {return(b.degree - a.degree);};
   var mostConnectedNode = nodesByDegree.sort(mySort)[0];
   console.log("mostConnectedNode: " + JSON.stringify(mostConnectedNode));

   QUnit.test("markers testSearch", function(assert){
     netOpsMenu.val("Hide All Edges");
     netOpsMenu.trigger("change");
     cwMarkers.filter("node:selected").unselect();
     assert.equal(cwMarkers.filter("node:selected").length, 0, "zero selected nodes");
     setTimeout(function(){searchBox.val(mostConnectedNode.id);}, 0);
     searchBox.trigger(jQuery.Event("keydown", {which: 13}));
     assert.equal(cwMarkers.filter("node:selected").length, 1, "one selected node from search box: " +
                  mostConnectedNode.id);
     netOpsMenu.val("Show Edges from Selected Nodes");
     netOpsMenu.trigger("change");
     netOpsMenu.val("Select All Connected Nodes");
     netOpsMenu.trigger("change");
     console.log("about to check for selected nodes");
     var expectedSelectionCount = mostConnectedNode.degree + 1; // include self
     var nodes = cwMarkers.nodes();
     var nodeNames = JSON.stringify(cwMarkers.nodes().map(function(node){return node.id();}));
     var selectedNodes = cwMarkers.filter("node:selected");
     var selectedNodeNames = JSON.stringify(selectedNodes.map(function(node){return node.id();}));
     console.log("selected nodes after filter: " + selectedNodeNames);
     assert.ok(cwMarkers.filter("node:selected").length == expectedSelectionCount,
               "found expected number of selected nodes: " + selectedNodes.length);
     setTimeout(function(){searchBox.val("");}, 0);
     cwMarkers.nodes().unselect();
     testSendGoodIDs();
     });

}  // testSearch
//------------------------------------------------------------------------------------------------------------------------
function testSendGoodIDs()
{
   console.log("entering Test.markers:testSendGoodIDs");

   var title = "testSendIDs";
   console.log(title);
   var maxNodes = 10;
   var totalNodes = cwMarkers.nodes().length; 
   if(maxNodes > totalNodes)
      maxNodes = totalNodes;

      // first test is to clear any existing selection, then send 10 node
      // ids (simple name strings) taken from the network itself.
      // these nodes are sent to the network using hub.send
      // we then check to see that these 10 nodes are selected in cyjs

   cwMarkers.filter("node:selected").unselect();
   var ids = cwMarkers.nodes().map(function(node) {return node.id();}).slice(0, maxNodes);
     // selection of incoming identifiers can be a bit promiscuous.  for instance,
     // sending "Y" will select "Y" and "YWHAE"

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var statusMsg = $(minorStatusDiv).text();
        QUnit.test(title, function(assert) {
           console.log("-- in QUnit.test for testSendIDs " + 7 + "  statusMsg: " + statusMsg);
           var selectedNodes = cwMarkers.filter("node:selected").map(function(node){return node.id();});
           assert.ok(selectedNodes.length >= maxNodes, "incoming " + maxNodes + " nodes, selected: " +
                     selectedNodes.length);
           testSendBadIDs();
           });
        }); // new MutationObserver
      } // if null mutation observer

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   console.log("testSendIDs, sending " + JSON.stringify(ids));
   var payload = {value: ids, count: ids.length, source: "markers/Test.js::testSendIDs"};
   var msg = {cmd: "sendSelectionTo_MarkersAndPatients", callback: "", status: "request", payload:  payload};

   hub.send(JSON.stringify(msg));

} // testSendGoodIDs
//------------------------------------------------------------------------------------------------------------------------
function testSendBadIDs()
{
   console.log("entering Test.markers:testSendBadIDs");

   var title = "testSendBadIDs";
   console.log(title);
   var maxNodes = 10;
   var totalNodes = cwMarkers.nodes().length; 
   if(maxNodes > totalNodes)
      maxNodes = totalNodes;

      // first test is to clear any existing selection, then send 10 node
      // ids (simple name strings) taken from the network itself.
      // these nodes are sent to the network using hub.send
      // we then check to see that these 10 nodes are selected in cyjs

   cwMarkers.filter("node:selected").unselect();
   var badIDs = ["bogus1", "bogus2", "bogus3"];

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var statusMsg = $(minorStatusDiv).text();
        QUnit.test(title, function(assert) {
           console.log("-- in QUnit.test for testSendIDs " + 7 + "  statusMsg: " + statusMsg);
           var selectedNodes = cwMarkers.filter("node:selected").map(function(node){return node.id();});
           assert.equal(selectedNodes.length, 0);
           var errorDialog = $("#markersIncomingIdentifiersErrorDialog");
           console.log("error dialog count: " + errorDialog.length);
           var errorText = errorDialog.text();
           console.log("======== badIDs errorText");
           console.log(errorText);
           for(var i=0; i < badIDs.length; i++){
              assert.ok(errorText.indexOf(badIDs[i]) > 0);
              } // for i
           errorDialog.remove();
           testSendMixedIDs();
           });
        }); // new MutationObserver
      } // if null mutation observer

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   console.log("testSendBadIDs, sending " + JSON.stringify(badIDs));
   var payload = {value: badIDs, count: badIDs.length, source: "markers/Test.js::testSendIDs"};
   var msg = {cmd: "sendSelectionTo_MarkersAndPatients", callback: "", status: "request", payload:  payload};

   hub.send(JSON.stringify(msg));

} // testSendBadIDs
//------------------------------------------------------------------------------------------------------------------------
function testSendMixedIDs()
{
   console.log("entering Test.markers:testSendMixedIDs");

   var title = "testSendMixedDs";
   console.log(title);
   var maxNodes = 3;
   var totalNodes = cwMarkers.nodes().length; 
   if(maxNodes > totalNodes)
      maxNodes = totalNodes;

   var goodIDs = cwMarkers.nodes().map(function(node) {return node.id();}).slice(0, maxNodes);

      // first test is to clear any existing selection, then send 10 node
      // ids (simple name strings) taken from the network itself.
      // these nodes are sent to the network using hub.send
      // we then check to see that these 10 nodes are selected in cyjs

   cwMarkers.filter("node:selected").unselect();
   var badIDs = ["bagus1", "begus2", "bigus3"];
   var ids = goodIDs.concat(badIDs);

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var statusMsg = $(minorStatusDiv).text();
        QUnit.test(title, function(assert) {
           console.log("-- in QUnit.test for testSendIDs " + 7 + "  statusMsg: " + statusMsg);
           var selectedNodes = cwMarkers.filter("node:selected").map(function(node){return node.id();});
           assert.ok(selectedNodes.length >= goodIDs.length);
              // at present (we may wish to change) when some ids work, no error dialog is posted
              /************
              var errorDialog = $("#markersIncomingIdentifiersErrorDialog");
              console.log("error dialog count: " + errorDialog.length);
              var errorText = errorDialog.text();
              console.log("======== mixedIDs errorText");
              console.log(errorText);
              for(var i=0; i < badIDs.length; i++)
                 assert.ok(errorText.indexOf(badIDs[i]) >= 0);
              for(i=0; i < goodIDs.length; i++)
                 assert.equal(errorText.indexOf(goodIDs[i]), -1);
              errorDialog.remove();
              **************/
           testColorTumorsByCategory();
           });
        }); // new MutationObserver
      } // if null mutation observer

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   console.log("testSendIDs, sending " + JSON.stringify(ids));
   var payload = {value: ids, count: ids.length, source: "markers/Test.js::testSendIDs"};
   var msg = {cmd: "sendSelectionTo_MarkersAndPatients", callback: "", status: "request", payload:  payload};

   hub.send(JSON.stringify(msg));

} // testSendMixedIDs
//------------------------------------------------------------------------------------------------------------------------
function testColorTumorsByCategory()
{
   console.log("entering Test.markers:testColorTumorsByCategory");

   var title = "testColorTumorsByCategory";
   console.log(title);
     // set all tumor node-border colors to white: no tumor classification coloring scheme
     // would a) consist of just one group and b) mark it with such a nondescript color
     // then manipulate the menu, make sure that at least some of the colors have changed
     
   var tumorNodes = cwMarkers.nodes().fnFilter(function(node){ return(node.data("nodeType") == "patient");});
   tumorNodes.map(function(node){node.data({"subType": "unassigned"});});
   //var subTypes = jQuery.unique(tumorNodes.map(function(node){return(node.data("subType"));}));
   var subTypes = hub.uniqueElementsOfArray(tumorNodes.map(function(node){return(node.data("subType"));}));
   console.log("before tumor category test, should be just one subType: " + subTypes.length);
   
   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        console.log("mutation observer for testColorTumorsByCategory");
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var statusMsg = $(minorStatusDiv).text();
        QUnit.test(title, function(assert) {
           console.log("-- in QUnit.test for testColorTumorsByCategory");
           var subTypes = hub.uniqueElementsOfArray(tumorNodes.map(function(node){return(node.data("subType"));}));
           console.log(" during tumor category test, should be > one subType: " + subTypes.length);
           assert.ok(subTypes.length > 1);  // more than just the single "unassigned" enforced above;
           markEndOfTestingDataSet();
           });
        }); // new MutationObserver
      } // if null mutation observer

     // the menu value has been changed above.  now elicit action

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   var allCategoryNames = $("#cyMarkersTumorCategorizationsMenu").children().map(function() {return $(this).val();}).get();
   console.log("--- still setting up testColorTumorsByCateory, names: ");
   console.log(JSON.stringify(allCategoryNames));
   var firstCategory = allCategoryNames[2];  // the 0th name is always the menu title. 1st is "Clear". choose the next one
   $("#cyMarkersTumorCategorizationsMenu").val(firstCategory);
   $("#cyMarkersTumorCategorizationsMenu").trigger("change");

} // testColorTumorsByCategory
//------------------------------------------------------------------------------------------------------------------------
function testColorTumorsByClassification()
{
   var testTitle = "testColorTumorsByClassifictaion";
   console.log(testTitle);

      // TCGA.02.0033 is in all three of our current gbm-related, public, TCGA datasets

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        //hub.raiseTab("markersAndPatientsDiv");
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var msg = $("#markersAndSamplesStatusDiv").text();
        QUnit.test(title, function(assert) {
           assert.ok(10 === 10, msg);
           });
        }); // new MutationObserver
      } // if null mutation observer


   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   var dataSetName = "TCGAbrain";
   var msg = {cmd: "specifyCurrentDataset", callback: "datasetSpecified", status: "request", payload:  dataSetName};

   hub.send(JSON.stringify(msg));

} // testColorTumors
//------------------------------------------------------------------------------------------------------------------------
function markEndOfTestingDataSet()
{
  console.log("end of testing dataset");
  $(majorStatusDiv).text("dataset complete");
  $("#testManagerLoopStatusDiv").text("Test.markers, datasets complete");
  
} // markEndOfTestingDataSet
//------------------------------------------------------------------------------------------------------------------------
function initialize()
{
   console.log("--- initializing markersAndSamples/Test.js");

} // initialize
//------------------------------------------------------------------------------------------------------------------------
return{
   init: initialize,
   run: runTests
   }; // module return value

//------------------------------------------------------------------------------------------------------------------------
}); // MarkersAndSamplesTestModule
markersTester = MarkersAndSamplesTestModule();
moduleTests.push(markersTester);



</script>

<body>

<div id="oncoscapeTabs">
   <ul>
     <li><a href="#datasetsDiv">Datasets</a></li>
     <li><a href="#markersAndPatientsDiv">Markers</a></li>
     <li><a href="#markersTestDiv">Tests</a></li>
   </ul>

<style>
</style>

<div id="datasetsDiv" style="height:auto">
  <div id="datasetsStatusDiv" style="display:none"></div>
  <div id="dataSummaryControlsDiv">
     <span id="selectDataSetMenuLabel" style="margin-left: 20px;">Available Datasets</span>
     <select type="button" id="datasetMenu" style="margin: 5px;"><option> </option></select>
     <button id="selectDatasetButton">Use Dataset</button>
	 <span id="loadingDatasetMessage" style="display:none; margin-left:10px">Loading Dataset...</span>
     <select type="button" id="datasetsSendSelectionsMenu" style="float:right; margin:15px; display: none"></select>
    <div id="oncoscapeLogo" style="float:right; margin-right:0.5em">	<img width="175" src="http://oncoscape.sttrcancer.org/oncoscape/images/oncoscape_logo_TM.png" alt="Oncoscape"/></div>
  </div>

   <div id="dataSetNamesOutputDiv" style="margin: 20px;"></div>

   <div id="dataSummaryOutputDiv" style="margin: 20px;overflow-x:auto">
      <div id="datasetInstructions">Please select a dataset from the above menu.</div>
      <table id="datasetsManifestTable" class="display" cellpadding="0" cellspacing="0" style="margin:0px; width:auto; display:none; border:none"></table>
   </div>
</div>

<style>

#cyMarkersDiv {
  background-color: white;  // medium light gray
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  margin-top: 2px;
  margin-left: 0px;
  padding: 0px;
  }

#cyMarkersDiv select, input, button{
  font-size: 14px;
  }
  
#markersControlsLayoutTable{
  border: 1px solid black;
  margin: 2px;
  width: 100%;
  }

.chosen-container, .chosen-drop .chosen-search input {
   width: 100% !important;
   -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
           box-sizing: border-box;
  }

</style>


<div id="markersAndPatientsDiv">
   <div id="markersAndTissuesControlsDiv">
      <table id="markersControlsLayoutTable">
         <tr>
           <td style="width:25%">
             <input type="text" id="markersAndTissuesMouseOverReadout" disabled value="(names displayed here)"
                    style="width:100%; margin-right:5px"></input>
           </td>
   
           <td style="width:20%">
             <select id="cyMarkersOperationsMenu" style="float:right; margin-right:5px">
             </select>
           </td>

           <td style="width:10%">
             <select id="cyMarkersTumorCategorizationsMenu">
             </select>
           </td>
         
           <td style="width:30%">
             <select class="SelectionMenu" type="button" id="cyMarkersSendSelectionsMenu"
                     style="float:right; margin-right:5px">
            </select>
          </td>
         </tr>
    
      <tr>
          <td>
           <input type="text" id="markersAndTissuesSearchBox" placeholder="search" ></input>
           <button id="markersFitViewButton" title="Restore Initial View">Fit</button>
           <button id="markersShowEdgesFromSelectedButton" title="Show Edges from Selected Nodes">Show</button>
           <button id="markersHideEdgesButton" title="Hide Edges">Hide</button>
          </td>
    
          <td>
           <select id="markerLayouts" style="float:right; margin-right:5px">
           </select>
          </td>
          <td>
            <button id="markersSubSelectButton">Subselect</button>
          </td>

          <td>
             <select id="markersEdgeTypeSelector" 
                class="chosen-select form-control dropdown navbar-form selectpicker SelectionMenu"
                 multiple>
                   <option value="mutation" class="btn-info" selected>Mut</option>
                   <option value="cnGain.2" class="btn-info" selected>Copy+2</option>
                   <option value="cnLoss.2" class="btn-info" selected>Copy-2</option>
                   <option value="cnGain.1" class="btn-info" selected>C+1</option>
                   <option value="cnLoss.1" class="btn-info" selected>C-1</option>
            </select>
          </td>
      </tr>
    
    </table>
    </div>
   
   
 <div id="cyMarkersDiv" data-toggle="tooltip" class="content" style="margin:0 auto" ></div>
 <div id="bottomMargin" style="width:100%;height:30px margin:0 auto"></div>

</div>




<div id="markersTestDiv">
  <div id="markersTestStatusDiv"        style="display:none"></div>
  <div id="markersAndPatientsStatusDiv" style="display:none"></div>
  <div id="qunit" style="display:block"></div>
  <div id="qunit-fixture"></div>
</div>



</div>

</body>
</html>
