




<!DOCTYPE html> 
<html>

<head>
   <meta charset="UTF-8">
   <meta property="og:title" content="Oncoscape" />

   <title> OncoDev 1.4</title>

   <script src="http://code.jquery.com/qunit/qunit-1.18.0.js"></script>
   <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.18.0.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-2.1.3.min.js"></script>
   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-1.11.2.min.js"></script-->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-ui-1.11.4.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.7/themes/smoothness/jquery-ui.css">

   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.4.4.min.js"></script-->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.5.0-u7.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.cytoscape.js-panzoom.js"></script>
   <link   href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.cytoscape.js-panzoom.css" 
           rel="stylesheet" 
           type="text/css">


   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/d3.min.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.dataTables-1.10.5.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.dataTables-1.10.5.min.css">

   <script src="http://cdn.datatables.net/colvis/1.1.0/js/dataTable.colVis.js"></script>

   <link   rel="stylesheet" type="text/css"
           href="http://cdn.datatables.net/colvis/1.1.0/css/dataTables.colVis.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.multi-select.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/multi-select.css" media="screen" rel="stylesheet" type="text/css">
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/chosen.jquery.min.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/chosen.min.css" media="screen" rel="stylesheet" type="text/css">

    <link rel="SHORTCUT ICON" type="image/x-icon" href="http://oncoscape.sttrcancer.org/oncoscape/images/favicon.ico"/>
    <link rel="ICON" type="image/x-icon" href="http://oncoscape.sttrcancer.org/oncoscape/images/favicon.ico"/>


<script> 
//--------------------------------------------------------------------------------------------------
// hooks for google analytics

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 
  ga('create', 'UA-528883-29', 'auto');
  ga('send', 'pageview');
//--------------------------------------------------------------------------------------------------
</script> 

<script>
navigator.sayswho= (function(){
    var ua= navigator.userAgent, tem,
    M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
    }
    if(M[1]!== 'Chrome'){
       alert("Oncoscape is currently developed and tested under Chrome.  For best results, please use Chrome version 45.0 and later.")
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
    }
    M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();
</script>

</head>

<style>

.flex-container {
  display: -webkit-flex;
  display: flex;
  }

.ui-slider-range {
   background-image: none;
   background: lightgrey;
   }

th,td {
   font-size:12px;
   }

.patientDataFilterSliderReadout{
   font-size: 10px;
   height:16px;
   }

.ui-tabs .ui-tabs-nav li a{
   font-size:10pt !important;
   }

.ui-button .ui-button-text{
   font-size:10pt !important;
   }

.ui-dialog .ui-dialog-titlebar-close span{ margin:0 }

.SelectionMenu{
color: rgb(0, 0, 0); 
background-color: rgb(255, 255, 255);
}

</style>



<script>
//----------------------------------------------------------------------------------------------------
// These javascript functions and variables are arranged into a simple module so that
// implementation details are kept private from the public API other oncoscape 
// browser modules will use.  common services and utility functions are provided here
//----------------------------------------------------------------------------------------------------
var HubModule = (function () {

  var name = "HubModule";
     // keys are module names, their outermost divs are the values.
     // providing these outermost divs allows was inspired by 
     // the need to allow raising of tabs by the sending tab.
     // TODO: not sure that's still needed

  var selectionDestinations = {};
  var dispatchOptions = {};
  var socketIsConnected = false;
  var socketConnectedFunctions = [];
  var onDocumentReadyFunctions = [];
  var socketURI = window.location.href.replace("http://", "ws://");
  var socket;
  
  var  messagingRestrictedToLogin = false;

  var modules = {};
//----------------------------------------------------------------------------------------------------
function registerModule(name, moduleObject)
{
   modules[name] = moduleObject;

} // registerModule
//----------------------------------------------------------------------------------------------------
function getModuleNames()
{
   return(Object.getOwnPropertyNames(modules));

} // getModuleNames
//----------------------------------------------------------------------------------------------------
function getModules()
{
   return modules;

} // getModules
//----------------------------------------------------------------------------------------------------
// TODO: add 3rd argument: acceptsIncomingMessages
//       datasets, for instance, seems to have no need for incoming json/websocket messages
function registerSelectionDestination(names, outermostDivID)
{
  if(typeof(names) == "string")
    names = [names];

  for(var i=0; i < names.length; i++)
     selectionDestinations[names[i]] = outermostDivID;

} // registerSelectionDestination
//----------------------------------------------------------------------------------------------------
function getRegisteredSelectionDestinations()
{
  return(selectionDestinations);

} // getRegisteredSelectionDestinations
//----------------------------------------------------------------------------------------------------
function setupSocket(socket)
{
  console.log("=== Module.hub setupSocket");

  try {
     socket.onopen = function() {
        console.log("websocket connection now open");
        socketIsConnected = true;
        for(var f=0; f < socketConnectedFunctions.length; f++){
           console.log("calling the next sockectConnectedFunction");
           socketConnectedFunctions[f]();
           } // for f
        } // socked.onopen

     socket.onmessage = function got_packet(msg) {
        var msg = JSON.parse(msg.data)
        dispatchMessage(msg)
        } // socket.onmessage, got_packet

     socket.onclose = function(){
        alert("Web socket connection to server has closed");
        } // socket.onclose
     } // try
  catch(exception) {
    console.log("Error: " + exception);
    }
 
  return(socket);

} // setupSocket
//----------------------------------------------------------------------------------------------------
function socketConnected()
{
   return(socketIsConnected);

} // socketConnected
//----------------------------------------------------------------------------------------------------
function addSocketConnectedFunction(func)
{
   socketConnectedFunctions.push(func)

} // addSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function getSocketConnectedFunctions()
{
   return(socketConnectedFunctions)

} // getSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function addOnDocumentReadyFunction(func)
{
   onDocumentReadyFunctions.push(func)

} // addOnDocumentReadyFunction
//----------------------------------------------------------------------------------------------------
function getOnDocumentReadyFunctions()
{
   return(onDocumentReadyFunctions)

} // getOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
// the nginx proxy server, used by fhcrc IT for the publicly-visible version of Oncoscape
// times out web sockets at 90 seconds.
// this function, when called more often that that, will keep the websocket open.
keepAlive = function()
{   
    //console.log("keep alive"); 
    msg = {cmd: "keepAlive", callback: "", status:"request", payload:""}
    socket.send(JSON.stringify(msg));

} // keepAlive
//--------------------------------------------------------------------------------------------------
function runOnDocumentReadyFunctions()
{
  setInterval(keepAlive, 10000);  // 10 seconds
  var funcs = getOnDocumentReadyFunctions()
  console.log("==== Module.hub: " + funcs.length + " onDocumentReadyFunctions");

  for (var f = 0; f < funcs.length; f++) {
     console.log("calling on ready function");
     funcs[f]();
     }

} // runOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
function runningInNode()
{
    // a not very sophisticated test, but adequate for our purposes thus far
  return(typeof(window) == "undefined")

} // functionRunningInNode
//----------------------------------------------------------------------------------------------------
function initializeWebSocket()
{
   if(runningInNode()){
     console.log("--- web socket not currently available when runing in Node");
     process.exit(code=1)
     }

   socket = new WebSocket(socketURI);
   socket = setupSocket(socket);

} // initializeWebSocket
//----------------------------------------------------------------------------------------------------
function getSocket()
{
  return(socket);

} // getSocket
//----------------------------------------------------------------------------------------------------
function addMessageHandler(cmd, func)
{
  if(cmd in dispatchOptions){
     dispatchOptions[cmd].push(func)
     }
  else{
     dispatchOptions[cmd] = [func]
     }
  
} // addMessageHandler
//----------------------------------------------------------------------------------------------------
function getRegisteredMessageNames()
{
   return(Object.keys(dispatchOptions));
  
} // getRegisteredMessageNames
//----------------------------------------------------------------------------------------------------
function getDispatchOptions()
{
   return(dispatchOptions);
  
} // getDispatchOptions
//----------------------------------------------------------------------------------------------------
function dispatchMessage(msg)
{
   var cmd = msg.cmd;
   var status = msg.status;
   console.log("====== Module.hub dispatchMessage '" + cmd + "' [" + Date() + "]" );

   var dispatchKeys = Object.keys(dispatchOptions);
   var cmdIndex = dispatchKeys.indexOf(cmd);
   console.log("hub.dispatchMessage(" + cmd + "): " + cmdIndex);

   if(cmdIndex === -1){
      console.log("unrecognized socket request: " + msg.cmd);
      console.log(" --- msg:");
      console.log(msg);
      console.log(" --- dispatchOptions");
      console.log(dispatchOptions);
      }
   else{
     var funcs = dispatchOptions[cmd];
     //console.log(" func count for msg cmd " + cmd + ": " + funcs.length);
      for(var i=0; i < funcs.length; i++){
         //console.log("--- Module.hub executing func # " + i + " for cmd " + msg.cmd);
         funcs[i](msg); // dispatchOptions[msg.cmd](msg)
         } // for i
      }

}  // dispatchMessage
//----------------------------------------------------------------------------------------------------
function restrictMessagingToLogin(newState)
{
   messagingRestrictedToLogin = newState;

} // restrictMessagingToLogin
//----------------------------------------------------------------------------------------------------
function send(msg)
{
   var cmd = JSON.parse(msg).cmd;
   if(messagingRestrictedToLogin && cmd === "checkPassword"){
      console.log("hub.send drops non-login msg");
      return;
      }

   var browserLocalCommand = Object.keys(dispatchOptions).indexOf(cmd) >= 0;
   var mode = "server";
   if(browserLocalCommand)
      mode = "browser local";

   console.log("--- hub.send: '" + cmd + "' (" + mode + ")");

   if(browserLocalCommand)
      dispatchMessage(JSON.parse(msg));
   else{
      socket.send(msg);
      }

}  // send
//----------------------------------------------------------------------------------------------------
function setTitle (newTitle)
{
  window.document.title = newTitle;

}  // setTitle
//----------------------------------------------------------------------------------------------------
// add a pulldown menu to the specified menuSelector, which has been provided by the caller, which
// is assumed to be an Oncoscape module.  append the names of all previously-registered divs, 
// except for those explicitly excluded in the incoming argument "excludedModules".
// This supports the usual (but not universal) case: a module does not want to send selections
// to itself.
// this argument will often be an array of one element, the name of the calling module.
// some modules may have multiple send destinations (eg, "PCA" & "PCA (highlight)".
function configureSendSelectionMenu(menuSelector, excludedModules, changeFunction, menuTitle)
{
  var menu = $(menuSelector);
  menu.append("<option>" + menuTitle + "</option>");
  menu.change(changeFunction);
  var otherModules = Object.keys(hub.getRegisteredSelectionDestinations());

  for(var i=0; i < otherModules.length; i++){
     var moduleName = otherModules[i];
     var excluded = excludedModules.indexOf(moduleName) >= 0;
     if(!excluded){
        menu.append("<option>" + moduleName + "</option>");
        }
     } // for i

  return(menu);

} // createSendSelectionMenu
//--------------------------------------------------------------------------------------------
// from http://stackoverflow.com/questions/4068373/center-a-popup-window-on-screen
function openCenteredBrowserWindow(url, title, w, h, replaceAnyExistingPopup) {
      // Fixes dual-screen position                       Most browsers      Firefox
    var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
    var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
    width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
    height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;

    var left = ((width / 2) - (w / 2)) + dualScreenLeft;
    var top = ((height / 2) - (h / 2)) + dualScreenTop;
    var options = 'scrollbars=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left;

    var newWindow;

      // warning, a bug: when multiple popup windows are created, they
      // all have the same content -- not what we want.  fix this
      // by severing their relationship, and/or switching to jQuery dialog

    if(replaceAnyExistingPopup)
      newWindow = window.open(url, title, options);
    else // leave any existing popup windows untouched
      newWindow = window.open(url, "_blank", options);

    if (window.focus) {
       newWindow.focus();
       }
       
    return newWindow;

} // openCenteredBrowserWindow
//--------------------------------------------------------------------------------------------
function disableButton(button)
{
   button.prop("disabled", true);
   button.css({"background-color": "lightgray", "color": "gray"});

} // disableButton
//--------------------------------------------------------------------------------------------
function enableButton(button)
{
   button.prop("disabled", false);
   //button.css({ 'color': 'black'})
   button.css({"background-color": "white", "color": "black"});

} // enableButton
//--------------------------------------------------------------------------------------------
function disableAllTabsExcept(tabIDstring)
{
  if(typeof tabIDstring == "string") tabIDstring = [tabIDstring]
  var allDivIDs = getTabDivIDs()
  allDivIDs = allDivIDs.filter(function(i, id){ return(tabIDstring.indexOf(id) == -1) })
  for(var i=0;i<allDivIDs.length; i++){  	disableTab(allDivIDs[i]) }
  
  return allDivIDs;  //returns divIDs that have been disabled
  
} // disableTab
//--------------------------------------------------------------------------------------------
function disableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "disable", "#" + tabIDstring  )

} // disableTab
//--------------------------------------------------------------------------------------------
function enableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "enable", "#" + tabIDstring   )
} // enableTab

//--------------------------------------------------------------------------------------------
// if jQuery-style tabs are in use with Oncoscape, this function raised the named tab to the
// the front (visible) position in the tabset
// the argument, "tabIDString" is the tab id used in the module's widget.html, reproduced exactly
// in tabsApp/widget.html, with some current examples being
//  pcaDiv, patientTimeLinesDiv, gbmPathwaysDiv
//
function raiseTab(tabIDString)
{
  var tabsWidget = $("#oncoscapeTabs");

  if(tabsWidget.length > 0){
     var selectionString = '#oncoscapeTabs a[href="#' + tabIDString + '"]';
     var tabIndex = $(selectionString).parent().index ();
     if(tabIndex < 0) throw "Module.hub does not recognize tabIDString '" + tabIDString + "'";
     console.log("Module.hub:raiseTab for '" + tabIDString + "' (" + tabIndex + ") set to active'");
     setTimeout(function(){tabsWidget.tabs( "option", "active", tabIndex);}, 0);
     } // if tabs exist

} // raiseTab
//----------------------------------------------------------------------------------------------------
// each of our tabs is a div, nested directly within $("oncoscapeTabs").  
// this function returns an array of each of the div ids
function getTabNames()
{
  var tabNames = $("#oncoscapeTabs").children()[0].textContent.trim().split("\n")
  for (i=0;i< tabNames.length; i++){ tabNames[i] = tabNames[i].trim()}
  tabNames =tabNames.filter(function(name){return name != ""})

	return tabNames;

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// each of our tabs has a title within the $("oncoscapeTabs") nav bar
// this function returns an array of each tab Title
function getTabDivIDs()
{
   return ($("#oncoscapeTabs").children("div").map(function(index,dom){return dom.id}));

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTab("Login", "#loginDiv");
function hideTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideTab
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTabNav("Login");
function hideTabNav(tabTitle)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()

} // hideTab
//----------------------------------------------------------------------------------------------------
function hideAllTabsButOne(tabTitle, tabDivIDstring)
{
  var divIDs = getTabDivIDs();
  
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideAllTabsButOne
//----------------------------------------------------------------------------------------------------
function showTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").show()
  $(tabDivIDstring).show();

} // showTab
//----------------------------------------------------------------------------------------------------
function addTab(tabTitle, tabDivIDstring,  content)
{
  var tabs = $("#oncoscapeTabs").tabs()
  var listItem = "<li><a href='#" + tabDivIDstring + "}'>" + tabTitle + "</a>";

  tabs.find(".ui-tabs-nav").append(listItem);
  tabs.append("<div id='" + tabDivIDstring + "'><p>" + content + "</p></div>");
  tabs.tabs("refresh");

} // addTab
//----------------------------------------------------------------------------------------------------
function getRandomFloat (min, max)
{
    return Math.random() * (max - min) + min;
}
//----------------------------------------------------------------------------------------------------
function getRandomInt (min, max) 
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
//----------------------------------------------------------------------------------------------------
String.prototype.beginsWith = function (string) 
{
    return(this.toLowerCase().indexOf(string.toLowerCase()) === 0);
};
//----------------------------------------------------------------------------------------------------
uniqueElementsOfArray = function(vector)
{
  var u = {}, a = [];

  for(var i = 0, l = vector.length; i < l; ++i){
     if(u.hasOwnProperty(vector[i])){
       continue;
       }
     a.push(vector[i]);
     u[vector[i]] = 1;
     } // for i

   return a;

} // uniqueElementsOfArray
//----------------------------------------------------------------------------------------------------
// return the targets matched by the candidates, where match is tolerant of differences by suffix
// thus incoming id "TCGA.06.0649.01" matches existing id "TCGA.06.0649" and
//      incoming id "TCGA.06.0649"    matches existing id "TCGA.06.0649.01" 
// this may cause problems with gene names, eg, MYC would mach MYCL and MYCA
// todo: make this suffix-tolerant match suffix-specific 
function intersectionOfArrays(candidates, targets) {

  hits=[]; 

  for(var i=0; i < candidates.length; i++){
    for (var j=0; j < targets.length; j++){
       candidate = candidates[i];
       target = targets[j];
       index1 = candidate.indexOf(target);   // "abc".indexOf("ab") -> 0
       index2 = target.indexOf(candidate); 
       //console.log("c(t): " + candidate + " contains " + target + ": " + index1);
       //console.log("t(c): " + target + " contains " + candidate + ": " + index2);
       if (index1 == 0)
          hits.push(target)
       else if (index2 == 0)
          hits.push(target)
         } // for j
     } // for i

  return(hits)

} // intersectionOfArays
//----------------------------------------------------------------------------------------------------
function setupGlobalExceptionHandler()
{
   window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {

      var title = "Oncoscape Error";
      var options = {buttons: { "Ok": function () { $(this).dialog("close"); } },
                     title: title};
      var text = "<i>" + errorMsg + "</i><br>" +
                 "<br><b>Script</b>: " + url + 
                 "<br><b>Line:</b> " + lineNumber + 
                 "<br><b>Column:</b> " + column + 
                 "<br><b>StackTrace:</b> " +  errorObj;
      $("<div></div>").dialog(options).html(text);
      };
 
} // setupGlobalExceptionHandler
//----------------------------------------------------------------------------------------------------
function start()
{
  setupGlobalExceptionHandler();
  initializeWebSocket();
  $(document).ready(runOnDocumentReadyFunctions);
  QUnit.config.altertitle = false;

}  // start
//----------------------------------------------------------------------------------------------------
function logEventOnServer(moduleOfOrigin, eventName, eventStatus, comment)
{
   console.log("about to logEvent: " + eventName);
   payload= {eventName: eventName, eventStatus: eventStatus, 
             moduleOfOrigin: moduleOfOrigin, comment: comment};

   hub.send(JSON.stringify({cmd: "logEvent", callback: "", status: "request", payload: payload}));

} // logEventOnServer
//----------------------------------------------------------------------------------------------------
function test_intersectionOfArrays()
{
   console.log("---  test_intersectionOfArrays");
   var targets = ["TCGA.02.0006"];
   var candidates = ["TCGA.02.0006"];

   QUnit.test("test_intersectionOfArrays 1", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   targets = ["TCGA.02.0006"];
   candidates = ["bogus"];
   QUnit.test("test_intersectionOfArrays 2", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });

   targets = ["bogus"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 3", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });


   targets = ["TCGA.02.0006.01"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 4", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   //targets = ["MAP2"];   this test will fail because sometimes we want incomplete matches:
   //  see test4 just above
   //candidates = ["MAP2K4", "abc"];
   //QUnit.test("test_intersectionOfArrays 5", function(assert) {
   //   assert.equal(hub.intersectionOfArrays(candidates, targets), []);
   //   });


} //  test_intersectionOfArrays
//----------------------------------------------------------------------------------------------------
function standAloneTest()
{
   test_intersectionOfArrays();

}  // standaloneTest
//----------------------------------------------------------------------------------------------------

  return({
     getName: function() {return(name)},
     restrictMessagingToLogin: restrictMessagingToLogin,
     registerModule: registerModule,
     getModules: getModules,
     registerSelectionDestination: registerSelectionDestination,
     getRegisteredSelectionDestinations: getRegisteredSelectionDestinations,
     socketConnected: socketConnected,
     addSocketConnectedFunction: addSocketConnectedFunction,
     getSocketConnectedFunctions: getSocketConnectedFunctions,
     addOnDocumentReadyFunction: addOnDocumentReadyFunction,
     getOnDocumentReadyFunctions: getOnDocumentReadyFunctions,
     runningInNode: runningInNode,
     initializeWebSocket: initializeWebSocket,
     getSocket: getSocket,
     addMessageHandler: addMessageHandler,
     getRegisteredMessageNames: getRegisteredMessageNames,
     getDispatchOptions: getDispatchOptions,
     dispatchMessage: dispatchMessage,
     configureSendSelectionMenu: configureSendSelectionMenu,
     openCenteredBrowserWindow: openCenteredBrowserWindow,
     enableButton: enableButton,
     disableButton: disableButton,
     enableTab: enableTab,
     disableTab: disableTab,
     disableAllTabsExcept: disableAllTabsExcept,
     getRandomInt: getRandomInt,
     getRandomFloat: getRandomFloat,
     intersectionOfArrays: intersectionOfArrays,
     uniqueElementsOfArray: uniqueElementsOfArray,
     send: send,
     setTitle: setTitle,
     getTabDivIDs: getTabDivIDs,
     getTabNames: getTabNames,
     raiseTab: raiseTab,
     hideTab: hideTab,
     hideTabNav: hideTabNav,
     showTab: showTab,
     addTab: addTab,
     sat: standAloneTest,
     start: start,
     logEventOnServer: logEventOnServer
     });

}); // HubModule
//----------------------------------------------------------------------------------------------------


var hub = HubModule();
hub.start();
hub.addOnDocumentReadyFunction(function() {
    console.log("====== tabapps document ready");
    window.tabsAppRunning = true
    $("#oncoscapeTabs").tabs({
         // todo: distinguish between tabs, only do needed resets
       activate: function(event, ui) {
            console.log(" tabsApp/code.js:activate");
            var tableRef = $("#historyTable").dataTable();
            var tableRef2 = $("#userDataStoreTable").dataTable();
            if (tableRef.length > 0) {
               console.log("   adjusting patient history table");
               tableRef.fnAdjustColumnSizing();
               } // if
            if (tableRef2.length > 0) {
               console.log("   skipping! - adjusting user data store table");
               tableRef2.fnAdjustColumnSizing();
               } // if
            //console.log(" ==== tab.activate, possible cyjs resize and fit");
            if(typeof(cwMarkers) != "undefined") {
              console.log("adjusting cwMarkers? " + cwMarkers.width() + " * " + cwMarkers.height());
               if(cwMarkers.width() > 0){
                  cwMarkers.resize(); 
                  console.log("after resize");
                  cwMarkers.fit(50);
                  console.log("done adjusting cwMarkers");
		  }
               }
            if(typeof(cyGbm) != "undefined") {
               //console.log("adjusting cwGbm");
               cyGbm.resize();
               cyGbm.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cwAngio) != "undefined") {
               //console.log("adjusting cwAngio");
               cwAngio.resize();
               cwAngio.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cyPathway) != "undefined") {
               cyPathway.resize();
               cyPathway.fit(50);
               }
            } // activate
        }); // tabs
    });  // ready



hub.raiseTab("datasetsDiv");
hub.setTitle("oncoscape");
</script>
<body>
<style>
.ui-tabs .ui-tabs-nav li a {font-size:10pt !important;}
.ui-button .ui-button-text {font-size:10pt !important;}
</style>


<script>
//----------------------------------------------------------------------------------------------------
var DataSummaryModule = (function () {

  var dataSummaryDiv;

  var outputDiv;
  var dataSetNamesOutputDiv;
  var thisModulesName = "Datasets";
  var thisModulesOutermostDiv = "datasetsDiv";

  var tableElement;
  var tableRef;
  var datasetMenu;
  var selectedDataSet;
  var useThisDatasetButton;

  var sendSelectionsMenu;
  var sendSelectionsMenuTitle = "Send selection...";
  var passwordProtected = false;

//----------------------------------------------------------------------------------------------------
function initializeUI()
{
  sendSelectionsMenu = hub.configureSendSelectionMenu("#datasetsSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                       sendSelectionsMenuTitle);

  hub.disableButton(sendSelectionsMenu);

  $(window).resize(handleWindowResize);
  datasetMenu = $("#datasetMenu");
  datasetMenu.change(selectManifest);

  dataSetNamesOutputDiv = $("#dataSetNamesOutputDiv");
  dataSummaryDiv = $("#dataSummaryOutputDiv");

  useThisDatasetButton = $("#selectDatasetButton");
  useThisDatasetButton.button();
  hub.disableButton(useThisDatasetButton);
  useThisDatasetButton.click(specifyCurrentDataset);

  outputDiv = $("#dataSummaryOutputDiv");
  tableElement = $("#datasetsManifestTable");
      
    // if no login tab is present, then allow unrestricted choice of datasets.
    // if it IS present, then that tab will control this.

  var loginRequired = $("#loginDiv").length === 1;
  console.log("loginRequired? " + loginRequired);

  if(!loginRequired){
    console.log(" enabling datasetMenu");
    hub.enableButton($("#datasetMenu"));
    }
  else{
    console.log(" disabling datasetMenu");
    hub.disableButton($("#datasetMenu"));
    }

   if(hub.socketConnected())
      populateDataSetMenu();
   else
     hub.addSocketConnectedFunction(populateDataSetMenu);

} // initializeUI
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
   $("#datasetsStatusDiv").text(msg);   // todo: this is obsolete
   $("#datasetsMinorStatusDiv").text(msg);
   
} // postStatus
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  $("#"+thisModulesOutermostDiv).width($(window).width() * 0.95);
//  $("#"+thisModulesOutermostDiv).height($(window).height() * 0.95);

//  console.log("  div: " + outputDiv.width());
//  console.log("  tbl before: " + tableElement.width());
//  tableElement.width($(window).width() * 0.50);
//  console.log("  tbl after: " + tableElement.width());

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   var cmd = "sendSelectionTo_" + destination;
   payload = "dummy payload";
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//----------------------------------------------------------------------------------------------------
function selectManifest(event)
{
   selectedDataSet = datasetMenu.val();
   console.log("dataset '" + selectedDataSet + "'");

   if(selectedDataSet === ""){
      $("#datasetInstructions").css("display", "block");
      $("#datasetsManifestTable").css("display", "none");
      hub.disableButton(useThisDatasetButton);
      }
    else{
      $("#datasetInstructions").css("display", "none");
      $("#datasetsManifestTable").css("display", "block");
      requestDataSetSummary(selectedDataSet);
    }

} // selectManifest
//----------------------------------------------------------------------------------------------------
function populateDataSetMenu()
{
   console.log("Module.datasets, entering populateDataSetMenu");

   console.log("      socket connected? " + hub.socketConnected());
   console.log("=== datasetMenu ready, now issuing populateDataSetMenu request to server");
   var msg = {cmd: "getDataSetNames",  callback: "handleDataSetNames", status: "request", payload: ""};
   hub.send(JSON.stringify(msg));

} // populateDataSetMenu
//----------------------------------------------------------------------------------------------------
function handleDataSetNames(msg)
{
   console.log("=== handleDataSetNames");
   
   var dataSetNames = msg.payload.datasets;
   console.log("dataSetNames length: " + dataSetNames.length);
   console.log("dataSetNames: " + JSON.stringify(dataSetNames));

   var passwordProtected = msg.payload.passwordProtected;

   if(!Array.isArray(dataSetNames))
      dataSetNames = [dataSetNames];

   for(var i=0; i < dataSetNames.length; i++){
      var s = dataSetNames[i];
      datasetMenu.append("<option value='" + s + "'>" + s + "</option>");
      }

  $("#datasetsMinorStatusDiv").text("datasetMenu loaded");

} // handleDataSetNames
//----------------------------------------------------------------------------------------------------
function requestDataSetSummary(dataSetName)
{
   console.log("=== requestDataSetSummary");

   var msg = {cmd: "getDataManifest",  callback: "displayDataManifest", status: "request", 
              payload: dataSetName};
   hub.logEventOnServer(thisModulesName, "datasets requestDataSummary", "request", dataSetName);

   hub.send(JSON.stringify(msg));

} // requestDataSetSummary
//----------------------------------------------------------------------------------------------------
function displayDataManifest(msg)
{
   var payload = msg.payload;
   var tblColumnNames = payload.colnames;

   var columnTitles = [];
     // convert simple strings to array of objects, each an sTitle
   for(var i=0; i < tblColumnNames.length; i++){
      columnTitles.push({sTitle: tblColumnNames[i]});
      }
     
   if(typeof(tableRef) != "undefined"){
      tableRef.destroy();
      tableElement.empty();
      }


   $(tableElement).ready(function() {
      tableRef = tableElement.DataTable({
        //sDom: 't',
        aoColumns: columnTitles,
        //scrollX: true,
        bPaginate: false,
        bFilter: false, 
        bAutoWidth: true,
        bSort: false,
        bInfo: false
        }); // dataTable

     tableRef = $("#datasetsManifestTable").DataTable();

     tableRef.rows.add(payload.mtx).draw();
     // tableRef.fnAddData(payload.mtx);

     $('#datasetsManifestTable tbody').on( 'click', 'tr', function (){ 
         console.log("=== click");
         var category = $('td', this).eq(0).text();
         var subcategory = $('td', this).eq(1).text();
         if($(this).hasClass("selected")){
            $(this).removeClass('selected');
            hub.disableButton(sendSelectionsMenu);
            }
         else{
            tableRef.$('tr.selected').removeClass('selected');
            $(this).addClass('selected');
            hub.enableButton(sendSelectionsMenu);
            console.log("selected " + category + ", " + subcategory);
            }
         });

     handleWindowResize();
     hub.enableButton(useThisDatasetButton);
     postStatus("manifest table displayed");
     hub.logEventOnServer(thisModulesName, "datasets requestDataSummary", "complete", "");
     }); // tableElement.ready

} // displayDataManifest
//----------------------------------------------------------------------------------------------------
function specifyCurrentDataset()
{
   console.log("Module.datasets 'Use Dataset' button clicked, specifyCurrentDataset: " + selectedDataSet);
 
   hub.disableAllTabsExcept([thisModulesOutermostDiv, "userDataStoreDiv", "ericTestDiv"]);
   $("#loadingDatasetMessage").css("display", "inline");
	
   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: selectedDataSet};

   hub.send(JSON.stringify(msg));

} // specifyCurrentDataset
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   $("#loadingDatasetMessage").css("display", "none");
   console.log("--- Module.datasets:  datasetSpecified");

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function test(dataSetName)
{
   console.log("Module.datasets test, on datasetName: '" + dataSetName + "'");

   QUnit.test("choose dataset '" + dataSetName + "'", function(assert) {
      hub.raiseTab("datasetsDiv");
      var desiredDataset = dataSetName;
      var dzNames = $("#datasetMenu option").map(function(opt){return this.value;});

      if($.inArray(desiredDataset, dzNames) < 0){
         alert("cannot run tests:  " + desiredDataset + " dataset not loaded");
         return;
         }

      $("#datasetMenu").val(desiredDataset);
      $("#datasetMenu").trigger("change");

      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      assert.expect(3);

      setTimeout(function(){
         assert.equal($("#datasetMenu").val(), desiredDataset);  done1();
         assert.ok($("#datasetsManifestTable tr").length >= 10); done2();
         assert.equal($("#datasetsManifestTable tbody tr").eq(0).find("td").eq(0).text(), 
                      "mRNA expression"); done3();
         //testLoadPatientHistoryTable();
         }, 5000);
      });


} // test
//----------------------------------------------------------------------------------------------------
function moduleInit()
{
  hub.addOnDocumentReadyFunction(initializeUI);
  //hub.addSocketConnectedFunction(populateDataSetMenu);
  hub.addMessageHandler("handleDataSetNames", handleDataSetNames);
  hub.addMessageHandler("displayDataManifest", displayDataManifest);
  hub.addMessageHandler("datasetSpecified", datasetSpecified);

} // moduleInit
//----------------------------------------------------------------------------------------------------
return{
   init: moduleInit,
   test: test
   }; // DataSummaryModule return value

//----------------------------------------------------------------------------------------------------
}); // DataSummaryModule

var dataSummaryModule = DataSummaryModule();
dataSummaryModule.init();
hub.registerModule("Datasets", dataSummaryModule);

//----------------------------------------------------------------------------------------------------
var patientHistoryTableRef;

var ageAtDxMinReadout;
var ageAtDxMaxReadout;
var survivalMinReadout, survivalMaxReadout;

var ageAtDxMin, ageAtDxMax;
var ageAtDxSlider, survivalSlider;
var survivalMin, survivalMax;


var PatientHistoryModule = (function () {

  var statusDiv;
  var patientHistoryDiv;
  var controlsDiv;
  var tableDiv;
  var tableElement;
  var sendSelectionsMenu;

  var thisModulesName = "patientHistory";
  var thisModulesOutermostDiv = "patientHistoryDiv";
  var selectionDestinations = [thisModulesName];

  var sendSelectionsMenuTitle = "Send selection...";
  var showAllRowsButton;
  
//--------------------------------------------------------------------------------------------
function initializeUI()
{
  console.log("=== Module.patientHistory, initializeUID");

  $(window).resize(handleWindowResize);

  statusDiv = $("#patientHistoryStatusDiv");

  patientHistoryDiv = $("#patientHistoryDiv");
  controlsDiv = $("#patientHistoryControlsDiv");
  tableDiv = $("#patientHistoryTableDiv");
  tableElement = $("#patientHistoryTable");

  showAllRowsButton = $("#patientHistoryShowAllRowsButton");
  showAllRowsButton.click(showAllRows);

  sendSelectionsMenu = hub.configureSendSelectionMenu("#patientHistorySendSelectionsMenu", 
                                                      selectionDestinations, sendSelections,
                                                      sendSelectionsMenuTitle);

  handleWindowResize();
  hub.disableTab(thisModulesOutermostDiv)


} // initializeUI
//----------------------------------------------------------------------------------------------------
function createDataTable(colnames, data)
{
      // DataTable likes some structure for column titles

   var columnTitles = [];
   for(var i=0; i < colnames.length; i++){
     columnTitles.push({sTitle: colnames[i]});
     }

   if(typeof(patientHistoryTableRef) != "undefined"){
      patientHistoryTableRef.destroy();
      tableElement.empty();
      }

   patientHistoryTableRef = tableElement.DataTable({
                             data: data,
                             columns: columnTitles,
                             //dom: "C<fi<t>>",
                             dom: 'C<"clear">lfrtip',
                             paging: false,
                             jQueryUI: false
                             });

   if(colnames.indexOf("AgeDx") >= 0){
      var minMax = learnSliderMinAndMax(data, colnames.indexOf("AgeDx"));
      console.log("minMax for AgeDx: ");
      console.log(minMax);
      ageAtDxMin = minMax[0];
      ageAtDxMax = minMax[1];
         // slider, title & readouts for specifying age range for table display
      createAgeAtDiagnosisWidget(ageAtDxMin, ageAtDxMax);  
      } // ageAtDx slider

   if(colnames.indexOf("Survival") >= 0){
      minMax = learnSliderMinAndMax(data, colnames.indexOf("Survival"));
      console.log("minMax for Survival: ");
      console.log(minMax);
      survivalMin = minMax[0];
      survivalMax = minMax[1];
         // slider, title & readouts for specifying age range for table display
      createSurvivalWidget(survivalMin, survivalMax);  
      } // survival slider

   showAllRows();
   setupSliderDrivenFilterBehavior(colnames);
 

} // createDataTable
//----------------------------------------------------------------------------------------------------
function setupSliderDrivenFilterBehavior(colnames)
{
  var ageDxColumn = colnames.indexOf("AgeDx");
  var survivalColumn = colnames.indexOf("Survival");

  if(ageDxColumn >= 0) {
    jQuery.fn.dataTable.ext.search.push(
       function(settings, data, dataIndex) {
         var ageAtDxMin      = parseFloat(ageAtDxMinReadout.val());
         var ageAtDxMax      = parseFloat(ageAtDxMaxReadout.val());

         var patientAgeAtDx  = parseFloat(data[ageDxColumn]) || 0;
 
         var ageAtDxInRange  = (patientAgeAtDx >= ageAtDxMin) && (patientAgeAtDx <= ageAtDxMax);
         if(ageAtDxInRange)
            return true;
         return false;
        }); // anonymous function
      } // push

  if(survivalColumn >= 0) {
    jQuery.fn.dataTable.ext.search.push(
       function(settings, data, dataIndex) {
         var survivalMin      = parseFloat(survivalMinReadout.val());
         var survivalMax      = parseFloat(survivalMaxReadout.val());

         var patientSurvival  = parseFloat(data[survivalColumn]) || 0;
         var survivalInRange  = (patientSurvival >= survivalMin) && (patientSurvival <= survivalMax);
         if(survivalInRange)
            return true;
         return false;
        }); // anonymous function
      } // push


} // setupSliderDrivenFilterBehavior
//----------------------------------------------------------------------------------------------------
function createAgeAtDiagnosisWidget(minValue, maxValue)
{
  ageAtDxSlider = $("#ageAtDxSlider");
  ageAtDxMinReadout = $("#ageAtDxMinSliderReadout");
  ageAtDxMaxReadout = $("#ageAtDxMaxSliderReadout");

  ageAtDxSlider.slider({
     range: true,
     slide: function(event, ui) {
        //console.log("AgeDx: " + ui.values[0] + ", " + ui.values[1]);
        if(ui.values[0] > ui.values[1]){
           return false;
           }          
       ageAtDxMinReadout.text (ui.values[0]);
       ageAtDxMaxReadout.text (ui.values[1]);
       patientHistoryTableRef.draw();
       handleWindowResize();
       //updateRowCountReadout();
       },
    min: minValue,
    max: maxValue,
    values: [minValue, maxValue]
    });

  ageAtDxMinReadout.text(minValue);
  ageAtDxMaxReadout.text(maxValue);

} // createAgeAtDiagnosisWidget
//----------------------------------------------------------------------------------------------------
function createSurvivalWidget(minValue, maxValue)
{
  survivalSlider = $("#survivalSlider");
  survivalMinReadout = $("#survivalMinSliderReadout");
  survivalMaxReadout = $("#survivalMaxSliderReadout");
  console.log("createSurvivalWidget");

  survivalSlider.slider({
     range: true,
     slide: function(event, ui) {
        //console.log("survival: " + ui.values[0] + ", " + ui.values[1]);
        if(ui.values[0] > ui.values[1]){
           return false;
           }          
       survivalMinReadout.text (ui.values[0]);
       survivalMaxReadout.text (ui.values[1]);
       patientHistoryTableRef.draw();
       handleWindowResize();
       },
    min: minValue,
    max: maxValue,
    values: [minValue, maxValue]
    });

  survivalMinReadout.text(minValue);
  survivalMaxReadout.text(maxValue);

} // createSurvivalWidget
//----------------------------------------------------------------------------------------------------
// when the patient history table arrives, the filtering sliders can be setup, using the 
// min and max values of selected columns.  our sliders are currently ageAtDx and survival.
// the column numbers for these are specified by the caller.  missing values are not
// troublesome to Javascript's min and max functions.  note the use of floor and ceil,
// to nudge min and max values out a bit.
function learnSliderMinAndMax(tbl, columnNumber)
{
  var rowCount = tbl.length;
  var min = Number.MAX_VALUE;
  var max = -Number.MAX_VALUE;

  for(var r=0; r < rowCount; r++){
    var value = parseFloat(tbl[r][columnNumber]);
    //console.log(value)
    if(value < min)
      min = value;
    if(value > max)
      max = value;
    } // for r

  return[Math.floor(min), Math.ceil(max)];

} // learnSliderMinAndMax
//----------------------------------------------------------------------------------------------------
function showAllRows()
{
   if(typeof(ageAtDxMin)  != "undefined" &&
      typeof(ageAtDxMax)  != "undefined" &&
      typeof(survivalMin) != "undefined" &&
      typeof(survivalMax) != "undefined") {

        ageAtDxSlider.slider("values", [ageAtDxMin, ageAtDxMax]);
        survivalSlider.slider("values", [survivalMin, survivalMax]);
        ageAtDxMinReadout.text(ageAtDxMin);
        ageAtDxMaxReadout.text(ageAtDxMax);
        survivalMinReadout.text(survivalMin);
        survivalMaxReadout.text(survivalMax);
        } // all 4 min/max slider values defined

    // chained calls: clear the DataTable search box, then iterate through the columns, then render

   if(typeof(patientHistoryTableRef) != "undefined")
       patientHistoryTableRef.search('').columns().search('').draw();

   handleWindowResize();

} // showAllRows
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{

  patientHistoryDiv.width($(window).width() * 0.95);
  patientHistoryDiv.height($(window).height() * 0.90);  // leave room for tabs above

  //controlsDiv.width($(window).width() * 0.90);
  controlsDiv.width(patientHistoryDiv.width()); //  * 0.95);
  controlsDiv.height("100px");

  tableDiv.width(patientHistoryDiv.width()); //  * 0.95);
  tableDiv.height(patientHistoryDiv.height() - 130);

} // handleWindowResize
//--------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();

   var visibleRows = patientHistoryTableRef.rows({'filter': 'applied'})[0];
   if(visibleRows.length === 0)
      return;

   var selectedIDs = [];

   var data = patientHistoryTableRef.data();

   for(var i=0; i < visibleRows.length; i++){
      var id = data[visibleRows[i]][0];
      selectedIDs.push(id);
      } // for i

   var cmd = "sendSelectionTo_" + destination;

   payload = {value: selectedIDs, count: selectedIDs.length, source: "patient history module"};
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function handleSelections(msg)
{
   showAllRows();
   var ids = msg.payload.value;
   if(typeof(ids) == "string")
      ids = [ids];

      // incoming ids may have trailing version number, e.g., "TCGA.02.0114.01"
      // strip all such 2-digit suffixes:

   ids = ids.map(function(id) {return(id.replace(/\.0[0-9]$/, ""))})
   filterByString(ids);
   hub.raiseTab(thisModulesOutermostDiv);

} // handleSelections
//----------------------------------------------------------------------------------------------------
filterByString = function(strings)
{
   var filterString = strings[0];
   for(var i=1; i < strings.length; i++){
     filterString += "|" + strings[i];
     }

   showAllRows();
   console.log(filterString);

   if(typeof(patientHistoryTableRef) != "undefined")
      patientHistoryTableRef.search(filterString, true, false).draw();   // string, regex, smart

}; // filterByString
//----------------------------------------------------------------------------------------------------
function displayPatientHistoryTable(msg)
{
   var payload = msg.payload;
   var colnames = payload.colnames;
   var data = payload.tbl; // an array of arrays

   console.log("incoming table, rows: " + data.length);
   console.log("incoming table, cols: " + data[0].length);
   createDataTable(colnames, data);
   postStatus("patientHistory data table loaded");
   hub.enableTab(thisModulesOutermostDiv)

}  // displayPatientHistoryTable
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the patient history table from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

     // request patient data table
   var payload = {datasetName: datasetName, durationFormat: "byYear"};
   var newMsg = {cmd: "getPatientHistoryTable",  callback: "displayPatientHistoryTable", 
                 status: "request", payload: payload};

   hub.send(JSON.stringify(newMsg));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
// for standalone exploration, development, and testing.   assumes a hub has been
// created and initialized.  set the dataset, and in the callback load the table
// thus 
//   specifyCurrentDataSet -> getPatientHistoryTable -> displayPatientHistoryTable
//
function testLoad()
{
   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: "TCGAgbm"};

   hub.send(JSON.stringify(msg));

} // test
//----------------------------------------------------------------------------------------------------
function testSelect()
{
   var msg={cmd: "sendSelectionTo_patientHistory", status: "request", callback: "", 
            payload:["TCGA.02.0011", "TCGA.06.0238"]};

   hub.send(JSON.stringify(msg));

} // testSelect
//----------------------------------------------------------------------------------------------------
return{
   init: function(){
      hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
      hub.addOnDocumentReadyFunction(initializeUI);
      hub.addMessageHandler("sendSelectionTo_patientHistory", handleSelections);
      hub.addMessageHandler("datasetSpecified", datasetSpecified);
      hub.addMessageHandler("displayPatientHistoryTable", displayPatientHistoryTable);
      //hub.addSocketConnectedFunction(testLoad);
      //hub.setTitle("patientHistory");
      },
   testSelect: testSelect,
   testLoad:   testLoad
   }; // PatientHistoryModule return value

//----------------------------------------------------------------------------------------------------
}); // PatientHistoryModule
pts = PatientHistoryModule();
pts.init();


//----------------------------------------------------------------------------------------------------
var TimeLineModule = (function () {

	// Integration Components
	//--------------------------------------------------------------------------------------------------

    var sendSelectionMenu;
    var sendSelectionsMenuTitle = "Send selection...";
    var selectionDestinationsOfferedHere = ["Timelines"];
    var OneDay = 1000 *60 * 60*24;
	var ThisModuleName = "Timelines";
    var thisModulesOutermostDiv = "patientTimeLinesDiv";
    
    var then, now;

	// Data Elements
	//--------------------------------------------------------------------------------------------------
		var EventTypes;
		var Events;
		var ptList;
		var ptOrderArray = [];

	// Display features
	//--------------------------------------------------------------------------------------------------
		var TimeLineMargin = {top: 15, right: 15, bottom: 30, left: 25};
        var TimeLineDisplay;
        var TimelineSize, SideBarSize, legendSize;
		var svg, SidePlot, TimeLine, legend, tooltip;
		var MainEvents = ["Birth","Encounter", "Diagnosis", "Procedure","Pathology", "Radiation", "Drug","Progression", "Tests", "Status", "History", "Absent"];
		var MainEventColors = ["#17becf", "#d62728", "#8c564b","#ff7f0e", "#7f7f7f","#e7969c","#9467bd","#1f77b4","#2ca02c", "#bcbd22","#000000" ,"#000000" ];
        var MainEventTextSpacing = [0, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90];
        var TextOffSet = d3.scale.ordinal().range(MainEventTextSpacing).domain(MainEvents);
        var TimeLineColor = d3.scale.ordinal().range(MainEventColors).domain(MainEvents);


//--------------------------------------------------------------------------------------------
     function initializeUI(){
        console.log("========== initializing Timeline UI");
       	d = new Date();
       	then = d.getTime();
       	d = new Date();
		now = d.getTime();
		console.log("Initialize UI start: ", now - then);
		then = now;

		TimeLineDisplay = $("#TimeLineDisplay");
        HandleWindowResize();
 
        sendSelectionMenu = hub.configureSendSelectionMenu("#timeLineSendSelectionsMenu", 
                                                        selectionDestinationsOfferedHere,
                                                        sendSelections,
                                                        sendSelectionsMenuTitle);  

        $(window).resize(HandleWindowResize);

        $("#AlignOptions").change(updateDisplayAlignment);
        $("#OrderOptions").change(updateDisplayOrder);
        $("#SideBarOptions").change(updateDisplaySidePlot);
		
		$('#FitToPage').change(function() { 	HandleWindowResize();  });
	    
		svg = d3.select("#TimeLineDisplay").append("svg")
				  .attr("id", "timelineSVG")
				  .attr("width", TimeLineSize.width + 2*SideBarSize.width + 2*TimeLineMargin.left + 2*TimeLineMargin.right )
				  .attr("height", SideBarSize.height + TimeLineMargin.top + TimeLineMargin.bottom + legendSize.height)
				  ;
		
	    tooltip = d3.select("body").attr("data-toggle", "tooltip")
				   .attr("class", "tooltip")
				   .append("div").attr("id", "tooltipDiv").attr("class", "tooltipNoHover")
				   .style("position", "absolute")
				   .style("z-index", "10")
				   .style("background", "lightgray")
				   .style("border", "thin solid black")
				   .style("border-radius", "5px")
				   .style("padding", "10px")
				   .style("overflow-y", "auto");                        

			//setTimeoutHover = function(el){setTimeout( el.className = "tooltipNoHover", 1000);};
             tooltip.on("mouseover",  function(){
             		   	this.className = "tooltipHover";});
             tooltip.on("mouseout", function(){
            			var x = document.getElementsByClassName("tooltipHover");
            			for(var i=0;i<x.length;i++){x[i].className = "tooltipNoHover"; }
             });

		
		hub.disableTab(thisModulesOutermostDiv);


    }
//--------------------------------------------------------------------------------------------
     function HandleWindowResize(){

		var width, height;

		if($('#FitToPage').is(":checked")){
			  TimeLineDisplay.width($(window).width() * 0.9);
			  TimeLineDisplay.height($(window).height() * 0.9);

			  width = $("#TimeLineDisplay").width();
			  height = $("#TimeLineDisplay").height();
		  
			  TimeLineSize = {width: (0.8 *width - TimeLineMargin.left - TimeLineMargin.right), height: (0.9*height - TimeLineMargin.top - TimeLineMargin.bottom)};
			   SideBarSize = {width: (0.25*width - TimeLineMargin.left - TimeLineMargin.right), height: (0.9*height - TimeLineMargin.top - TimeLineMargin.bottom)};
				legendSize = {width: TimeLineSize.width, height: (0.1*height)};
		} else{
			  TimeLineDisplay.width($(window).width() * 0.9);
			  width = $("#TimeLineDisplay").width();
			  height = ptOrderArray.length * 20;
			  TimeLineSize = {width: (0.8 *width - TimeLineMargin.left - TimeLineMargin.right), height: height};
			   SideBarSize = {width: (0.25*width - TimeLineMargin.left - TimeLineMargin.right), height: height};		
				legendSize = {width: TimeLineSize.width, height: legendSize.height};

		}
         if(typeof TimeLine !== "undefined") redrawSVG();
     }


//--------------------------------------------------------------------------------------------------
	function redrawSVG(){
		initDisplay();
		loadLegend();
		plotTimelines();
		plotSideBar();
	}


//--------------------------------------------------------------------------------------------
     function LogTime(t, TimeScale){ 
        TimeScale = typeof TimeScale !== 'undefined' ? TimeScale : OneDay;
               var Dir = (t<0 ? -1 : 1); 
              return Dir * Math.log(Math.abs(t/TimeScale)+1)/Math.log(2); 
     }     
//--------------------------------------------------------------------------------------------
	function getFormattedDate(date) {  // takes date and returns mm/dd/yyyy
		var dd = date.getDate();
		var mm = date.getMonth()+1; //January is 0!
		var yyyy = date.getFullYear();

		if(dd<10) { dd='0'+dd; } 
		if(mm<10) { mm='0'+mm;} 

		date = mm+'/'+dd+'/'+yyyy;
		
		return date;
	 }
//--------------------------------------------------------------------------------------------
	function insertAscending(id, array) {  //null orderBy values listed first
		  
		  var val = ptList[id].orderVal;
		  array.splice(locationOf(val, array) +1, 0, id);
		  return array;
	}

//--------------------------------------------------------------------------------------------
	function locationOf(val, array, start, end) {
	  
	  if (array.length >0 && ptList[array[0]].orderVal < val || typeof val === "undefined") return -1;
	  start = start || 0;
	  end = end || array.length;
	  var pivot = parseInt(start + (end - start) / 2, 10);
	  if (end-start <= 1 || ptList[array[pivot]].orderVal === val) return pivot;
	  if (ptList[array[pivot]].orderVal > val || typeof ptList[array[pivot]].orderVal === "undefined") {
		return locationOf(val, array, pivot, end);
	  } else {
		return locationOf(val, array, start, pivot);
	  }
	}


//--------------------------------------------------------------------------------------------------
	function sendSelections()
	{
	  var destination = sendSelectionMenu.val();
	  var selectedIDs = identifyEntitiesInCurrentSelection();

	  var cmd = "sendSelectionTo_" + destination;
	  var payload = {value: selectedIDs, count: selectedIDs.length, source: "timelines module"};
	  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

	  sendSelectionMenu.val(sendSelectionsMenuTitle);

	  hub.send(JSON.stringify(newMsg));

	} // sendSelections
//--------------------------------------------------------------------------------------------
	function identifyEntitiesInCurrentSelection ()
	{
       currentlySelectedRegion = TimeLined3PlotBrush.extent();

	   var x1 = currentlySelectedRegion[0][0],
   		   y1 = currentlySelectedRegion[0][1],
		   x2 = currentlySelectedRegion[1][0],
		   y2 = currentlySelectedRegion[1][1],
	   	   ids = [];
	   
	   var selectedPts = ptOrderArray.slice(Math.max(Math.floor(y1)+1,0), Math.min(Math.ceil(y2), ptOrderArray.length-1));		//patient IDs within Y range
    	var AlignOp = document.getElementById("AlignOptions");
		var AlignBy = AlignOp.options[AlignOp.selectedIndex].text;
	   
	   for(var i=0; i < selectedPts.length; i++){		//return IDs with events in X range
	   	  var ptObj = ptList[selectedPts[i]];
		  var dateEvents = ptObj.dateEvents;
		  for(var j=0;j<dateEvents.length;j++){
		     if(AlignBy == "--"){
				 if(dateEvents[j].date-ptObj.offset >=x1 & dateEvents[j].date-ptObj.offset <= x2) {
					ids.push(selectedPts[i]);
					break;
		    	 } //if
		     }else{
				 if(LogTime(dateEvents[j].date-ptObj.offset) >=x1 & LogTime(dateEvents[j].date-ptObj.offset) <= x2) {
					ids.push(selectedPts[i]);
					break;
		    	 } //if
		    }
	   	  } // for dateEvents
	   } // for patients

	  return (ids);
	}

//-------------------------------------------------------------------------------------------
// when a dataset is specified, this module 
//  1) extracts the name of the dataset from the payload of the incoming msg
//  2) (for now) extracts the name of the matrices, from the manifest (also in the payload
//     of the incoming msg, chooses the first mtx.mrna entry it finds
//  3) sends a "createPLSR" message to the server, with dataset & matrix name specified
//  4) asks that the server, upon successful completion of that createPLSR request, callback
//     here so that the sliders can be set
	function datasetSpecified(msg)
	{
//	   timelinesXXX = msg;
	   var dataPackageName = msg.payload.datasetName;
        
        d = new Date();
       	then = d.getTime();
       	d = new Date();
		now = d.getTime();
		console.log("Dataset specified start: ", (now - then));
		then = now;

		   // ["mtx.cn.RData", "history.RData", "mtx.mrna.RData", "mtx.mrna.ueArray.RData", 
		   // "mtx.mut.RData", "mtx.prot.RData", "mtx.meth.RData", "markers.json.RData", 
		   // "genesets.RData", "g.markers.json"]
	   var dataElementNames = msg.payload.rownames;

		  // for now, and very temporarily, use the first match (if any are found)
	   var hits = dataElementNames.map(function(name) {if(name.indexOf("history") >= 0) return(name);});
	   hits = hits.filter(function(n){ return (n !== undefined); });

	   var dataName = null;

	   if(hits.length > 0){
			// for now always grab the first hit, remove the trailing .RData
			// the PLSR constructor wants both dataPacakgeName & a matrix name
			// our convention is that the maniftest rowname is the same as
			// its name, with ".RData" appended
		  dataName = hits[0].replace(".RData", "");
		  }
	   else{
		  return;
		  }
   
	   createTimelinesObjectOnServer(dataPackageName, dataName);

	} // datasetSpecified
//--------------------------------------------------------------------------------------------
	function createTimelinesObjectOnServer(dataPackageName, dataName)
	{
	  console.log("create Timelines on server " + dataPackageName + ": " + dataName);
	  payload = {dataPackage: dataPackageName, dataName: dataName};
	  msg = {cmd: "createTimelines", callback: "DisplayPatientTimeLine", status: "request", payload: payload};
	  msg.json = JSON.stringify(msg);
	  hub.send(msg.json);

	} // createTimelinesObjectOnServer
//--------------------------------------------------------------------------------------------------     
     function handlePatientIDs(msg){
  
		if(msg.status == "success"){
             var patientIDs = msg.payload;
             
             ptOrderArray = patientIDs.filter(function(id){ return Object.keys(ptList).indexOf(id) !== -1 });
			 OrderEvents();
			 redrawSVG();
        } else{
             console.log("Timelines handlePatientIDs about to call alert: " + msg);
             alert(msg.payload);
         }

        hub.raiseTab(thisModulesOutermostDiv);


	} //handlePatientIDs
//--------------------------------------------------------------------------------------------------     
     function handleIncomingIDs(msg){
          
          if(msg.status == "request"){
             var patientIDs = msg.payload.value;
             msg = {cmd: "canonicalizePatientIDsInDataset", callback: "TimelinesHandlePatientIDs", status: "request", 
                    payload: patientIDs};
             hub.send(JSON.stringify(msg));
          }
          else{
             console.log("handlePatientIDs about to call alert: " + msg);
             alert(msg.payload);
         }
     } // handlePatientIDs



 //--------------------------------------------------------------------------------------------------
     function initDisplay(){

          console.log("======== initDisplay");

  		  svg.selectAll("g").remove();
  		  $("#timelineSVG")
				  .attr("width", TimeLineSize.width + 2*SideBarSize.width + 2*TimeLineMargin.left + 2*TimeLineMargin.right )
				  .attr("height", SideBarSize.height + TimeLineMargin.top + TimeLineMargin.bottom + legendSize.height)
				  ;
                    
          SidePlot = svg.append("g").attr("id", "SidePlotSVG")
                            .attr("transform", "translate(" + TimeLineMargin.left + "," + (TimeLineMargin.top) + ")");     
             
          TimeLine = svg.append("g").attr("id", "TimeLineSVG")
                            .attr("transform", "translate(" + (SideBarSize.width+TimeLineMargin.left + TimeLineMargin.right) + "," + (TimeLineMargin.top) + ")");
          
	}

//--------------------------------------------------------------------------------------------------
     function loadPatientDataDisplay(msg) {
          console.log("==== loadPatientDataDisplay");
       	d = new Date();
       	now = d.getTime();
		console.log("load data started: " , now - then);
		then = now;

		$('select[name="AlignOptions"] option[value="--"]').attr('selected', 'selected');
		$('select[name="OrderOptions"] option[value="--"]').attr('selected', 'selected');

		  Events = msg.payload.events;
		  ptList = msg.payload.pts;
		  EventTypes = msg.payload.eventTypes;
	  
          console.log("Event count: " + Events.length);
          console.log("Patient count: " + ptList.length);
          console.log("Category count: " + EventTypes.length);
               
		  function  separateDates(event){ 
				event.date = new Date(event.date);
				event.ptID = pt;
				if(event.eventOrder== "single")     Events[event.eventID].Fields.date = event.date;
				else if(event.eventOrder== "start") Events[event.eventID].Fields.date[0] = event.date;
				else if(event.eventOrder== "end")   Events[event.eventID].Fields.date[1] = event.date;
		  }
                    
          var i = 0; ptOrderArray = [];
          for(var pt in ptList){
        		ptList[pt].showPatient = true;  ptList[pt].PatientHeight=1;  
            	ptList[pt].offset = 0;          ptList[pt].orderVal=i;
				ptOrderArray.push(pt); i++;
				ptList[pt].dateEvents.forEach(separateDates);
		  }
		  
		  for(var event in EventTypes){		EventTypes[event].disabled = false;		  }

       	d = new Date();
       	now = d.getTime();
		console.log("Load data finished: ", now - then);		then = now;
	  
		loadDataMenus();
        redrawSVG();
          
}
//--------------------------------------------------------------------------------------------------
	function loadDataMenus(){
			  console.log("======== load.Menu") ;               

		  var dateEvents = [];
		  for(var name in EventTypes){
		  	if(EventTypes[name].dateIndicator) { dateEvents.push(name);} 
		  }
		  
		  $(".plotCategoryOptions").empty(); $(".plotValueOptions").empty();
		  $("#AlignOptions").empty(); 		 $("#AlignOptions").append("<option value='--' selected='selected'>--</option>");
		  $(".OrderByDateOptions").empty();  $(".OrderByValueOptions").empty();
		  
		  for(var elem in dateEvents){
			   $("#AlignOptions").append(" <option>"+dateEvents[elem]+"</option>");
  			   $(".OrderByDateOptions").append(" <option class='OrderByDate'>"+dateEvents[elem]+"</option>");
			             
               $("#Event1").append("<option value='"+ dateEvents[elem] +"'>"+ dateEvents[elem] +"</option>");
               $("#Event2").append("<option value='"+ dateEvents[elem] +"'>"+ dateEvents[elem] +"</option>");
		  }
		  var CalculatedEvents = ptList[ptOrderArray[0]].calcEvents;
		  for(var ev in CalculatedEvents){
			   $(".OrderByValueOptions").append(" <option>"+CalculatedEvents[ev].name+"</option>");
			   $(".plotValueOptions").append(" <option>"+CalculatedEvents[ev].name+"</option>");
		  }
	  
	}
//--------------------------------------------------------------------------------------------------
	function loadLegend(){
          legend = svg.append("g")
                          .attr("class", "legend")
                          .attr("transform", "translate(" + (SideBarSize.width+2* TimeLineMargin.left + TimeLineMargin.right) + "," + (0) + ")")
         			      .selectAll(".legend")
                          .data(TimeLineColor.domain().filter(function(d){
                                return Object.keys(EventTypes).indexOf(d) !== -1; })  )
                          .enter().append("g")
                            .attr("transform", function(d, i) { 
                                  return "translate(" + i*TextOffSet(d) + ",0)" ;})
                          ;
          legend.append("rect")
                .attr("rx", 2)
                .attr("ry", 2)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", function(d) { return TimeLineColor(d);})
                .on("click", ToggleVisibleEvent);

          legend.append("text")
                .attr("y", 9)
                .attr("x", 12)
                .style("font-size", "12px")
                .text(function(d) { return d; });
                
          legend[0].forEach(function(d){
        	if(EventTypes[d.textContent].disabled)
        		d.children[0].style.opacity = 0.2
          })
	}
 //--------------------------------------------------------------------------------------------------     
     function ToggleVisibleEvent(d){
         
         EventTypes[d].disabled = !EventTypes[d].disabled;
         if(EventTypes[d].disabled)
           d3.select(this).style("opacity", 0.2);
         else
           d3.select(this).style("opacity", 1);

          plotTimelines();
     }

//--------------------------------------------------------------------------------------------------
        function updateDisplayAlignment(){
			AlignEvents(); 
			plotTimelines();
        }
//--------------------------------------------------------------------------------------------------
        function updateDisplayOrder(){
			var OrderOp = document.getElementById("OrderOptions");
			var OrderBy = OrderOp.options[OrderOp.selectedIndex].text;

			 if(OrderBy === "+Add"){
//				console.log("== changing OrderBy with ", OrderBy);
//				OpenDialogForAddedEvents("OrderBy");
			 }else{
				console.log("== changing OrderBy " + OrderBy);
				OrderEvents();      
				plotTimelines();
				plotSideBar();
			 }        
        }
//--------------------------------------------------------------------------------------------------
        function updateDisplaySidePlot(){
			var SideOp = document.getElementById("SideBarOptions");
			var SideBy = SideOp.options[SideOp.selectedIndex].text;

				 if(SideBy === "+Add"){
			//		console.log("== changing SideBar with ", SidePlotEvent);
			//		OpenDialogForAddedEvents("SidePlot");
				 } else{ 
					console.log("== changing SideBar", SideBy);
					plotSideBar();
				 }
        
        }

//--------------------------------------------------------------------------------------------------
        function getTimelineXoptions(){
				var AlignOp = document.getElementById("AlignOptions");
				var AlignBy = AlignOp.options[AlignOp.selectedIndex].text;

               if(AlignBy === "--"){ 
                  x = d3.time.scale().range([0, TimeLineSize.width]); 
                  TimeScale =1;
                  Xtitle="Year";
                  xAxis = d3.svg.axis().scale(x).orient("bottom");
               } else{
                  x =  d3.scale.linear().range([0, TimeLineSize.width]);
                  TimeScale = OneDay;
                  Xtitle = "Days";
                  xAxis = d3.svg.axis().scale(x).orient("bottom")
                            .ticks(10)
                            .tickFormat(function (d) { 
                               var Dir = (d<0 ? -1 : 1); 
                               return Math.round(Dir * (Math.pow(2, (Math.abs(d)))-1) *100)/100;
                            });
//                            .attr("width", 1440);
               }
            return {AlignBy: AlignBy, scale: x, timescale: TimeScale, title: Xtitle, axis: xAxis};
        }

//--------------------------------------------------------------------------------------------------
		function plotTimelines(){

               console.log("======== DisplayPatients.TimeLineDisplay");
      	d = new Date();
       	now = d.getTime();
		console.log("plot Timelines start: ",now - then);		then = now;

 		TimeLine.selectAll("g").remove();

			//------  Define Ranges
                var y = d3.scale.linear().range([TimeLineSize.height, 0]), 
                    yAxis = d3.svg.axis().scale(y).orient("left").ticks(0);
            
				var X = getTimelineXoptions();  //scale,TimeScale, title, axis

				var EventMin= null, EventMax = null;
				var allEvents = [];
				ptOrderArray.filter(function(id){ return ptList[id].showPatient }).forEach(function(d){  //return d.showPatient && !d.disabled;}), 
					var activeEvents = ptList[d].dateEvents.filter(function(event){ return !EventTypes[event.name].disabled; });
					if(activeEvents.length >0){
  					   allEvents = allEvents.concat(activeEvents);
  					   var first = (X.AlignBy == "--" ? activeEvents[0].date :                       LogTime((activeEvents[0].date - ptList[d].offset), X.TimeScale));
  					   var last  = (X.AlignBy == "--" ? activeEvents[activeEvents.length-1].date :   LogTime((activeEvents[activeEvents.length-1].date - ptList[d].offset), X.TimeScale));
					   if(EventMin === null || EventMin > first) EventMin = first;
					   if(EventMax === null || EventMax < last ) EventMax = last;
					}
                });  

               X.scale.domain([EventMin, EventMax]);
               y.domain([-2, ptOrderArray.length+1]);


			//------  Set axes
			   			
               TimeLine.append("g")
                       .attr("class", "x axis").attr("transform", "translate(0," + TimeLineSize.height + ")").call(X.axis)
                       .append("text").style("font-size", "12px").text(X.title);
               TimeLine.append("g")
                       .attr("class", "y axis").call(yAxis)
                       .append("text").attr("transform", "rotate(-90)").attr("y", 2).attr("dy", "-.71em")
                       .style("text-anchor", "end").style("font-size", "12px").text("Patients");
               var PixelScale = Math.max(Math.min(y(0)-y(1), 20), 3);
               console.log(PixelScale);
				// y domain doesn't filter by showPatient or event disabled - showPatient set to false when lacks AlignBy element so has blank row in timeline
 

			//------  Add mouse Features
               var Hoverbar = TimeLine.append("g").attr("class", "hoverbar");

               				  
               TimeLined3PlotBrush = d3.svg.brush().x(X.scale).y(y)
                                       .on("brushend", identifyEntitiesInCurrentSelection);
               TimeLine.call(TimeLined3PlotBrush);

                            
			//------ Define Event plot styles
				
				var openEventStack = [], eventPathAttr = [];
	
	            	function rect_eventParams(prior, event){
					if( typeof prior == "undefined" || typeof event == "undefined")
					  console.log("ERROR: event dates not properly specified", prior, event);
					var x = (X.AlignBy == "--" ? X.scale(prior.date) : X.scale(LogTime((prior.date - ptList[prior.ptID].offset), X.TimeScale)) ),
						x2 =(X.AlignBy == "--" ? X.scale(event.date) : X.scale(LogTime((event.date - ptList[event.ptID].offset), X.TimeScale)) ),
					    Y = y(ptOrderArray.indexOf(prior.ptID)) + PixelScale/(ptList[prior.ptID].PatientHeight+1),
					    width = x2-x,
					    height = PixelScale/ptList[event.ptID].PatientHeight,
					    fill = d3.rgb(TimeLineColor(prior.name)),
					    eventIDs = openEventStack.concat([event]),
					    id = event.ptID;
    			    if(width<3) width= 3;
					return {id:id,x:x, y:Y, height:height, width:width, fill:fill, eventIDs: eventIDs};
	  		    }
  
  				var prior;
                allEvents.forEach(function(event){
                     if(event.eventOrder == "single"){
                        eventPathAttr.push(rect_eventParams(event, event));
                    } else if(event.eventOrder == "start"){ 
                        if(openEventStack.length > 0) 						//start draw at end of interval (not beginning of line)
                       	    eventPathAttr.push(rect_eventParams(prior, event)); 
                       	prior  = event; 
                        openEventStack.push(event); 
                    } else if(event.eventOrder == "end"){
	                    	openEventStack = openEventStack.filter(function(ev){ return ev.eventID != event.eventID; }) ; //remove all matching eventID from stack
							eventPathAttr.push(rect_eventParams(prior, event));	   
							prior = event;
                    }
                });

			//------ plot Events in Timeline
                 var TimeSeries = TimeLine.append("g").selectAll("rect");

                 TimeSeries.data(eventPathAttr).enter().append("rect").attr("class", "rect")                 
                    	 .attr("x",      function(d) { return d.x; })
                    	 .attr("rx",     function(d) { return 5;})
                    	 .attr("ry",     function(d) { return 5;})
                    	 .attr("width",  function(d) { return d.width; })
                    	 .attr("y",      function(d) { return d.y; })
                    	 .attr("height", function(d) { return d.height; })
                    	 .attr("stroke", function(d) { return d.fill; })
                    	 .attr("border-radius", "20px")
                    	 .attr("fill", function(d){ 
                    	 	if(d.eventIDs.length >1)
                    	 		return "url(#diagonalHatch)";
                    	 	return d.fill; 
                    	 })
//	                     .attr("stroke-width", function(d){return d.strokeWidth;})
                         .on("mouseover", function(d,i){
                             Hoverbar.append("rect")
                                .attr("x", (0 - 2*SideBarSize.width ))
                                .attr("y", function(){return y(ptOrderArray.indexOf(d.id))+ PixelScale/(ptList[d.id].PatientHeight+1);})
                                .attr("width", TimeLineSize.width + 2*SideBarSize.width +TimeLineMargin.left)
                                .attr("height", function(){return PixelScale;})
                                .style("fill", "grey").style("opacity", 0.3);    
							 
							 tooltip.style("left", function(){ 
							 			var tipOffset = $(window).width() - (d3.event.pageX +400) ;
							 			tipOffset = (tipOffset < 0 ? tipOffset : 0);
							 			var tipOffsetString = (d3.event.pageX + tipOffset) + "px";
							 			return tipOffsetString; })		
							 		.style("top", (d3.event.pageY+5) + "px")
							 		.style("height", "250px").style("width", "350px");	
							 tooltip.html(function(){
								var EventsString = "<span ><b>" + Events[d.eventIDs[0].eventID].PatientID + ": </b>("+Events[d.eventIDs[0].eventID].study +")<br/>"; 
								for(i=0;i<d.eventIDs.length; i++){
									var Fields = Events[d.eventIDs[i].eventID].Fields;
									EventsString = EventsString + "<br/><b>"+ Events[d.eventIDs[i].eventID].Name + "</b><br/>";
									for(var f in Fields) { 
										if(f == "date"){
											if(Fields[f].length >1){
												EventsString = EventsString + f + ": " + getFormattedDate(Fields[f][0]) + ", "+ getFormattedDate(Fields[f][1]) + "<br/>"; 
											}else{
												EventsString = EventsString + f + ": " + getFormattedDate(Fields[f]) + "<br/>"; 
											}
										}else{    		
											EventsString = EventsString + f + ": " + Fields[f] + "<br/>"; }
										}
								}
			                    return EventsString + "</span>"; });
			                     $("#tooltipDiv").removeClass("eventNoHover").addClass("eventHover");})
                         .on("mouseout", function(d){
                            Hoverbar.select("rect").remove();
							setTimeout(function () {
								 $("#tooltipDiv").removeClass("eventHover").addClass("eventNoHover");}, 500);
                            })
                         .on("mousemove", function(){
                            return tooltip.style("top",(d3.event.pageY+5)+"px")
                            		.style("left",function(){ 
							 			var tipOffset = $(window).width() - (d3.event.pageX +400) ;
							 			tipOffset = (tipOffset < 0 ? tipOffset : 0);
							 			var tipOffsetString = (d3.event.pageX + tipOffset) + "px";
							 			return tipOffsetString; });  });
//                         .attr("data-legend",function(d) { return d.name;});

  	hub.enableTab(thisModulesOutermostDiv);

      	d = new Date();
       	now = d.getTime();
		console.log("plot Timelines finished: ", (now - then));		then = now;


	}  

//--------------------------------------------------------------------------------------------------
	function plotSideBar(){

		console.log("======== plotSideBar");
   			
   		SidePlot.selectAll("g").remove();
 
		   var x     = d3.scale.linear().range([0, SideBarSize.width]),
			   y     = d3.scale.linear().range([SideBarSize.height, 0]), 
			   xAxis = d3.svg.axis().scale(x).orient("bottom"),
			   yAxis = d3.svg.axis().scale(y).orient("left").ticks(0),
			   xTitle = ""
			   ;
			
               y.domain([-2, ptOrderArray.length+1]);
		   var PixelScale = d3.max([d3.min([y(0)-y(1), 20]), 3]);
		   console.log("PixelScale", PixelScale);
															
		   var barAttr = [];

			var SideOp = document.getElementById("SideBarOptions");
			var SideSel = SideOp.options[SideOp.selectedIndex];
			var SideplotVal = SideSel.text;
		
	   		if(SideSel.parentNode.label == "Category"){
			} else if(SideSel.parentNode.label == "Value"){
				var calc = ptList[ptOrderArray[0]].calcEvents;
				var typeNum = -1;
				for(var k=0;k<calc.length;k++){ 
					if(calc[k].name == SideplotVal){ typeNum = k; break; }
				}
				if(typeNum !== -1){
					barAttr =  getHorizontalBarSize(typeNum); 
					xTitle = barAttr[0].timeScale;
				}
			}

		   x.domain([d3.min([d3.min(barAttr, function(d){return d.width;}),d3.min(barAttr, function(d){return d.xBar;})]),
							 d3.max(barAttr, function(d){ return d.xBar + d.width;})]).nice();

		   SidePlot.append("g").attr("class", "x axis")
				   .attr("transform", "translate(0," +SideBarSize.height + ")").call(xAxis)
				   .selectAll("text").style("text-anchor", "end")
				   .style("font-size", "12px")
				   .attr("dy", ".55em").attr("dx", "-.45em")
				   .attr("transform", function(d) {return "rotate(-75)"; });
		   SidePlot.append("g").append("text")
				   .attr("transform", "translate(0," +SideBarSize.height + ")")
				   .style("font-size", "12px").text(xTitle);
		   SidePlot.append("g").attr("class", "y axis").call(yAxis)
				   .append("text").attr("transform", "rotate(-90)")
				   .attr("y", 2).attr("dy", "-.71em")
				   .style("font-size", "12px").style("text-anchor", "end")
				   .text(SideplotVal);
	
		   var BarPlot_Horiz = SidePlot.append("g").selectAll("rect")
				   .data(barAttr).enter().append("rect")
					 .attr("x", function(d)     { return x(d.xBar);  })
					 .attr("y", function(d)     { return y(d.yBar) + PixelScale/(ptList[d.id].PatientHeight+1); })   // rectangles draw from top down
					 .attr("width", function(d) { return Math.abs(x(d.width) - x(0));  })
					 .attr("height", function(d){ return PixelScale; }) 
					 .attr("fill", function(d){ 
						  var ColorShade =  d3.rgb("gray"); 
//						  if(EventTypes.keys().indexOf(SidePlotEvent) !== -1) { ColorShade = d3.rgb(TimeLineColor(SidePlotEvent)); }
						  return ColorShade;  })
					 .on("mouseover", function(d,i){
  						 tooltip.style("top",(d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");
  						 tooltip.style("height", "100px").style("width", "150px");
                         tooltip.text(d.id + ": " + d.info);
                         $("#tooltipDiv").removeClass("eventNoHover").addClass("eventHover");})
                     .on("mouseout", function(){
						 setTimeout(function () { $("#tooltipDiv").removeClass("eventHover").addClass("eventNoHover"); }, 500); })  //
					 .on("mousemove", function(){
                              return tooltip.style("top",(d3.event.pageY-50)+"px").style("left",(d3.event.pageX+10)+"px");})
;
	}
//--------------------------------------------------------------------------------------------------     
     function getHorizontalBarSize(Valtype){
     // ~~ is shortcut for Math.floor()
     
       var BarSizes = [];
		for(var i=0; i<ptOrderArray.length; i++){
			var calcEvent = ptList[ptOrderArray[i]].calcEvents[Valtype];
               var xBar = 0; var barWidth = calcEvent.value;
               if(typeof calcEvent.value === "undefined") barWidth = 0;
               if(calcEvent.value < 0){ xBar = calcEvent.value; barWidth = Math.abs(calcEvent.value);  }
               BarSizes.push( {id: ptOrderArray[i], info: calcEvent.value, xBar: xBar, yBar: i,  width: barWidth, timeScale: calcEvent.units});
       }
       return BarSizes;
     }

//--------------------------------------------------------------------------------------------------
     function updatePtOrderArray(enterIDs, exitIDs){

		var tempArray = ptOrderArray.filter(function(pt){ return exitIDs.indexOf(pt) === -1;});
		enterIDs.forEach(function(id){ 
 			tempArray = insertAscending(id, tempArray);
		});
		ptOrderArray = tempArray;
	 }
//--------------------------------------------------------------------------------------------------
     function setOrderByVal(id){
		var OrderOp = document.getElementById("OrderOptions");
		var OrderSel = OrderOp.options[OrderOp.selectedIndex];
		var OrderBy = OrderSel.text;
		
		ptList[id].orderVal = null;
		
   		if(OrderSel.parentNode.label == "Date"){
        	var dateEvents = ptList[id].dateEvents;
            for(var i=0;i<dateEvents.length; i++){
            	if(dateEvents[i].name == OrderBy){
            		ptList[id].orderVal = dateEvents[i].date;
            		break; 
            	}
            }
        	
    	} else if(OrderSel.parentNode.label == "Value"){
    		calcEvents = ptList[id].calcEvents;
    		for(var j=0;j<calcEvents.length; j++){
            	if(calcEvents[j].name == OrderBy){
					var eventValue =  calcEvents[j].value;
					if(OrderBy == "Survival"){
//						if(ptList[id]. == ){
//							eventValue = 1/eventValue
//						}
					}
					ptList[id].orderVal = eventValue
            		break; 
            	}
            }    
    	}

		return ptList[id].orderVal;

	}

//--------------------------------------------------------------------------------------------------
     function OrderEvents(){
     
		var OrderOp = document.getElementById("OrderOptions");
		var OrderBy = OrderOp.options[OrderOp.selectedIndex].text;
		
		var tempArray = [];
		for(var i=0;i<ptOrderArray.length;i++){
			setOrderByVal(ptOrderArray[i]);
			tempArray = insertAscending(ptOrderArray[i], tempArray);
		}
		ptOrderArray = tempArray;
	 }
//--------------------------------------------------------------------------------------------------
     function AlignEvents(){
     
		var AlignOp = document.getElementById("AlignOptions");
		var AlignBy = AlignOp.options[AlignOp.selectedIndex].text;

		var enterPts = [], removePts = [];  
        console.log("========Align Event: "+ AlignBy);
        
        for(var pt in ptList){ 
          	if(AlignBy == "--"){
          		ptList[pt].offset = 0; 
				ptList[pt].showPatient=true;
				setOrderByVal(pt);
//				if(ptOrderArray.indexOf(pt) === -1) enterPts.push(pt);
          	}else{
				ptList[pt].offset = null; 
				ptList[pt].showPatient=false;
		  
				var dateEvents = ptList[pt].dateEvents;
				for(var i=0;i<dateEvents.length; i++){
					if(dateEvents[i].name == AlignBy){
						ptList[pt].showPatient=true;
						ptList[pt].offset = dateEvents[i].date;
//						if(ptOrderArray.indexOf(pt) === -1) enterPts.push(pt);
						break; 
					}
				}
//				if(!ptList[pt].showPatient) {removePts.push(pt);}
			}
 		}
//		updatePtOrderArray(enterPts, removePts);
     }     

//--------------------------------------------------------------------------------------------------
   
   return{
          init: function(){
                hub.addOnDocumentReadyFunction(initializeUI);
                hub.registerSelectionDestination(selectionDestinationsOfferedHere, thisModulesOutermostDiv);
                hub.addMessageHandler("sendSelectionTo_Timelines", handleIncomingIDs);
                hub.addMessageHandler("DisplayPatientTimeLine", loadPatientDataDisplay);
                hub.addMessageHandler("TimelinesHandlePatientIDs", handlePatientIDs);
                hub.addMessageHandler("datasetSpecified", datasetSpecified);
          },
     };

}); // TimeLineModule
//----------------------------------------------------------------------------------------------------
PatientTimeLine = TimeLineModule();
PatientTimeLine.init();


//----------------------------------------------------------------------------------------------------
// move these all back inside module scope when debugging is done

var cwMarkers;
var markersTester;

//----------------------------------------------------------------------------------------------------
var markersAndTissuesModule = (function () {

  var statusDiv; 
  var cyDiv;
  var searchBox;
  var hideEdgesButton, showEdgesButton, showAllEdgesButton, clearSelectionButton, sfnButton;
  var nodeRestriction = [];
  var subSelectButton;
  var helpButton;
  var infoMenu;
  var edgeTypeSelector;
  var mouseOverReadout;
  var graphOperationsMenu;
  var tumorCategorizationsMenu;
  var tumorCategorizationsMenuTitle = "Tumor Groups...";
  var sendSelectionsMenu;
  var layoutMenu;
  var thisModulesName = "MarkersAndPatients";
  var thisModulesOutermostDiv = "markersAndPatientsDiv";
  var userID = "NA";

      // sometimes a module offers multiple selection destinations.
      // usually there is just one:

  var selectionDestinations = [thisModulesName];


  var sendSelectionsMenuTitle = "Send selection...";

     // the user may specify that only certain tumors, and/or certain genes
     // are to be used in any subsequent network operations -- especially
     // "show edges from selected nodes"
     // to experiment with this capability, there are two new net ops menu
     // options, which assign zero or more selected nodes to these variables,
     // which are then used (if defined) to limit the subsequent network
     // operation


//--------------------------------------------------------------------------------------------
function initializeUI ()
{

  cyDiv = $("#cyMarkersDiv");
  statusDiv = $("#markersAndPatientsStatusDiv");

  sendSelectionsMenu = hub.configureSendSelectionMenu("#cyMarkersSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                      sendSelectionsMenuTitle);

  tumorCategorizationsMenu = $("#cyMarkersTumorCategorizationsMenu");
  tumorCategorizationsMenu.empty();
  tumorCategorizationsMenu.append("<option>" + tumorCategorizationsMenuTitle + "</option>");
  tumorCategorizationsMenu.change(requestTumorCategorization);

  graphOperationsMenu = $("#cyMarkersOperationsMenu");
  graphOperationsMenu.change(doGraphOperation);
  graphOperationsMenu.empty();
  graphOperationsMenu.append("<option>Network Operations...</option>");

  var operations = ["Show All Edges",
                    "Show Edges from Selected Nodes",
                    "Hide All Edges",
                    //"Connect to First Neighbors",
                    "Invert Node Selection",
                    "Clear Selections",
                    "Select All Connected Nodes",
                    "Select All Nodes with Selected Edges",
                    "Hide Unselected Nodes",
                    "Show All Nodes",
                    "Restrict Next Ops to Selected Nodes"];

  for(var i=0;i< operations.length; i++){
     var optionMarkup = "<option>" + operations[i] + "</option>";
     graphOperationsMenu.append(optionMarkup);
     } // for 


   layoutMenu = $("#markerLayouts");
   layoutMenu.change(performLayout);

   showEdgesButton = $("#cyMarkersShowEdgesButton");
   showEdgesButton.click(showEdges);
   
   showAllEdgesButton = $("#cyMarkersShowAllEdgesButton");
   showAllEdgesButton.click(showAllEdges);

   sfnButton = $("#cyMarkersSFNButton");
   sfnButton.click(selectFirstNeighbors);
   clearSelectionButton = $("#cyMarkersClearSelectionButton");
   clearSelectionButton.click(clearSelection);

   hideEdgesButton = $("#cyMarkersHideEdgesButton");
   hideEdgesButton.click(hideAllEdges);


   searchBox = $("#markersAndTissuesSearchBox");

   edgeTypeSelector = $("#markersEdgeTypeSelector");
   edgeTypeSelector.chosen();

   mouseOverReadout = $("#markersAndTissuesMouseOverReadout");
   configureCytoscape();
   //$(".chosen-select").chosen();
   $(window).resize(handleWindowResize);

   subSelectButton = $("#markersSubSelectButton");
   subSelectButton.click(subSelectNodes);

  //if(hub.socketConnected())
  //   runAutomatedTestsIfAppropriate();
  //else
  //   hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);

   setInterval(function(){
      var count = cwMarkers.nodes("node:selected").length;
      var disable = (count === 0);
      sendSelectionsMenu.attr("disabled", disable);
      subSelectButton.attr("disabled", disable);
      }, 500);
      
   hub.disableTab(thisModulesOutermostDiv);
 
} // initializeUI
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("CyMarkers send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: nodeNames, count: nodeNames.length, source: "markers and patients module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function configureLayoutsMenu(layoutMenu){

   console.log("--- configureLayoutsMenu");
   layoutMenu.append("<option>Layouts...</option>");
   layoutMenu.append("<option> Save Current</option>");

   var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
          var result = {id:n.id(), position:n.position()};
          return (result);  
          }) // map
       ); // stringify

   localStorage.markersDefault = defaultLayout;

   var existingLayouts = Object.keys(localStorage);
   for(var i=0; i < existingLayouts.length; i++){
      if(existingLayouts[i].match("markers") !== null){
        layoutMenu.append("<option>" + existingLayouts[i] + "</option>");
        }
      } // for i

} // configureLayoutsMenu
//----------------------------------------------------------------------------------------------------
function performLayout(event){

  var chosenLayoutName = layoutMenu.val();

  if(chosenLayoutName == "Save Current"){
     var uniqueNumber = Math.floor(new Date().getTime()/1000);   // number of seconds since 1970
     newName = "markers." + (uniqueNumber - 1420414900);    // since today, very roughly
     var positions = cwMarkers.nodes().map(function(n){
           var result = {id:n.id(), position:n.position()};
           return(result);
           }); // map
     currentLayout = JSON.stringify(positions);
     localStorage[newName] = currentLayout;
     layoutMenu.append("<option>" + newName + "</option>");
     layoutMenu.val(newName);
     return;
     } // if "Save Current"

  if(Object.keys(localStorage).indexOf(chosenLayoutName) >= 0){
     var newLayout;
     newLayout = JSON.parse(localStorage[chosenLayoutName]);
     cwMarkers.nodes().positions(function(i, node){
        return{x: newLayout[i].position.x, y:newLayout[i].position.y};
         });
     } // if requested layout name is recognized
  
  layoutMenu.val("Layouts...");   // restore the title

} // performLayout
//--------------------------------------------------------------------------------------------
function sendSelection()
{
   destinationModule = sendSelectionsMenu.val();
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }
   metadata = {};
   sendSelectionToModule(destinationModule, nodeNames, metadata);
   sendSelectionsMenu.val("Send Selection...");

} // sendSelectionsMenuChanged
//--------------------------------------------------------------------------------------------
function configureCytoscape ()
{
  cwMarkers = $("#cyMarkersDiv");
  cwMarkers.cytoscape({
     boxSelectionEnabled: true,
     showOverlay: false,
     minZoom: 0.01,
     maxZoom: 8.0,
     layout: {
       name: "preset",
       fit: true
       },
   ready: function() {
      console.log("cwMarkers ready");
      cwMarkers = this;
      cwMarkers.on('mouseover', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val(node.id());
         });
      cwMarkers.on('mouseout', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val("");
         });
      cwMarkers.on('mouseover', 'edge', function(evt){
         var edge = evt.cyTarget;
         var d = edge.data();
         var msg = d.edgeType + ": " + d.source + " - " + d.target;
         var mutation = d.mutation;
         if(typeof(mutation) == "string")
            msg = mutation + " " + msg;
         mouseOverReadout.val(msg);
         });

      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      searchBox.keydown(doSearch);

      console.log("cwMarkers.reset");
      cwMarkers.reset();
      handleWindowResize();
      cwMarkers.edges().selectify(); // this seems to hold through session, visibility notwithstanding
      //hideAllEdges();
      configureLayoutsMenu(layoutMenu);
      cwMarkers.fit(50);
      }, // cy.ready
     }) // .cytoscape
    .cytoscapePanzoom({ });   // need to learn about options

} // configureCytoscape
//----------------------------------------------------------------------------------------------------
function handleWindowResize ()
{
   cyDiv.width(0.95 * $(window).width());
   cyDiv.height(0.8 * $(window).height());
   cwMarkers.resize();
   cwMarkers.fit(50);

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
// there are often subgroups among a selected node.
// here we opreate only on those distinguished by different node border color
// the dialog posted here provided interactive select/deselect of those originally
// selected nodes, by color.
// this function could be made smarter by being made avaialble (via the subselect button) only
// if multiple border colors are found within the currently selected nodes
//
function subSelectNodes()
{
  var selectedNodes = cwMarkers.nodes("node:selected");
  var borderColors =  jQuery.unique(selectedNodes.map(function(node){return (node.style("border-color"));}));
  console.log(JSON.stringify(borderColors));

  var content = "<form action=''>";
  for(i=0; i < borderColors.length; i++){
     var color = borderColors[i];
     var e = "<input type='checkbox' class='markersSubSelectRadioButton' name='" + color + "' checked> " + color + "<br>";
     content = content + e;
     }
  content = content + "</form>";
  button = "<br><br><button id='markersSubSelectCloseButton'>Close</button>";

  content = content + button;

  var dialog =  $('<div id="markersSubSelectDialog" />').html(content).dialog();

  $("#markersSubSelectCloseButton").click(function(){
     console.log("close dialog");
     $("#markersSubSelectDialog").remove();
     });

  $(".markersSubSelectRadioButton").click(function(e) {
      console.log("radio!"); 
      console.log(this.name + " " + this.checked);
      var color = this.name;
      var selectSubset = this.checked;
      var subsetNodes = selectedNodes.filterFn(function(node) {return(node.style("border-color") == color);});
      if(selectSubset)
         subsetNodes.select();
      else
         subsetNodes.unselect();
      }); // radio button click

} // subSelectNodes
//----------------------------------------------------------------------------------------------------
function requestTumorCategorization()
{
  var allCategoryNames = tumorCategorizationsMenu.children().map(function() {return $(this).val();}).get();
  var menuTitle = allCategoryNames[0];
  var categorizationName = tumorCategorizationsMenu.val();
  if(categorizationName === menuTitle)
     return;
     
  console.log("apply " + categorizationName);
  hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "request", "");

  var msg = {cmd: "getSampleCategorization", callback: "markersApplyTumorCategorization",
             status: "request", payload: categorizationName};

  hub.send(JSON.stringify(msg));

} // requestTumorCategorization
//----------------------------------------------------------------------------------------------------
function applyTumorCategorization(msg)
{
   console.log("=== applyTumorCategorization");
   var tumorsInGraph = cwMarkers.nodes("[nodeType='patient']");
   var tumorsInTable = msg.payload.rownames;
   var tbl = msg.payload.tbl;
   hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "data received", "");


   tumorsInGraph.forEach(function(node, index){
      var nodeID = node.id();  // our convention is that this is the tumor name, eg, "TCGA.02.0014"
      var indexInTable = tumorsInTable.indexOf(nodeID);
      if(indexInTable >= 0){
         var cluster = tbl[indexInTable][0];
         node.data({subType: cluster});
         }
      else{
         node.data({subType: "unassigned"});
         }
       }); // forEach

  cwMarkers.style().update();
  postStatus("applyTumorCategorization complete");
  hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "node subType assigned", "");

} // applyTumorCategorization
//----------------------------------------------------------------------------------------------------
function doGraphOperation()
{
   var operation = graphOperationsMenu.val();

   switch(operation){
      case "Show All Edges":
         showAllEdges();
         break;
      case "Show Edges from Selected Nodes":
         //showEdgesFromSelectedNodes();
         showEdgesFromSelectedNodes();
         break;
      case "Hide All Edges":
         hideAllEdges();
         break;
      case "Invert Node Selection":
         invertSelection();
         break;
      case "Clear Selections":
         cwMarkers.filter('node:selected').unselect();
         break;
      case "Select All Connected Nodes":
         selectAllConnectedNodes();
         break;
      case "Select All Nodes with Selected Edges":
        selectAllNodesConnectedBySelectedEdges();
        break;
      case "Hide Unselected Nodes":
         cwMarkers.filter("node:unselected").hide();
         break;
      case "Show All Nodes":
         cwMarkers.filter('node:hidden').show();
         break;
      case "Restrict Next Ops to Selected Nodes":
         restrictNextOpsToSelectedNodes();
         break;
      default:
         console.log("unrecoginized graph operation requested from menu: " + operation);
      } // switch

      // restore menu to initial condition, with only title showing
   graphOperationsMenu.val("Network Operations...");

} // doGraphOperation
//----------------------------------------------------------------------------------------------------
function clearSelection ()
{
   cwMarkers.elements().unselect();
}
//----------------------------------------------------------------------------------------------------
function selectFirstNeighbors ()
{
  selectedNodes = cwMarkers.filter('node:selected');
  showEdgesForNodes(cwMarkers, selectedNodes);

}
//----------------------------------------------------------------------------------------------------
function invertSelection ()
{
   selected = cwMarkers.filter("node:selected");
   unselected = cwMarkers.filter("node:unselected");
   selected.unselect();
   unselected.select();
}
//----------------------------------------------------------------------------------------------------
function hideAllEdges ()
{
     // hide all edges besides chromsome edges
  cwMarkers.edges().fnFilter(function(edge) {
     return(edge.data("edgeType") != "chromosome");
     }).hide();

} // hideAllEdges
//----------------------------------------------------------------------------------------------------
function showAllEdges ()
{
   var edgeTypesToDisplay = edgeTypeSelector.val();

   console.log("edgeTypeToDisplay: " + edgeTypesToDisplay);

   if(edgeTypesToDisplay === null){
      return;
      }

   for(var e=0; e < edgeTypesToDisplay.length; e++){
      var type =  edgeTypesToDisplay[e];
      selectionString = '[edgeType="' + type + '"]';
      //console.log(" showAllEdges selection string: " + selectionString);
      cwMarkers.edges(selectionString).show();
      } // for e

} // showAllEdges
//----------------------------------------------------------------------------------------------------
function zoomSelected()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 100);
}
//----------------------------------------------------------------------------------------------------
function handleIncomingIdentifiers(msg)
{
   console.log("Module.markers, handleIncomingIdentifiers");
      // expect 3 payload fields: value, count, source
   var ids = msg.payload.value; 
   if(typeof(ids) == "string")
      ids = [ids];
   //intersectingIDs = hub.intersectionOfArrays(ids, nodeNames())
   intersectingIDs = hub.intersectionOfArrays(ids, nodeIDs());
   console.log("found ids: " + intersectingIDs.length);

   if(intersectingIDs.length > 0){
      selectNodesByID(intersectingIDs);
      }
   else{
      errorMessage = "No overlap with genes or tissue sample IDs:  <br><br>" +
                      ids.join(", ");
      title = ids.length + " unrecognized identifiers";
      console.log("+++++++++++ creating error div");
      $('<div id="markersIncomingIdentifiersErrorDialog" />').html(errorMessage).dialog({title: title, width:600, height:300});
      }

   console.log("about to post status from incoming identifiers");
   postStatus("incoming identifiers: " + ids.length);

   hub.raiseTab(thisModulesOutermostDiv);

} // handleIncomingIdentifiers
//----------------------------------------------------------------------------------------------------
  // run all that should happen when this module receives an incoming selection of patientIDs
function demoMarkersIncomingSelectionOfIDs()
{

   names = ["TCGA.06.0210", "TCGA.02.0106", "TCGA.02.0111",
            "TCGA.06.0194", "TCGA.06.0164", "TCGA.06.0409", "TCGA.02.0004",
            "TCGA.02.0051", "TCGA.08.0390", "TCGA.02.0025", "TCGA.08.0392",
            "TCGA.02.0079", "TCGA.12.0620", "TCGA.08.0373", "TCGA.06.0645",
            "TCGA.06.0192", "TCGA.12.0776", "TCGA.12.0778", "TCGA.06.0750",
            "TCGA.06.0878", "TCGA.14.0789", "TCGA.06.0881", "BCL11A",
            "BRCA1", "MDM2", "PIK3R1", "ABCA1", "CDK6", "CNTRL", "FH",
            "IFNA1", "LMO2", "PRKCA", "RELA", "STK11", "ZEB1", "CCNB1IP1",
            "CREB3L1", "GDF2", "OR4K2", "PRKCH", "WAS"];

   subset = [];
   for(var i=0; i < 10; i++)
     subset.push(names[getRandomInt(0, names.length -1)]);

   selectNodes(subset);

} // demoIncomingSelectionOfPatientIDs
//----------------------------------------------------------------------------------------------------
function allNodeIDs()
{
   ids = [];
   allNodes = cwMarkers.nodes();

   for(i=0; i < allNodes.length; i++)
       ids.push(allNodes[i].data("id"));

   return(ids);

} // allNodeIDs
//----------------------------------------------------------------------------------------------------
function showEdges()
{
   hideAllEdges();   // is this wise?

   var edgeTypesToDisplay = edgeTypeSelector.val();
   if(edgeTypesToDisplay === null){
      hideAllEdges();
      return;
      }

   var selectedNodes = selectedNodeIDs(cwMarkers);

   //console.log(" newEdgeTypeSelection (" + edgeTypesToDisplay.length + 
   //            "), selectedNodes: " + selectedNodes.length);

   if(selectedNodes.length > 0) { // show edges to and from all selected nodes
     showEdgesForNodes(cwMarkers, selectedNodes);
     }

} // showEdges
//----------------------------------------------------------------------------------------------------
// function showEdgesFromSelectedNodes()
// {
//    var selectedNodes = cwMarkers.filter('node:selected');
// 
//       // break out the selected nodes into the two groups we care about: 
//       //    genes & tumors (aka, patients)
// 
//    var tumorNodes = selectedNodes.filter("[nodeType='patient']");
//    var geneNodes  = selectedNodes.filter("[nodeType='gene']");
// 
//       // if any tumor node restriction is in force, only 
//       // the intersecton of that with our current selection is kept
// 
//    if(tumorNodeRestriction.length > 0){
//       var correctedTumorNodes = [];
//       tumorNodes.forEach(function(node){
//         if(tumorNodeRestriction.indexOf(node.id()) >= 0){
//            console.log("match!");
//            correctedTumorNodes.push(node);
//           } // if matched
//         }); // forEach
//      console.log("some tumor nodes restricted, some selected");
//      tumorNodes = correctedTumorNodes;   // 0 or more
//      } // some tumor nodes restricted
// 
//    if(geneNodeRestriction.length > 0){
//       var correctedGeneNodes = [];
//       geneNodes.forEach(function(node){
//        if(geneNodeRestriction.indexOf(node.id()) >= 0){
//          console.log("match!");
//          correctedTumorNodes.push(node);
//           } // if matched
//        }); // forEach
//     console.log("some gene nodes restricted, some selected");
//     geneNodes = correctedGeneNodes;   // 0 or more
//     } // some gene node restriction
//        
//    selectedNodes = tumorNodes;
//    geneNodes.forEach(function(node){selectedNodes.push(node)});
// 
//    if(selectedNodes.length == 0) {
//       return;
//       }
// 
//       // "closed" means that we have tumors and genes specified, and
//       // only want to find connections among them
// 
//    //var closedCandidates = FALSE;
// 
//    //if(tumorNodes.length > 0 & geneNodes.length > 0)
//    //   closedCandidates = TRUE;
// 
//    debugger;
//    showEdgesForNodes(cwMarkers, selectedNodes);
// 
// } // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function zoomSelection()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 50);

}
//----------------------------------------------------------------------------------------------------
function selectedNodeIDs(cw)
{
   ids = [];
   noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     ids.push(noi[n].data('id'));
     }
  return(ids);

} // selectedNodeIDs
//----------------------------------------------------------------------------------------------------
function selectedNodeNames(cw)
{
   var names = [];
   var noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }
  return(names);

} // selectedNodeNames
//----------------------------------------------------------------------------------------------------
function showEdgesFromSelectedNodes()
{
   var targets = nodeRestriction;
   var selectedNodes = cwMarkers.nodes("node:selected");
   var neighbors = selectedNodes.neighborhood();
   var candidateEdges = neighbors.filterFn(function(e){
       if(e.isEdge()) return (e);
       });

   candidateEdges = candidateEdges.fnFilter(function(edge){
      return(edgeTypeSelector.val().indexOf(edge.data("edgeType")) >= 0);
      });

   if(targets.length === 0){
      candidateEdges.show();
      return;
      }

   function intersects(array1, array2){
      var size = array1.filter(function(n) {return (array2.indexOf(n) != -1);}).length;
      return(size > 0);
      }

   candidateEdges.filterFn(function(edge){
      var actual=edge.connectedNodes().map(function(node){return node.id();});
      return(intersects(actual, targets));
       }).show();

} // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function selectSourceAndTargetNodesOfEdges(cw, edges)
{
  //var eoi = cwMarkers.filter('edge:visible');
  var notChromosomal = function(edge){return(edge.data("edgeType") !== "chromosome");};
  eoi = edges.filterFn(notChromosomal);

  var filterStrings = [];

  for(var i=0; i < eoi.length; i++){
     edge = eoi[i];
     targetID = edge.target().data("id");
     sourceID = edge.source().data("id");
     var sourceFilterString = '[id="' + sourceID + '"]';
     var targetFilterString = '[id="' + targetID + '"]';
     filterStrings.push(sourceFilterString);
     filterStrings.push(targetFilterString);
     } // for i

   var nodesToSelect = cw.nodes(filterStrings.join());
   nodesToSelect.select();

} // selecteSourceAndTargetNodesOfEdge
//----------------------------------------------------------------------------------------------------
  // todo: massive inefficiencies here
function showEdgesForNodes(cw, nodes)
{

  var edgeTypes = edgeTypeSelector.val();
  console.log("=== showEdgesForNodes, edgeType count: " + edgeTypes.length);
  console.log(edgeTypes);

  if(edgeTypes.length === 0)
      return;

  var filterStrings = [];

  $("body").toggleClass("wait");

  setTimeout(function(){
     for(var e=0; e < edgeTypes.length; e++){
        var edgeType = edgeTypes[e];
        for(var n=0; n < nodes.length; n++){
          var nodeID = nodes[n].data("id");
          var sourceFilterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
          var targetFilterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
          filterStrings.push(sourceFilterString);
          filterStrings.push(targetFilterString);
          } // for n
        } // for e

      console.log("filterString count: " + filterStrings.length);
      filter = filterStrings.join();
      console.log("filter created, about to apply...");
      var existingEdges = cw.edges(filter);
      console.log("filtering complete");
      if(existingEdges.length > 0) {
         console.log("about to show edges");
         existingEdges.show();
         console.log("edges shown...");
         }
     }, 1000); // setTimeout

  $("body").toggleClass("wait");

} // showEdgesForNodes
//----------------------------------------------------------------------------------------------------
function selectAllConnectedNodes()
{
    var selectedEdges = cwMarkers.filter("edge:visible");
    selectedEdges = selectedEdges.filterFn(function(e){return (e.data("edgeType") !== "chromosome");});
    if(selectedEdges.length > 0)
       selectSourceAndTargetNodesOfEdges(cwMarkers, selectedEdges);

} // selectAllConnectedNodes
//----------------------------------------------------------------------------------------------------
function selectAllNodesConnectedBySelectedEdges()
{
    edges = cwMarkers.filter("edge:selected");
    console.log(" selected edge count: " + edges.length);
    if(edges.length === 0)
      return;
    for(var e=0; e < edges.length; e++){
       selectNodes(edges[e].target().data("name"));
       selectNodes(edges[e].source().data("name"));
       } // for e

} //selectAllNodesConnectedBySelectedEdges
//----------------------------------------------------------------------------------------------------
function showEdgesForSelectedNodes(cw, edgeTypes)
{
   var nodeIDs = selectedNodeIDs(cw);
   for(var n=0; n < nodeIDs.length; n++){
      nodeID = nodeIDs[n];
      for(var e=0; e < edgeTypes.length; e++){
         edgeType = edgeTypes[e];
         filterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         filterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         } // for e
      } // for n

} // showEdgesForSelectedNodes
//----------------------------------------------------------------------------------------------------
function restrictNextOpsToSelectedNodes()
{
  var nodes = cwMarkers.nodes("node:selected"); // .filter("[nodeType='gene']");
  if(nodes.length === 0){
     nodeRestriction = [];
     }
  else{
     nodeRestriction = nodes.map(function(node){return (node.id());});
     }

} // restrictNextOpsToSelectedNodes
//----------------------------------------------------------------------------------------------------
function nodeNames()
{
  var nodes = cwMarkers.filter("node:visible");
  var result = [];
  for(var i=0; i < nodes.length; i++){
    result.push(nodes[i].data().label);
    } // for i

  return(result);

} // nodeNames
//----------------------------------------------------------------------------------------------------
function nodeIDs()
{
   return(cwMarkers.nodes().map(function(node){return (node.id());}));
}
//----------------------------------------------------------------------------------------------------
function upperCaseNodeIDs()
{
   return(nodeIDs().map(function(node){return(node.toUpperCase());}));
}
//----------------------------------------------------------------------------------------------------
// todo: build up the filter string first, then send it all at once
function selectNodes(nodeNames)
{
  console.log("Module.markers::selectNodes");
  //console.log(nodeNames);

  if(typeof(nodeNames) == "string")   // trap scalar, but expect and support arrays
     nodeNames = [nodeNames];

  var allNodes = cwMarkers.nodes().map(function(n){return (n.id());});
  var allNodesUpperCase = allNodes.map(function(name){return (name.toUpperCase());});

  for(var i=0; i < nodeNames.length; i++){
    var nodeName = nodeNames[i].toUpperCase();  // depends upon this conv
    var index = allNodesUpperCase.indexOf(nodeName);
    if(index >= 0){
      var actualNodeID = allNodes[index];
      var s = "cwMarkers.filter('node[id=\"" + actualNodeID + "\"]').select()";
       //console.log("markers selectNodes: " + s);
       eval (s);
       } // if found, index >= 0
    } // for i

} // selectNodes
//----------------------------------------------------------------------------------------------------
   // todo: build up the filter string first, then send it all at once
function selectNodesByID(nodeIDs) {

  if(typeof(nodeIDs) == "string")   // trap scalar, but expect and support arrays
     nodeIDs = [nodeIDs];

  console.log("about to select nodes by id: " + nodeIDs.length);
  console.log(nodeIDs);

  for(var i=0; i < nodeIDs.length; i++){
    s = "cwMarkers.filter('node[id=\"" + nodeIDs[i] + "\"]').select()";
    console.log(s);
    eval (s);
    } // for i

} // selectNodesByID
//----------------------------------------------------------------------------------------------------
function doSearch(e)
{
   var keyCode = e.keyCode || e.which;

   if (keyCode == 13) {
      var searchString = searchBox.val().toUpperCase();
      console.log("searchString: " + searchString);
      var idsActual = nodeIDs();
      var idsUpper = upperCaseNodeIDs();
      var hits = idsUpper.filter(function(id) {return(id.startsWith(searchString));});
      var hitIndices = hits.map(function(hit) {return(idsUpper.indexOf(hit));});
      var hitsActual = hitIndices.map(function(hit) {return(idsActual[hit]);});
      selectNodes(hitsActual);
      } // if 13 (return key)

} // doSearch
//----------------------------------------------------------------------------------------------------
function displayMarkersNetwork(msg)
{
   console.log("--- Module.markers: displayMarkersNetwork");

   hub.logEventOnServer(thisModulesName, "display markers network", "data received", "");

   if(msg.status == "success"){
      console.log("nchar(network): " + msg.payload.length);
      var json = JSON.parse(msg.payload);
      cwMarkers.remove(cwMarkers.edges());
      cwMarkers.remove(cwMarkers.nodes());
      console.log(" after JSON.parse, json.length: " + json.length);
      console.log("  about to add json.elements");
      cwMarkers.add(json.elements);
      console.log("  about to add  json.style");
      cwMarkers.style(json.style);
      console.log("   hiding edges");
      cwMarkers.edges().hide();
      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      cwMarkers.nodes().unselect();
        // map current node degree into a node attribute of that name
      cwMarkers.nodes().map(function(node){node.data({degree: node.degree()});});

      var edgeTypes = hub.uniqueElementsOfArray(cwMarkers.edges().map(function(edge){
                               return(edge.data("edgeType"));}
                               ));
      updateEdgeSelectionWidget(edgeTypes);  // preserve only known edgeTypes
      cwMarkers.fit(20);
      var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
                                         return({id:n.id(), position:n.position()});}));
      localStorage.markersDefault = defaultLayout;
      hub.logEventOnServer(thisModulesName, "display markers network", "complete", "");

        //postStatus("markers network displayed");  // deferred; set when the category menu is configured

      hub.logEventOnServer(thisModulesName, "getSampleCategorizationNames", "request", "");

      var msg2 = {cmd: "getSampleCategorizationNames", callback: "configureSampleCategorizationMenu",
                  status: "request", payload: ""};
      hub.send(JSON.stringify(msg2));
      }
   else{
     console.log("displayMarkersNetwork error: " + msg.payload);
     }

} // displayMarkersNetwork
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// ensure that only edgeTypes in current network are offered in the selection widget
function updateEdgeSelectionWidget(edgeTypes)
{
     // loop over currently offered edge types
   var options = $("#markersEdgeTypeSelector").children();
   for(var i=0; i < options.length; i++){
      var optionElement = options[i];
      var optionValue = optionElement.value;
      var found = jQuery.inArray(optionValue, edgeTypes) >= 0;
      console.log("checking option '" + optionValue + "':  " + found);
      if(!found){
         console.log("  deleting selector option " + optionValue);
         $("#markersEdgeTypeSelector option[value='" + optionValue + "']").remove();
         } // unrecognized edge type
      }
   $("#markersEdgeTypeSelector").trigger("chosen:updated");

} // updateEdgeSelectionWidget
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the g.markers.json network from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

   hub.logEventOnServer(thisModulesName, "display markers network", "request", "");

   var newMsg = {cmd: "getMarkersNetwork",  callback: "displayMarkersNetwork", status: "request", payload: datasetName};
   hub.send(JSON.stringify(newMsg));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function configureSampleCategorizationMenu(msg)
{
   console.log("=== configureSampleCategorizationMenu");
   //console.log(msg.payload);
   tumorCategorizationsMenu.empty();
   var categorizations = msg.payload;

   if(typeof categorizations == "string") 
   	 categorizations = [categorizations];

   var titleOption = "Tumor Groups...";

   tumorCategorizationsMenu.append("<option>" + titleOption + "</option>");

   for(var i=0; i < categorizations.length; i++){
     tumorCategorizationsMenu.append("<option>" + categorizations[i] + "</option>");
     } // for i

   tumorCategorizationsMenu.val(titleOption);
   hub.logEventOnServer(thisModulesName, "getSampleCategorizationNames",  "complete", "");
   
   hub.enableTab(thisModulesOutermostDiv);
   postStatus("markers network displayed");

} // configureSampleCategorizationMenu
//----------------------------------------------------------------------------------------------------

 return{
     init: function(){
        hub.addMessageHandler("sendSelectionTo_MarkersAndPatients", handleIncomingIdentifiers);
        hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
        hub.addMessageHandler("datasetSpecified", datasetSpecified);
        hub.addMessageHandler("displayMarkersNetwork", displayMarkersNetwork);
        hub.addMessageHandler("configureSampleCategorizationMenu", configureSampleCategorizationMenu);
        hub.addMessageHandler("markersApplyTumorCategorization", applyTumorCategorization);
        hub.addOnDocumentReadyFunction(initializeUI);
       }
     };

   }); // markersAndTissuesModule
//----------------------------------------------------------------------------------------------------
markersModule = markersAndTissuesModule();
markersModule.init();

//----------------------------------------------------------------------------------------------------
var cyGbm;   // keep this public so that the tabsApp can see it, reset on tab activate
var expressionData = [];   // consists of a gene list, a tissue list, and the data (a list of 
                           // gene/value pairs, each list named by a tissue (patient) id
var cnvData = [];
var mutationData = [];

var gbmPathwaysModule = (function () {

  var cyGbmDiv;
  var statusDiv; 
  var viewAbstractsButton, zoomSelectedButton;
  var tissueMenu, movieButton;
  var movieButtonOriginalColor, movieButtonDisabledColor = "lightGray";
  var selectLabel;

  var slowerMovieButton, fasterMovieButton;
  var currentMovieSpeed = 750;
  var movieSpeedReadout;
  var movieIntervalID;

  var searchBox;
  var edgeAbstractsOn = false;

  var moviePlaying = false;

  var infoMenu;

  var sendSelectionsMenu;
  var sendSelectionsMenuTitle = "Send selection...";

  var thisModulesName = "gbmPathways";
  var thisModulesOutermostDiv = "gbmPathwaysDiv";
  var selectionDestinations = [thisModulesName];
  var outermostDiv;
  var controlsDiv;

  var errorDialogBox;

  //--------------------------------------------------------------------------------------------
function initializeUI(network, vizmap)
{
   outermostDiv = $("#gbmPathwaysDiv");

   cyGbmDiv = $("#cyGbmPathwaysDiv");
   statusDiv = $("#gbmPathwaysStatusDiv");
   controlsDiv = $("#gbmPathwaysButtonDiv");

   selectLabel = $("#gbmPathwaysSelectLabel");
   selectLabel.css("color", "lightgray");   // not functional until some tissueIDs have been been added
   viewAbstractsButton = $("#gbmViewAbstractsButton");
   viewAbstractsButton.button();
   viewAbstractsButton.click(toggleEdgeSelection);

   zoomSelectedButton  = $("#gbmZoomSelectedButton");
   zoomSelectedButton.button()
   zoomSelectedButton.click(zoomSelection);

   tissueMenu = $("#gbmPathwaysSampleSelector");
   tissueMenu.change(tissueSelectorChanged);

   movieButton = $("#gbmPathwaysMovieButton");
   movieButton.button();
   movieButtonOriginalColor = movieButton.css("color");
   movieButton.prop("disabled", true);
   movieButton.css("color", movieButtonDisabledColor);

   slowerMovieButton = $("#gbmPathwaysSlowerMovieButton");
   slowerMovieButton.button();
   fasterMovieButton = $("#gbmPathwaysFasterMovieButton");
   fasterMovieButton.button();

   movieSpeedReadout = $("#gbmPathwaysMovieSpeedReadout");
   movieSpeedReadout.text(Number(currentMovieSpeed/1000).toFixed(2));

   fasterMovieButton.click(function() {changeMovieSpeed(-250);})
   slowerMovieButton.click(function() {changeMovieSpeed(250);})
   
   movieButton.text("Play Movie");
   movieButton.click(togglePlayMovie);
   searchBox = $("#gbmPathwaysSearchBox");


   sendSelectionsMenu = hub.configureSendSelectionMenu("#gbmPathwaysSendSelectionMenu",
                                                       [thisModulesName], sendSelections,
                                                       sendSelectionsMenuTitle);

   sendSelectionsMenu.attr("disabled", true);

   loadNetwork();
   $(window).resize(handleWindowResize);

   hub.disableTab(thisModulesOutermostDiv)


 }; // initializeUI
//----------------------------------------------------------------------------------------------------
function selectedNodeNames(cw)
{
   var names = [];
   var noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }
  return(names);

} // selectedNodeNames
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("CyMarkers send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);
   var nodeNames = selectedNodeNames(cyGbm);
   if(nodeNames.length == 0){
      console.log("no nodes selected!")
      return;
      }

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: nodeNames, count: nodeNames.length, source: "markers and patients module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function identifyEntitiesInCurrentSelection()  // defunct, not quite yet ready to del
{  
   var names = [];
   var noi = cyGbm.filter('node:selected'); 
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }
  return(names);

} // identifyEntitiesInCurrentSelection
//--------------------------------------------------------------------------------------------
function loadNetwork()
{

    cyGbm = $("#cyGbmPathwaysDiv");
    cyGbm.cytoscape({
       boxSelectionEnabled: true,
       showOverlay: false,
       minZoom: 0.01,
       maxZoom: 8.0,
       layout: {
         name: "preset",
         fit: true
         },
     ready: function() {
        console.log("cyGbm ready");
        cyGbm = this;

        cyGbm.on('select', 'edge', function(evt){
           var edge = evt.cyTarget;
           console.log("selected edge");
           if(edgeAbstractsOn){
              var pmid = edge.data().pmid;
              var url = "http://www.ncbi.nlm.nih.gov/pubmed/?term=" + pmid;
              var replaceAnyExistingPopup = true;
              hub.openCenteredBrowserWindow(url, "pubmed abstract", 800, 600, replaceAnyExistingPopup)
              }
           });

        cyGbm.on('select', 'node', function(evt){
           var disable = identifyEntitiesInCurrentSelection().length == 0;
           sendSelectionsMenu.attr("disabled", disable);
           });
        cyGbm.on('unselect', 'node', function(evt){
           var disable = identifyEntitiesInCurrentSelection().length == 0;
           sendSelectionsMenu.attr("disabled", disable);
           });

        searchBox.keydown(doSearch);

        cyGbm.edges().unselectify();
        console.log("cyGbm.reset");
        cyGbm.reset();
        handleWindowResize();
        } // cy.ready
       })
    .cytoscapePanzoom({ });   // need to learn about options

} // loadNetwork
//----------------------------------------------------------------------------------------------------
function displayPathway(msg)
{
   console.log("--- Module.gbmPathways: displayPathway");
   if(msg.status == "success"){
      console.log("nchar(network): " + msg.payload.length);
      s = msg.payload;
      XXX = msg.payload;
      console.log("      1:40: " + s.substring(1, 40));
      var json = JSON.parse(msg.payload);
      cyGbm.remove(cyGbm.edges());
      cyGbm.remove(cyGbm.nodes());
      console.log(" after JSON.parse, json.length: " + json.length);
      console.log("  about to add json.elements");
      cyGbm.add(json.elements);
      console.log("  about to add  json.style");
      cyGbm.style(json.style);
      cyGbm.nodes().unselect();
        // map current node degree into a node attribute of that name
      cyGbm.nodes().map(function(node){node.data({degree: node.degree()})});

      var edgeTypes = hub.uniqueElementsOfArray(cyGbm.edges().map(function(edge){
                               return(edge.data("edgeType"))}
                               ));
      //updateEdgeSelectionWidget(edgeTypes);  // preserve only known edgeTypes
      cyGbm.resize();
      cyGbm.fit(50);
      console.log("concluding displayPathway in Module.gbmPathways");
      cyGbm.edges().show();
        // on load there are no selections.  make sure the menu is disabled.
      sendSelectionsMenu.prop({"disabled": true}); 
      hub.enableTab(thisModulesOutermostDiv);
      handleWindowResize();
//      postStatus("gbm pathway loaded");
      }
   else{
     console.log("displayPathway error: " + msg.payload);
     }

} // displayPathway
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
   outermostDiv.width(0.95 * $(window).width());
   outermostDiv.height(0.95 * $(window).width());

   controlsDiv.width(0.95 * $(window).width());
   controlsDiv.height(80);
  
   cyGbmDiv.width(0.95 * $(window).width());
   cyGbmDiv.height(0.8 * $(window).height());

   cyGbm.resize();
   cyGbm.fit(50);

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function zoomSelection()
{
   cyGbm.fit(cyGbm.$(':selected'), 50)

}
//----------------------------------------------------------------------------------------------------
function toggleEdgeSelection ()
{
  if(edgeAbstractsOn){
     edgeAbstractsOn = false;
     viewAbstractsButton.button("option", "label", "Enable Abstracts");
     }
   else{
     edgeAbstractsOn = true;
     viewAbstractsButton.button("option", "label", "Disable Abstracts");
     }

} // toggleEdgeSelection
//----------------------------------------------------------------------------------------------------
function transformMatrixToPatientOrientedNamedList(mtx) {

     // geneNames are repeated in each element; grab them from the first one
   var geneNames = Object.keys(mtx[0]);
     // the last element was originally (in R) the row name -- the tissue
     // gene1: expression, gene2: expession, ... rowname: 0445.T.1
   geneCount = geneNames.length - 1;
   geneNames = geneNames.slice(0,geneCount);
   var tissueNames = [];
   max = mtx.length;
   namedList={};

   for(var r=0; r < max; r++){
      row = mtx[r]
      tissueName = row["rowname"][0];
      tissueNames.push(tissueName);
      namedList[tissueName] = row;
      } // for r

   result = {genes: geneNames, tissues: tissueNames, values: namedList};
   return(result);

} // transformMatrixToPatientOrientedNamedList
//----------------------------------------------------------------------------------------------------
// policy: incoming ids will not always be only patientIDs, but may be geneIDs also
// a) if none of the incoming ids are recognized, their full list is displayed
//    in the body of an error dialog explaining the problem
// b) if there are any geneIDs present, we ignore all patientIDs, and select the geneIDs
// c) if there are only patientIDs, then they are used to load molecular data for
//    those patients, and to setup for running a gene/data movie across those patients
function handleIncomingIdentifiers(msg){

   console.log("=== entering handleIncomingIdentifiers for gbm");
   console.log("status: " + msg.status);

   var incomingIds = msg.payload.value;
   if(typeof(incomingIds) == "string")
      incomingIds = [incomingIds];

   var status = "gbm pathway received " + incomingIds.length + " identifiers";
   postStatus(status);
   console.log(status);
   console.log(JSON.stringify(incomingIds));

   var idsUpperCase = incomingIds.map(function(id){return(id.toUpperCase())});
   //var ourGenes = cyGbm.filter("node[nodeType='gene']").map(function(node){return(node.id())});
   var ourGenes = cyGbm.nodes().map(function(node){return(node.id())});
   var recognizedGenes = ourGenes.filter(function(gene){return(idsUpperCase.indexOf(gene) >= 0)});

   if(recognizedGenes.length > 0){
      hub.raiseTab("gbmPathwaysDiv");
      console.log(" incoming ids matched " + recognizedGenes.length + " gene names");
      console.log(JSON.stringify(recognizedGenes));
      selectNodes(recognizedGenes);
      }
   else{
     alert("None of the selected ids are recognized by the GBM Pathways tab.");
     }

     // todo: make this conditional, and post alert error message when there are no overlaps
     // todo: such that it appears on the sending page

    /**************
   for(var i=0; i < incomingIds.length; i++){
     if(ourGeneNames.indexOf(incomingIds[i]) >= 0)
        recognizedGeneNames.push(incomingIds[i]);
     } // for i

   if(recognizedGeneNames.length > 0){
      }
   else{
     alert("None of the selected nodes recogized by destination tab.");
     }
     // with no recognized genes, we may have recognized tissueIDs.
     // ask the server to check, providing a callback that will 
     // request loading the molecular data for those tissue ids
     // which are recognized
   //else{ 
   //   msg = {cmd:"getOverlappingIdentifiers",
   //          callback: "gbmPathwaysHandleOverlappingTissueIdentifiers",
   //          status:"request",
   //          payload: {idType:"entities", signature:"mRNA", ids:incomingIds}
   //          };
   //  msg.json = JSON.stringify(msg);
   // hub.send(msg.json);
   //  } // else: possibly some tissue (patient) ids 

   ********/

   } // handleIncomingIdentifiers
//----------------------------------------------------------------------------------------------------
function handleIdentifyOverlappingTissueIdentifiers(msg)
{ 
    console.log("=== Module.gbmPathways handleOverlappingTissueIdentifiers");
    payload = JSON.parse(msg.payload)
    recognizedIDs = payload.recognized;
    if(typeof(recognizedIDs) == "string")  // promote scalar to 1-element array
      recognizedIDs = [recognizedIDs];
    unrecognizedIDs = payload.unrecognized;
    if(typeof(unrecognizedIDs) == "string")  // promote scalar to 1-element array
      unrecognizedIDs = [unrecognizedIDs];

      // if any are recognized, ignore the others, request load of molecular data
      // allowing data movie to be run across these samples
    if(recognizedIDs.length > 0){
       request_mRNA_data(recognizedIDs, geneSymbols());   // entities: patient, tissue or sample ids
       request_cnv_data(recognizedIDs, geneSymbols());
       request_mutation_data(recognizedIDs, geneSymbols());
       }
    else if(unrecognizedIDs.length > 0) {
       errorMessage = "No overlap with pathway genes or tissue sample IDs:  <br><br>" +
                       unrecognizedIDs.join(", ");
       title = unrecognizedIDs.length + " unrecognized identifiers";
       $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
       } // else: only unrecognized identifiers

} // handleIdentifyOverlappingTissueIdentifiers
//----------------------------------------------------------------------------------------------------
function nodeIDs()
{
  nodes = cyGbm.filter("node:visible");
  result = [];
  for(var i=0; i < nodes.length; i++){
    id = nodes[i].data()['id'];
    result.push(id);
    } // for i
  return(result)

} // nodeIDs
//----------------------------------------------------------------------------------------------------
   function nodeNames() {

     nodes = cyGbm.nodes();
     //nodes = cyGbm.filter("node:visible");
     result = [];
     for(var i=0; i < nodes.length; i++){
       result.push(nodes[i].data().label)
       } // for i
     return(result)
     } // nodeNames

//----------------------------------------------------------------------------------------------------
function geneSymbols() {

  nodes = cyGbm.filter("node");
  result = [];
  for(var i=0; i < nodes.length; i++){
    sym = nodes[i].data().geneSymbol
    if(typeof(sym) != "undefined")
       result.push(sym)
    } // for i
  return(result)
  } // geneSymbols

//----------------------------------------------------------------------------------------------------
function selectNodes(nodeNames)
{
  if(typeof(nodeNames) == "string")   // trap scalar, but expect and support arrays
     nodeNames = [nodeNames];

  for(var i=0; i < nodeNames.length; i++){
     s = "cyGbm.filter('node[name=\"" + nodeNames[i] + "\"]').select()";
     //console.log("markers selectNodes: " + s);
     eval (s);
     } // for i

} // selectNodes
//----------------------------------------------------------------------------------------------------
   function changeMovieSpeed(delta) {

      if((currentMovieSpeed + delta) < 0)
         return;

      console.log("currentMovieSpeed: " + currentMovieSpeed);
      currentMovieSpeed += delta;
      console.log("currentMovieSpeed: " + currentMovieSpeed);
      movieSpeedReadout.text(Number(currentMovieSpeed/1000).toFixed(2));
      if(moviePlaying){
         clearInterval(movieIntervalID);
         movieIntervalID = setInterval(oneFrame, currentMovieSpeed);
         }
      } // changeMovieSpeed

   //----------------------------------------------------------------------------------------------------
   function togglePlayMovie() {


    allCurrentTissues = tissueMenu.children().map(function() {return $(this).val();}).get();
    currentTissueIndex = 0;

     oneFrame = function(){
        tissueIndex = currentTissueIndex  % allCurrentTissues.length;
        tissueName =  allCurrentTissues[tissueIndex]
        //console.log(" movie about to display frame " + tissueIndex + ", " + tissueName);
        currentTissueIndex = currentTissueIndex + 1;
        tissueMenu.val(tissueName);
        tissueSelectorChanged()
        } // oneFrame

     if(moviePlaying){
        moviePlaying = false;
        clearInterval(movieIntervalID);
        movieButton.text("Play Movie");
        }
     else{
        moviePlaying = true;
        movieButton.text("Stop Movie");
        movieIntervalID = setInterval(oneFrame, currentMovieSpeed);
        }
   

    } // togglePlayMovie
//----------------------------------------------------------------------------------------------------
function doSearch(e)
{
  var keyCode = e.keyCode || e.which;

  //console.log("Module.gbmPathway doSearch, keyCode: " + keyCode);

  if (keyCode == 13) {
     searchString = searchBox.val();
     //console.log("searchString: " + searchString);
     names = nodeNames()
     matches = []
     for(var i=0; i < names.length; i++){
        if(names[i].beginsWith(searchString)) {
           //console.log(searchString + " matched " + names[i]);
           selectNodes([names[i]]);
           } // if searchString matched beginning of node
        } // for i
     } // if 13 (return key)

} // doSearch
//----------------------------------------------------------------------------------------------------
function request_mRNA_data(entities, features) {

  msg = {cmd:"get_mRNA_data",
          callback: "handle_gbmPathways_mRNA_data",
          status:"request",
          payload:{entities: entities, features: features}
          };
   msg.json = JSON.stringify(msg);
   hub.send(msg.json);
   }

//----------------------------------------------------------------------------------------------------
function request_cnv_data(entities, features) {

  msg = {cmd:"get_cnv_data",
          callback: "handle_gbmPathways_cnv_data",
          status:"request",
          payload:{entities: entities, features: features}
          };
   msg.json = JSON.stringify(msg);
   hub.send(msg.json);
   }

//----------------------------------------------------------------------------------------------------
function request_mutation_data(entities, features) {

  msg = {cmd:"get_mutation_data",
          callback: "handle_gbmPathways_mutation_data",
          status:"request",
          payload:{entities: entities, features: features}
          };
   msg.json = JSON.stringify(msg);
   hub.send(msg.json);
   }

//----------------------------------------------------------------------------------------------------
function addTissueIDsToSelector (tissueIDs) {
  tissueMenu.empty();
  if(tissueIDs.length == 0) {
     alert("gbmPathways received empty tissueIDs list")
     return;
     }
  
  // every set of tissueIDs needs a neutral (no data) pseudo-tissue

  tissueIDs.unshift("neutral");

  for(var i=0; i < tissueIDs.length; i++){
     tissueName = tissueIDs[i]
     optionMarkup = "<option>" + tissueName + "</option>";
     tissueMenu.append(optionMarkup);
     } // for i

 } // addTissueIDsToSelector
//----------------------------------------------------------------------------------------------------
function handle_mRNA_data(msg) {

   console.log("handling mRNA data");
   hub.raiseTab("gbmPathwaysDiv");
   if(msg.status == "success"){
      var mtx = JSON.parse(msg.payload.mtx);
      expressionData = transformMatrixToPatientOrientedNamedList(mtx);
      console.log("handle_mRNA_data, success, rows: " + expressionData.length);
      addTissueIDsToSelector(expressionData.tissues);
      movieButton.prop("disabled", false);
      movieButton.css("color", movieButtonOriginalColor)
      selectLabel.css("color", "black");
      } // success
   else{
      expressionData = [];
      console.log("handle_mRNA_data, failure, rows: " + expressionData.length);
      } // failure
   } // handle_mRNA_data

//----------------------------------------------------------------------------------------------------
function handle_cnv_data(msg) {

   console.log("handling cnv data");
   if(msg.status == "success"){
     var mtx = JSON.parse(msg.payload.mtx);
     cnvData = transformMatrixToPatientOrientedNamedList(mtx);
     }
   else{
     cnvData = []
     }
   } // handle_mRNA_data

//----------------------------------------------------------------------------------------------------
function handle_mutation_data(msg) {

   console.log("handling mutation data");
   if(msg.status == "success"){
     var mtx = JSON.parse(msg.payload.mtx);
     mutationData = transformMatrixToPatientOrientedNamedList(mtx);
     }
   else{
     mutationData = [];
     }
   } // handle_mRNA_data

//----------------------------------------------------------------------------------------------------
function tissueSelectorChanged() {

   tissueID = tissueMenu.val()
   displayTissue(tissueID);

   } // tissueSelectorChanged

//----------------------------------------------------------------------------------------------------
function setInfoNodeLabel (newLabel)
{
   infoNodeID = cyGbm.filter('node[canonicalName="info.node"]').data("id")
   noa = {};
   noa[infoNodeID] = {label: newLabel};
   cyGbm.batchData(noa);
}
//----------------------------------------------------------------------------------------------------
function displayTissue(tissueID)
{
   setInfoNodeLabel(tissueID);

   var noa = {};

   if(tissueID == "neutral") {
      console.log(" will display neutral values of expression, copynumber, mutation");
      ids = [];
      allNodes = cyGbm.nodes();
      for(i=0; i < allNodes.length; i++){
         node = allNodes[i];
         id = node.data("id");
         if(Object.keys(node.data()).indexOf("geneSymbol") >= 0){
            geneSymbol = node.data("geneSymbol");
            ids.push(id);
            noa[id] = {score:0, label: geneSymbol, copyNumber:0}
            } // if node has geneSymbol attribute
         } // for i
      cyGbm.batchData(noa);
      return;
      } // neutral pseudo-tissue

   if(expressionData.tissues.indexOf(tissueID) < 0){
      alert(tissueId + " not found in current expressionData");
      return;
      }

   mRNA = expressionData.values
   genes = expressionData.genes;
   tissues = expressionData.tissues;

   noa = {};  // new node attributes to assign in the network

   for(var g=0; g < genes.length; g++){
      gene = genes[g];

      newScore = mRNA[tissueID][gene][0];
      filterString = '[geneSymbol="' + gene + '"]'
      nodeID = cyGbm.nodes(filterString)[0].data("id");
      noa[nodeID] = {score: newScore};
      } // for g

   cyGbm.batchData(noa);

   cnv = cnvData.values
   genes = cnvData.genes;
   tissues = cnvData.tissues;

   noa = {};  // new node attributes to assign in the network

   for(var g=0; g < genes.length; g++){
     gene = genes[g];
     newCopyNumber = cnv[tissueID][gene][0];
     filterString = '[geneSymbol="' + gene + '"]'
     nodeID = cyGbm.nodes(filterString)[0].data("id");
     noa[nodeID] = {copyNumber: newCopyNumber};
     } // for g

   cyGbm.batchData(noa);

   mut = mutationData.values

   noa = {};  // new node attributes to assign in the network


   for(var g=0; g < genes.length; g++){
     gene = genes[g];
     newMutation = mut [tissueID][gene][0];
        // identify the node (by id) whose geneSymbol attribute is gene
        // the label attribute changes, but geneSymbol remains
     filterString = 'node[geneSymbol="' + gene  + '"]';
     nodeID = cyGbm.filter(filterString).id();
        // set label and nodeType for every gene
     if(newMutation == null){
        newGeneLabel = gene;
        newNodeType = "gene";
        }
     else{
        newGeneLabel = gene + " (" + newMutation + ")";
        newNodeType = "mutation";
        }
     noa[nodeID] = {label: newGeneLabel, nodeType: newNodeType};
     } // for g, mutations
   cyGbm.batchData(noa);

} // displayTissue
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose only one
// as their current working dataset.
// this module uses the dataset name to request the g.gbmPathways.json network from the server
function datasetSpecified (msg)
{
   console.log("Module.gbm datasetSpecified");
   console.log(msg.payload);

   var manifestInfo = msg.payload;
   var variableNames = manifestInfo.rownames;

   var pathway = "gbmPathways.json.RData";
   if($.inArray(pathway, variableNames) >= 0){
      var newMsg = {cmd: "getPathway",  callback: "displayGbmPathway",
                    status: "request", payload: "g.gbmPathways.json"};
      hub.send(JSON.stringify(newMsg));
      } // if pathway available

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  console.log("posting new status to gbmPathway status div: " + msg);
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function SetModifiedDate()
{
   msg = {cmd:"getModuleModificationDate",
          callback: "DisplayGbmPathwaysModifiedDate",
          status:"request",
          payload:"gbmPathways"
          };
   msg.json = JSON.stringify(msg);
   hub.send(msg.json);

} // setModifiedData
//----------------------------------------------------------------------------------------------------
function DisplayGbmPathwaysModifiedDate(msg)
{
   document.getElementById("gbmPathwaysDateModified").innerHTML = msg.payload;
}
//----------------------------------------------------------------------------------------------------
return{
  init: function(){
     hub.addMessageHandler("DisplayGbmPathwaysModifiedDate", DisplayGbmPathwaysModifiedDate);
     hub.addMessageHandler("handle_gbmPathways_mRNA_data", handle_mRNA_data);
     hub.addMessageHandler("handle_gbmPathways_cnv_data",  handle_cnv_data);
     hub.addMessageHandler("handle_gbmPathways_mutation_data",  handle_mutation_data);
     //hub.addMessageHandler("gbmPathwaysHandlePatientIDs", handlePatientIDs);
     hub.addMessageHandler("gbmPathwaysHandleOverlappingTissueIdentifiers",
                            handleIdentifyOverlappingTissueIdentifiers)

     hub.addMessageHandler("sendSelectionTo_gbmPathways", handleIncomingIdentifiers);
     hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
     hub.addMessageHandler("datasetSpecified", datasetSpecified);
     hub.addMessageHandler("displayGbmPathway", displayPathway);
     hub.addOnDocumentReadyFunction(initializeUI);
     } // init
  }; 

//----------------------------------------------------------------------------------------------------
}); // gbmPathwaysModule
//----------------------------------------------------------------------------------------------------
gbmPathway = gbmPathwaysModule()
gbmPathway.init();

//------------------------------------------------------------------------------------------------------------------------
    // observers used in QUnit testing
  var datasetsStatusObserver = null;
  var gbmPathwaysStatusObserver = null;


var GbmPathwayTestModule = (function () {

//------------------------------------------------------------------------------------------------------------------------
function initializeUI()
{
   console.log("Test.gbmPathway intializeUI")

} // initializeUI
//------------------------------------------------------------------------------------------------------------------------
runTests = function(show)
{
   if(show) showTests();

   testLoadDataSetThenLoadPathways();

} // runTests
//------------------------------------------------------------------------------------------------------------------------
showTests = function()
{
   $("#qunit").css({"display": "block"});

} // show
//------------------------------------------------------------------------------------------------------------------------
hideTests = function()
{
   $("#qunit").css({"display": "none"});

} // hide
//------------------------------------------------------------------------------------------------------------------------
function testLoadDataSetThenLoadPathways()
{
   var testTitle = "testLoadDataSet";
   console.log(testTitle);
   hub.raiseTab("gbmPathwaysDiv")
     
     // we could use the datasets tab menu to select the dataset, then click the button.
     // easier and quite adequate for our purposes is to simply send out the message which
     // these ui actions create

   var msg = {cmd: "specifyCurrentDataset", callback: "datasetSpecified", status: "request", payload: "DEMOdz"};
      // when our module receives the 'datasetSpecified' msg, which is accompanied by the dataset's manifest
      // it looks for the gbmPathways data object in the manifest, requests it be sent if it is there
      // when that data is loaded and ready, the module updates the status div; we watch for that, then
      // check that a reasonable number of nodes are contained in the loaded graph.

   var target = document.querySelector("#gbmPathwaysStatusDiv");

   if(gbmPathwaysStatusObserver == null){
      gbmPathwaysStatusObserver = new MutationObserver(function(mutations) {
      mutation = mutations[0];
      gbmPathwaysStatusObserver.disconnect();
      gbmPathwaysStatusObserver = null;
      var id = mutation.target.id;
      var msg = $("#gbmPathwaysStatusDiv").text();
      QUnit.test("gbmPathways loaded", function(assert) {
         var nodeCount = cyGbm.nodes().length;
         var edgeCount = cyGbm.edges().length;
         console.log("gbmPathway loaded, with " + nodeCount + " nodes and " + edgeCount + " edges.");
         assert.ok(nodeCount > 150);
         assert.ok(edgeCount > 200);
         testMakeSelections();
         })
      }); // new MutationObserver
      }

   var config = {attributes: true, childList: true, characterData: true};
   gbmPathwaysStatusObserver.observe(target, config);

   hub.send(JSON.stringify(msg));

}; // testLoadDataSetThenLoadPathways
//------------------------------------------------------------------------------------------------------------------------
function testMakeSelections()
{
   var selectedNodes = cyGbm.filter("node:selected").map(function(node){ return node.id();});
   console.log("--- testMakeSelections, selected node count: " + selectedNodes.length);
   console.log(JSON.stringify(selectedNodes));
   console.log("   menu disabled? " + $("#gbmPathwaysSendSelectionMenu").prop("disabled"));

   QUnit.test("gbmPathways selections", function(assert){
     assert.equal(cyGbm.filter("node:selected").length, 0);
     assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), true);
     cyGbm.$("#GAB1").select()  // effectively instantaneous results?
     assert.equal(cyGbm.filter("node:selected").length, 1);
     assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), false);
     });

   QUnit.test("gbmPathways direct cyjs search", function(assert){
       // use setTimeout to ensure a brief delay between 
       // calls to cyjs and results appearing on the cyjs canvas
     var done1 = assert.async();
     var done2 = assert.async();
     var done3 = assert.async();
     var done4 = assert.async();
     var done5 = assert.async();
     assert.expect(5);
     cyGbm.filter("node:selected").unselect();
     setTimeout(function(){
        var selectedNodeCount = cyGbm.filter("node:selected").length;
        console.log(" testing  unselect: " + selectedNodeCount);
        assert.equal(selectedNodeCount, 0); done1();
        var menuDisabled = $("#gbmPathwaysSendSelectionMenu").prop("disabled")
        console.log(" testing  unselect, menu disabled?: " + menuDisabled);
        assert.equal(menuDisabled, true); done2();
          // with this test complete, setup the next one
        cyGbm.$("#GAB1").select();  // effectively instantaneous results?
        }, 1000);
     setTimeout(function(){
        var selectedNodes = cyGbm.filter("node:selected").map(function(node){ return node.id();});
        assert.equal(selectedNodes.length, 1); done3();
        console.log("selected node: " + selectedNodes[0]);
        assert.equal(selectedNodes[0], "GAB1"); done4();
        assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), false); done5();
        testSearchBox();
        }, 1000);
      }); // gbmPathways direct cyjs search

} // testMakeSelections
//------------------------------------------------------------------------------------------------------------------------
function testSearchBox()
{
   cyGbm.filter("node:selected").unselect();

   QUnit.test("gbmPathways searchBox", function(assert){
     assert.equal(cyGbm.filter("node:selected").length, 0);
     assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), true);
     var box = $("#gbmPathwaysSearchBox");
     box.val("pik");  // user lower case to test case insensitivity
     box.trigger(jQuery.Event("keydown", {which: 13}))
     assert.equal(cyGbm.filter("node:selected").length, 9);
     assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), false);
     testZoomSelected();
     });


} // testSearchBox
//------------------------------------------------------------------------------------------------------------------------
function testZoomSelected()
{
   console.log("--- testZoomSelected");

   QUnit.test("gbmPathways zoom selected", function(assert){
     assert.ok(cyGbm.filter("node:selected").length > 0);
     var zoomBefore = cyGbm.viewport().zoom();
     $("#gbmZoomSelectedButton").click();
     var zoomAfter = cyGbm.viewport().zoom();
     console.log("zoomBefore: " + zoomBefore);
     console.log("zoomAfter: " + zoomAfter);
     assert.ok(zoomAfter > zoomBefore);
     console.log("pause zoomed in before calling testHandleIncomingSelections");
     setTimeout(function(){testHandleIncomingSelections()}, 1000);
     });

} // testZoomSelected
//------------------------------------------------------------------------------------------------------------------------
function testHandleIncomingSelections()
{
     // start out with network zoomed out, and no selected nodes
   console.log("--- testHandleIncomingSelections")

   cyGbm.filter("node:selected").unselect();
   cyGbm.fit(50);
 
   var cmd = "sendSelectionTo_gbmPathways";
   var payload = {value: ["GRB2", "PDGFRB"]};  // two nodes at top center of network
   var msg = {cmd: cmd, callback: "", status: "request", payload: payload};

   var target = document.querySelector("#gbmPathwaysStatusDiv");

   if(gbmPathwaysStatusObserver == null){
      gbmPathwaysStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        gbmPathwaysStatusObserver.disconnect();
        gbmPathwaysStatusObserver = null;
        var id = mutation.target.id;
        var msg = $("#gbmPathwaysStatusDiv").text();
        QUnit.test("gbmPathways incoming identifiers received", function(assert) {
           assert.equal(cyGbm.filter("node:selected").length, 2)        
           })
        setTimeout(testSendSelectionsViaGUI, 2000);
        }); // new MutationObserver
      } // if null observer

   var config = {attributes: true, childList: true, characterData: true};
   gbmPathwaysStatusObserver.observe(target, config);
   hub.send(JSON.stringify(msg));
   
} // testHandleIncomingSelections
//------------------------------------------------------------------------------------------------------------------------
function testSendSelectionsViaGUI()
{
   console.log("--- testSendSelectionsViaGUI");

     // start out with network zoomed out, and no selected nodes
   cyGbm.filter("node:selected").unselect();
   cyGbm.fit(50);
 
   cyGbm.$("#IRS1").select();
   cyGbm.$("#GAB1").select();

   setTimeout(function(){
      $("#gbmPathwaysSendSelectionMenu").val("blankTab");
      $("#gbmPathwaysSendSelectionMenu").trigger("change");
      }, 200);

   setTimeout(function(){
      QUnit.test("gbmPathways send selection via GUI", function(assert) {
        assert.ok($("#blankTabOutputDiv").text().indexOf("IRS1") >= 0);
        assert.ok($("#blankTabOutputDiv").text().indexOf("GAB1") >= 0);
        //testEdgeSelectionAndAbstractDisplay();
        })}, 1000)
    
   setTimeout(function(){hub.raiseTab("gbmPathwaysDiv")}, 2000);

   console.log("--- testSendAndReceiveSelectionsViaGUI, sent selections?");

} // testSendSelectionsViaGUI
//------------------------------------------------------------------------------------------------------------------------
function testEdgeSelectionAndAbstractDisplay()
{
  console.log("--- testSendSelectionsViaGUI");
  $("#gbmViewAbstractsButton").trigger("click");
  cyGbm.edges()[0].select();
    // edge is not visually selected
    // don't know how to detect for an actually opened window...


} // testEdgeSelectionAndAbstractDisplay
//------------------------------------------------------------------------------------------------------------------------

return{
   init: initializeUI,
   run: runTests,
   show: showTests,
   hide: hideTests
   }; // module return value

//------------------------------------------------------------------------------------------------------------------------
}); // GbmPathwayTestModule

gbt = GbmPathwayTestModule();
//gbt.run(true);

"user strict";
//----------------------------------------------------------------------------------------------------
var SurvivalModule = (function () {

  var currentDataSet;
  var statusDiv;

  var survivalCurveDiv;
  var survivalImageArea;

  var thisModulesName = "survival";
  var thisModulesOutermostDiv = "survivalDiv";
  var selectionDestinationsOfferedHere = ["survival"];

//----------------------------------------------------------------------------------------------------
function initializeUI()
{
   survivalCurveDiv = $("#survivalCurveDiv");
   survivalImageArea = $("#survivalImageArea");
   statusDiv = $("#survivalStatusDiv");
   $("#survivalCurveDiv").css("display", "none");
   $(window).resize(handleWindowResize);
   handleWindowResize();
   hub.disableTab(thisModulesOutermostDiv);

}  // initializeUI
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
   //console.log("survivalCurveDiv window resize: " + $(window).width() + ", " + $(window).height());

   var newHeight = $(window).height() * 0.8;
   var newWidth = $(window).width() * 0.95;

   survivalCurveDiv.width(newWidth);
   survivalCurveDiv.height(newHeight);
   survivalImageArea.width(newWidth);
   survivalImageArea.height(newHeight);
  
} // handleWindowResize
//--------------------------------------------------------------------------------------------------     
 function handlePatientIDs(msg) {

    if(msg.status == "success"){
             var patientIDs = msg.payload;            
    		  analyzeSelectedTissues(patientIDs, "");
    } else {
             console.log("survival handlePatientIDs about to call alert: " + msg);
             alert(msg.payload);
    }

} //handlePatientIDs
//--------------------------------------------------------------------------------------------------     
function handleIncomingIDs(msg) 
{    
    var ids = msg.payload.value;
    var count = msg.payload.count;
    var source = msg.payload.source;  

    if(typeof(ids) == "string")
      ids = [ids];

    console.log("Survival module, " + msg.cmd + " count: " + count);
     msg = {cmd: "canonicalizePatientIDsInDataset", callback: "survivalHandlePatientIDs", status: "request", 
                  payload: ids};
           hub.send(JSON.stringify(msg));
} // handlePatientIDs

//----------------------------------------------------------------------------------------------------
function analyzeSelectedTissues(patientIDs, title)
{
   console.log("Survival module, hub.send 'calculateSurvivalCurves' for %d patientIDs",
               patientIDs.length);
   $("#survivalInstructions").css("display", "none");
   $("#survivalCurveDiv").css("display", "block");
   var payload = {sampleIDs: patientIDs, title: title};
   var msg = {cmd:"calculateSurvivalCurves", callback: "displaySurvivalCurves", status: "request", 
              payload: payload};

   hub.send(JSON.stringify(msg));

} // analyzeSelectedTissues
//----------------------------------------------------------------------------------------------------
function getSurvivalPlot(msg) 
{
   console.log("create Survival Plot for: ", msg);
   var payload = JSON.parse(msg.payload);
   var storage = [];

   for(var i=0;i<Object.keys(payload).length;i++) {
      var patient = Object.keys(payload)[i];
      storage.push({ID: patient, value: payload[patient]});
      }

} // getSurvivalPlot
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function displaySurvivalCurves(msg)
{
   //console.log("about to add survival curve image to survivalCurve div");
   var encodedImage = msg.payload;
   document.getElementById("survivalImageArea").src = encodedImage;
   hub.raiseTab(thisModulesOutermostDiv);
   postStatus("image loaded");
   // survivalImageArea.src = encodedImage;

} // displaySurvivalCurves
//----------------------------------------------------------------------------------------------------
function specifyCurrentDataset(datasetName)
{
   console.log("Module.survival, specifyCurrentDataset: " + datasetName);

   var msg = {cmd: "specifyCurrentDataset",  callback: "survivalDatasetSpecified", 
              status: "request", payload: datasetName};

   hub.send(JSON.stringify(msg));

} // specifyCurrentDataset
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   console.log("--- Module.survival, datasetSpecified: " + msg.payload);
   hub.enableTab(thisModulesOutermostDiv);
   document.getElementById("survivalImageArea").src = "";

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function demoPatientSet()
{
   var longSurvivors = ["TCGA.06.6693", "TCGA.12.1088", "TCGA.02.0113", "TCGA.02.0114", "TCGA.08.0344"];

   var firstFortyGbmPatients = ["TCGA.02.0001", "TCGA.02.0003", "TCGA.02.0006", "TCGA.02.0007",
                                "TCGA.02.0009", "TCGA.02.0010", "TCGA.02.0011", "TCGA.02.0014",
                                "TCGA.02.0021", "TCGA.02.0024", "TCGA.02.0027", "TCGA.02.0028",
                                "TCGA.02.0033", "TCGA.02.0034", "TCGA.02.0037", "TCGA.02.0038",
                                "TCGA.02.0043", "TCGA.02.0046", "TCGA.02.0047", "TCGA.02.0052",
                                "TCGA.02.0054", "TCGA.02.0055", "TCGA.02.0057", "TCGA.02.0058",
                                "TCGA.02.0060", "TCGA.06.0875", "TCGA.06.0876", "TCGA.06.0877",
                                "TCGA.06.0878", "TCGA.06.0879", "TCGA.06.0881", "TCGA.06.0882",
                                "TCGA.12.0670", "TCGA.12.0818", "TCGA.12.0819", "TCGA.12.0820",
                                "TCGA.12.0821", "TCGA.12.0822", "TCGA.12.0826", "TCGA.12.0827"];

   firstFortyGbmPatients.push(longSurvivors);
   return (firstFortyGbmPatients);

} // demoPatientSet
//----------------------------------------------------------------------------------------------------
// the standalone-test
function sat(maxReps)
{
   if(typeof(maxReps) == "undefined")
      maxReps = 3;

     // might need to code defensively here, waiting for this request to return before proceeding
   specifyCurrentDataset("TCGAgbm");

   var pool = demoPatientSet();

   var maxIndex = pool.length - 1;
   
   var worker = function(randomIDs){
      console.log("survival on %d randomIDs", randomIDs.length);
      analyzeSelectedTissues(randomIDs, "");
      };

   for(var reps=0; reps < maxReps; reps++){
     var randomIDs = [];
     var count = hub.getRandomInt(4, maxIndex+1);   // get between 4 and ~40 patient ids
     for(var i=0; i < count; i++){
       randomIDs.push(pool[hub.getRandomInt(0, maxIndex)]);
       }
    analyzeSelectedTissues(randomIDs, "rep " + reps);
    }  // for reps

} // sat
//----------------------------------------------------------------------------------------------------
return{
   init: function(){
      hub.addOnDocumentReadyFunction(initializeUI);
      hub.registerSelectionDestination(selectionDestinationsOfferedHere, thisModulesOutermostDiv);
	    hub.addMessageHandler("datasetSpecified", datasetSpecified);
      hub.addMessageHandler("survivalDatasetSpecified", datasetSpecified);
      hub.addMessageHandler("displaySurvivalCurves", displaySurvivalCurves);
      hub.addMessageHandler("sendSelectionTo_survival", handleIncomingIDs);
      hub.addMessageHandler("survivalHandlePatientIDs", handlePatientIDs);
      
      },
   sat: sat   // standalone test
   };

}); // SurvivalModule
//----------------------------------------------------------------------------------------------------
var survival = SurvivalModule();
survival.init();

//----------------------------------------------------------------------------------------------------


var PCAModule = (function () {

  var currentPatientIDs = null;
  var pcaScores;
  var pcaSelectedRegion;    // from brushing
    // by default, all patients (aka 'samples') in the current dataset are used for
    // all pca analyses.
    // but if a group of patientIDs arrived here as an incoming selection (via a 'handlePatientIDs' 
    // message) then that list is used until it is
    //   - replaced by another incoming set of ids
    //   - the "use all patientIDs in dataset" button is clicked


  var pcaDisplay;
  var d3pcaDisplay;
  var d3PlotBrush;
  var svg;
  var patientClassification;
  var firstTime = true;
  var pcaTextDisplay, pcaScreeDiv, pcaScoresDiv;

  var testResultsOutputDiv;

  var patientMenu;



  var pcaSendSelectionMenu;

  var thisModulesName = "PCA";
  var thisModulesOutermostDiv = "pcaDiv";
  var tempTest;
  var clearSelectionButton;
  var calculatePcaButton;
  var useAllSamplesInCurrentDatasetButton;
  var geneSetMenu;
  var currentIdentifiers = [];
  var infoMenu;

  var sendSelectionsMenuTitle = "Send selection...";
  var selectionDestinationsOfferedHere = ["PCA", "PCA (highlight)"];

//----------------------------------------------------------------------------------------------------
function initializeUI ()
{
  pcaDisplay = $("#pcaDisplay");
  d3pcaDisplay = d3.select("#pcaDisplay");
  pcaHandleWindowResize();
  testResultsOutputDiv = $("#pcaTestingOutputDiv");

  $(window).resize(pcaHandleWindowResize);

  clearSelectionButton = $("#pcaClearSelectionButton");
  clearSelectionButton.button();
  clearSelectionButton.click(clearSelection);

  calculatePcaButton = $("#pcaCalculateButton");
  calculatePcaButton.button();
  $("#pcaDisplay").css("display", "none");
  calculatePcaButton.click(calculate);
  useAllSamplesInCurrentDatasetButton = $("#pcaUseAllSamplesButton");
  useAllSamplesInCurrentDatasetButton.button();
  useAllSamplesInCurrentDatasetButton.click(useAllSamplesInCurrentDataset);
  hub.disableButton(useAllSamplesInCurrentDatasetButton);

  geneSetMenu = $("#pcaGeneSetSelector");
  geneSetMenu.change(function(){
     console.log("gene set is now " + geneSetMenu.val());
     //msg = {payload: {ids:currentIdentifiers}, status: "success"}
     //handlePatientIDs(msg)
     });  // ASSUMES success and requires use of GLOBAL variable storing identifiers WITHOUT passing through WS

  pcaTextDisplay = $("#pcaTextDisplayDiv");

  pcaSendSelectionMenu = hub.configureSendSelectionMenu("#pcaSendSelectionsMenu", 
                                                        selectionDestinationsOfferedHere, sendSelections,
                                                        sendSelectionsMenuTitle);
/// BUG FIX NECESSARY:		
//  $("#pcaSendSelectionsMenu").css("display", "none")                                                     
///
  hub.disableTab(thisModulesOutermostDiv)
 
}; // initializeUI
//----------------------------------------------------------------------------------------------------
function showLegend(){

  var text = $("#PCALegend").html()
  var title = "PCA Legend";
  $("<div>").html(text).dialog({title: title, width:600, height:600});

} // showHelp
//----------------------------------------------------------------------------------------------------
function getPatientClassification ()
{
   payload = "";
   msg = {cmd: "getPatientClassification", callback: "handlePatientClassification", 
          status: "request", payload: payload};
   hub.send(JSON.stringify(msg));

} // getPatientClassification
//----------------------------------------------------------------------------------------------------
function handlePatientClassification (msg)
{
   if(msg.status == "success"){
      patientClassification = msg.payload;
      console.log("got classification, length " + patientClassification.length);
      }
   else{
     alert("error!" + msg.payload)
     }

   //drawLegend()

} // handlePatientClassification
//----------------------------------------------------------------------------------------------------
function requestGeneSetNames()
{
   console.log("=== requestGeneSetNames");

   callback = "pcaHandleGeneSetNames"

   msg = {cmd:"getGeneSetNames",
          callback: callback,
          status:"request",
          payload:""}

   hub.send(JSON.stringify(msg));

} // requestGeneSetNames
//----------------------------------------------------------------------------------------------------
function handleGeneSetNames(msg)
{
   console.log("=== handleGeneSetNames");

   newNames = msg.payload;
   addGeneSetNamesToMenu(newNames);

} // handleGeneSetNames
//----------------------------------------------------------------------------------------------------
function addGeneSetNamesToMenu (geneSetNames)
{
   console.log("Module.pca:addGetSetNamesToMenu");

   geneSetMenu.empty();

   if(geneSetNames.length == 0) {
     postStatus("addGeneSetNamesToMenu: geneSetNames.length == 0");
     return;
     }
    
   if(typeof geneSetNames == "string") 
   	 geneSetNames = [geneSetNames] 
 
      
   for(var i=0; i < geneSetNames.length; i++){
     optionMarkup = "<option>" + geneSetNames[i] + "</option>";
     geneSetMenu.append(optionMarkup);
     } // for i

  postStatus("addGeneSetNamesToMenu: complete");
  hub.enableTab(thisModulesOutermostDiv)



} // addGeneSetNamesToMenu
//----------------------------------------------------------------------------------------------------
function useAllSamplesInCurrentDataset()
{
  currentPatientIDs = null;
  hub.disableButton(useAllSamplesInCurrentDatasetButton);

}  // useAllSamplesInCurrentDataset
//----------------------------------------------------------------------------------------------------
function changePCAids(msg)
{
   patientIDs = []
   selections = msg.payload;
   d3.values(selections).forEach(function(d){ d.patientIDs.forEach(function(id){patientIDs.push(id)})})
   sendSelectionToModule("PCA", patientIDs)

} // changePCAids
//----------------------------------------------------------------------------------------------------
function drawLegend ()
{
  if(typeof(patientClassification) == "undefined")
     return;

  for(var i=0; i<patientClassification.length; i++){
    if(patientClassification[i].gbmDzSubType[0] == null | patientClassification[i].gbmDzSubType[0] == ""){
      patientClassification[i].gbmDzSubType[0]= "undefined";
      } // if
    } // for i

  var classifications = d3.nest()
                          .key(function(d) { return d.gbmDzSubType[0]; })
                          .map(patientClassification, d3.map);

  var LegendLabels = d3.values(classifications.keys())
 
  var Legendsvg = d3.select("#pcaLegend").append("svg")
                      .attr("id", "pcaLegendSVG")
                      .attr("width", $("#pcaDisplay").width())
                      .attr("height", 50);
  
   var TextOffset =  [0, 87, 87, 87, 87, 87, 87];
   var TextOffSet = d3.scale.ordinal()
                      .range(TextOffset)
                      .domain(classifications.keys());
        
   var legend = Legendsvg.append("g")
                         .attr("class", "legend")
                         .attr("transform", "translate(" + 10 + "," + 10 + ")")  
                         .selectAll(".legend")
                         .data(LegendLabels)
                         .enter().append("g")
                         .attr("transform", function(d, i) { 
                             return "translate(" + i*TextOffSet(d) + ",0)" 
                             });

    var text = legend.append("text")
                      .attr("y", 10)
                      .attr("x", 0)
                      .style("font-size", 12)
                      .text(function(d) { return d})
                      .attr("transform", function(d, i) { 
                          return "translate(" + 15 + ",0)";
                           });

    legend.append("circle")
          .attr("cx", 0)
          .attr("cy", 5)
          .attr("r", function(d) { return 6;})
          .style("fill", function(d)   { if(d=="undefined") return "white"; return classifications.get(d)[0].color[0]})
          .style("stroke", function(d) { if(d=="undefined") return "black"; return classifications.get(d)[0].color[0]})
 
} // drawLegend
//----------------------------------------------------------------------------------------------------
function pcaHandleWindowResize () 
{
  pcaDisplay.width($(window).width() * 0.95);
  pcaDisplay.height($(window).height() * 0.80);

  if(!firstTime){
    d3PcaScatterPlot(pcaScores);
    }

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function pointsInBrushedRegion()
{
  x1=pcaSelectedRegion[0][0];
  y1=pcaSelectedRegion[0][1];
  x2=pcaSelectedRegion[1][0];
  y2=pcaSelectedRegion[1][1];

  var selectedIDs = [];

  for(var i=0; i < pcaScores.length; i++){
    px = pcaScores[i][0];
    py = pcaScores[i][1];
    if(px >= x1 & px <= x2 & py >= y1 & py <= y2){
      console.log(" selected: " + currentIdentifiers[i]);
      selectedIDs.push(currentIdentifiers[i]);
      }
    } // for i

  return(selectedIDs);

} // pointsInBrushedRegion
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
  var destination = pcaSendSelectionMenu.val();

  var selectedIDs = pointsInBrushedRegion()
       
   if(selectedIDs.length > 0){
      var cmd = "sendSelectionTo_" + destination;
      payload = {value: selectedIDs, count: selectedIDs.length, source: "PCA module"};
      var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};
      pcaSendSelectionMenu.val(sendSelectionsMenuTitle);
      hub.send(JSON.stringify(newMsg));
      }
   else{
     alert("No selections to send...");
     }

} // sendSelections
//----------------------------------------------------------------------------------------------------
function pcaPlot (msg)
{
   if(msg.status == "success"){
      pcaScores = msg.payload.scores;
      currentIdentifiers = msg.payload.ids
     
      d3PcaScatterPlot(pcaScores);

      var pcaData = msg.payload.importance
      var PC1var = 100 * msg.payload["importance.PC1"];
      var PC2var = 100 * msg.payload["importance.PC2"];
      var pcaText = $("#pcaTextDisplayDiv").html("")
      pcaText.append("Proportion of Variance: ")
      pcaText.append("PC1: "+PC1var.toFixed(2) + "%, PC2: "+PC2var.toFixed(2)+"%")
        
      //if(!firstTime){  // first call comes at startup.  do not want to raise tab then.
      hub.raiseTab(thisModulesOutermostDiv);
      postStatus("pcaPlot: success");
      //  }
      }// if success
    else{
      errorMessage = msg.payload;
      $("<div/>").html(errorMessage).dialog({title: "pcaPlot error", width:600, height:300});
      postStatus("pcaPlot: error");
      }
     firstTime = false;
     };

//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  $("#pcaStatusDiv").text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function highlightPatientIDs(msg)
{
   hub.raiseTab(thisModulesOutermostDiv);

   var candidates = msg.payload.value;
   console.log("=== Module.pca, highlightPatientIDs, candidates:");
   console.log(JSON.stringify(candidates));
   console.log("=== Module.pca, highlightPatientIDs, currentIdentifiers:");
   console.log(JSON.stringify(currentIdentifiers));

     // with currentIdentifiers (local shorter sample IDs) first, they
     // are returned:
     //   hub.intersectionOfArrays(currentIdentifiers, candidates)  ->    
     //      ["TCGA.02.0114", "TCGA.12.1088"]
     // rather than
     //    hub.intersectionOfArrays(candidates, currentIdentifiers) ->  
     //      ["TCGA.02.0114.01", "TCGA.12.1088.01"]

   var intersection = hub.intersectionOfArrays(candidates, currentIdentifiers);
   // debugger;
   console.log("=== Module.pca, highlightPatientIDs, intersection:");
   console.log(JSON.stringify(intersection));

   if(intersection.length == 0){
     count = candidates.length;
     errorMessage = "None of the incoming ids were recognized: ";
     for(var i=0; i < count; i++){
       errorMessage += candidates[i] + " ";
       }
     title = "Unrecognized Identifiers";
     $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
     } // if intersection
   else
     selectPoints(intersection, true);

} // highlightPatientIDs
//----------------------------------------------------------------------------------------------------
function selectPoints(ids, clearIDs)
{
   console.log("=== module.pca: selectPoints");
   console.log("    incoming ids count: " + ids.length)
   //console.log(ids);

   d3.selectAll("circle")
     .filter(function(d, i){
        //console.log("examining currentIdentifier " + i + ": " + currentIdentifiers[i]);
        if(typeof(d) == "undefined")
           return(false);
        match = ids.indexOf(currentIdentifiers[i]);
        //console.log("match: " + match);
        return (match >= 0);
        }) // filter
     .classed("highlighted", true)
     .transition()
     .attr("r", 7)
     .duration(500);

} // selectPoints
//----------------------------------------------------------------------------------------------------
function clearSelection()
{
   d3.selectAll("circle")
     .classed("highlighted", false)
     .attr("r", 3);

  d3PlotBrush.clear();
  svg.selectAll('.brush').call(d3PlotBrush);
  pcaHandleWindowResize();

} // clearSelection
//----------------------------------------------------------------------------------------------------
function calculate()
{
   var currentGeneSet = geneSetMenu.val();
   var payload = {genes: currentGeneSet};

   if(currentPatientIDs !== null)
       payload["samples"] = currentPatientIDs;

   msg = {cmd: "calculatePCA", callback: "pcaPlot", status: "request", payload: payload};
   hub.send(JSON.stringify(msg));
   $("#pcaInstructions").css("display", "none");
   $("#pcaDisplay").css("display", "block");
} // calculate
//----------------------------------------------------------------------------------------------------
function handlePatientIDs(msg)
{
   console.log("Module.pca: handlePatientIDs");

   if(msg.status !== "error"){   // sometimes "success" from a prior call, sometimes "request"
     var currentGeneSet = geneSetMenu.val();
     var selectedPatientIdentifiers = msg.payload.value;
     currentPatientIDs = msg.payload.value;
     var payload = {samples: currentPatientIDs, genes: currentGeneSet};
     msg = {cmd: "calculatePCA", callback: "pcaPlot", status: "request", payload: payload};
     hub.enableButton(useAllSamplesInCurrentDatasetButton);
     hub.send(JSON.stringify(msg));
     }
   else{
     alert("Module.pca handlePatientIDs error: " + JSON.stringify(msg));
     }

} // handlePatientIDs
//----------------------------------------------------------------------------------------------------
function d3PlotBrushReader ()
{
     //console.log("plotBrushReader 1037a 22jul2014");
  pcaSelectedRegion = d3PlotBrush.extent();
  console.log("region: " + pcaSelectedRegion);

  x0 = pcaSelectedRegion[0][0];
  x1 = pcaSelectedRegion[1][0];

  width = Math.abs(x0-x1);

  console.log("width: " + width);
  if(width > 0.001 &   pointsInBrushedRegion().length > 0){
    console.log("enabling pcaSendSelectionMenu")
    pcaSendSelectionMenu.prop("disabled",false);
    }
  else{
    console.log("disabling pcaSendSelectionMenu")
    pcaSendSelectionMenu.prop("disabled",true);
    }

} // d3PlotBrushReader
//----------------------------------------------------------------------------------------------------
function chooseColor(d)
{
  /********
  var id = d.id;
  for(var i=0; i<patientClassification.length; i++){
    var patientID = patientClassification[i]._row;
      // "TCGA.02.0047.01".indexOf("TCGA.02.0047") -> 0
      // using this strategy for partial match allows patient/tumor/sample multiplicity to be mapped
      // to patient classification
    if(id.indexOf(patientID) == 0){
       result = patientClassification[i].color;
       return(result)
       } // if match
    } // for i
 
   *********/
   return("black");

} // chooseColor
//----------------------------------------------------------------------------------------------------
function d3PcaScatterPlot(dataset)
{
   //pcaSendSelectionMenu.prop("disabled",true);
   var padding = 50;
   var width = $("#pcaDisplay").width();
   var height = $("#pcaDisplay").height();

   var xMax = d3.max(dataset, function(d) { return +d[0];} );
   var xMin = d3.min(dataset, function(d) { return +d[0];} );
   var yMax = d3.max(dataset, function(d) { return +d[1];} );
   var yMin = d3.min(dataset, function(d) { return +d[1];} );
 
       // todo:  after finding min and max, determine largest of each axis in abs value
       // todo:  then find next larger even number, use that throughout
     
   xMax = xMax * 1.1
   xMin = xMin * 1.1
   yMax = yMax * 1.1
   yMin = yMin * 1.1

     //console.log("xMax: " + xMax);   console.log("xMin: " + xMin);
     //console.log("yMax: " + yMax);   console.log("yMin: " + yMin);

   d3pcaDisplay.select("#pcaSVG").remove();  // so that append("svg") is not cumulative
 
   var xScale = d3.scale.linear()
                  .domain([xMin,xMax])
                  .range([padding, width - padding]);

   var yScale = d3.scale.linear()
                  .domain([yMin, yMax])
                  .range([height - padding, padding]); // note inversion 

   var xTranslationForYAxis = xScale(0);
   var yTranslationForXAxis = yScale(0);

   var xAxis = d3.svg.axis()
                 .scale(xScale)
                 .orient("top")
                 .ticks(5);

   var yAxis = d3.svg.axis()
                 .scale(yScale)
                 .orient("left")
                 .ticks(5);

   var tooltip = d3pcaDisplay.append("div")
                             .attr("data-toggle", "tooltip")
                             .style("position", "absolute")
                             .style("z-index", "10")
                             .style("visibility", "hidden")
                             .text("a simple tooltip");

   d3PlotBrush = d3.svg.brush()
                   .x(xScale)
                   .y(yScale)
                   .on("brushend", d3PlotBrushReader);

   svg = d3pcaDisplay.append("svg")
                         .attr("id", "pcaSVG")
                         .attr("width", width)
                         .attr("height", height)
                         .call(d3PlotBrush);

    svg.append("g")
       .attr("class", "x axis")
       .attr("transform", "translate(0, " + yTranslationForXAxis + ")")
       .call(xAxis)
       .append("text")
       .style("font-size", 14)
       .text("PC1");

   svg.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(" + xTranslationForYAxis + ", 0)")
      .call(yAxis)
      .append("text")
      .attr("y", 10)
      .attr("dy", ".71em")
      .style("font-size", 14)
      .style("text-anchor", "end") //start, middle
      .text("PC2");
            
   var circle = svg.append("g").selectAll("circle")
                   .data(dataset)
                   .enter()
                   .append("circle")
                   .attr("cx", function(d,i) {return xScale(d[0]);})
                   .attr("cy", function(d,i) {return yScale(d[1]);})
                   .attr("r", function(d) { return 3;})
                   .style("fill", function(d) {
                        var color = chooseColor(d[0])
                        if(color == "") return "white"
                        return color;})
                   .style("stroke", function(d) {
                        var color = chooseColor(d[0])
                        if(color == "") return "black"
                        return color;})
                   .on("mouseover", function(d,i){
                         tooltip.text(currentIdentifiers[i]);
                         return tooltip.style("visibility", "visible");
                         })
                   .on("mousemove", function(){return tooltip.style("top",
                           (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");})
                   .on("mouseout", function(){return tooltip.style("visibility", "hidden");});
      
 
} // d3PcaScatterPlot
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   console.log("=== datasetSpecified");
   console.log(msg);

   var dataPackageName = msg.payload.datasetName;
   var dataElementNames = msg.payload.rownames;

      // for now, and very temporarily, use the first match (if any are found)
   var hits = dataElementNames.map(function(name) {if(name.indexOf("mtx.mrna") >= 0) return(name);});
   hits = hits.filter(function(n){ return (n !== undefined); });

   var matrixName = null;

   if(hits.length > 0){
        // for now always grab the first (last!) hit, remove the trailing .RData
        // the PCA constructor wants both dataPacakgeName & a matrix name
        // our convention is that the maniftest rowname is the same as
        // its name, with ".RData" appended
        // TODO: this needs to be a user menu selection (29 jun 2015)
      var lastHit = hits.length - 1;
      matrixName = hits[lastHit].replace(".RData", "");
      }
   else{
      alert("No mtx.mrna in dataset '" + dataPackageName + "'");
      hub.disableButton(calculatePcaButton);
      return;
      }

   console.log("== calling createPcaObjectOnServer");
   createPcaObjectOnServer(dataPackageName, matrixName);

   d3pcaDisplay.select("#pcaSVG").remove();  // so that old layouts aren't mistaken for new dataset

} // datasetSpecified
//--------------------------------------------------------------------------------------------
function createPcaObjectOnServer(dataPackageName, matrixName)
{
  console.log("create PCA on server " + dataPackageName + ": " + matrixName);
  payload = {dataPackage: dataPackageName, matrixName: matrixName};

  msg = {cmd: "createPCA", callback: "pcaObjectCreated", status: "request", payload: payload};

  msg.json = JSON.stringify(msg);
  hub.send(msg.json);

} // createPcaObjectOnServer
//--------------------------------------------------------------------------------------------
function pcaObjectCreated(msg)
{
   console.log("=== pcaObjectCreated");
   console.log(msg);

   if(msg.status == "response")
      requestGeneSetNames();
   else
      alert("PCA module failed to create PCA object on server");

} // pcaObjectCreated
//--------------------------------------------------------------------------------------------
// a simple test.  can be called from the console in global scope
demoPCAHighlight = function ()
{
   ids = ["TCGA.06.0192", "TCGA.12.0775", "TCGA.14.0789"];
   selectPoints(ids, true);

} // demoHighlight
//----------------------------------------------------------------------------------------------------
demo = function ()
{
  msg = {cmd: "specifyCurrentDataset", callback: "pcaCurrentDataSetSpecified",
         status: "request", payload: "DEMOdz"};

  hub.send(JSON.stringify(msg));

} // demo
//----------------------------------------------------------------------------------------------------
//function requestGeneSetNames()
//{
//   callback = "pcaHandleGeneSetNames";
//
//   msg = {cmd:"getGeneSetNames",
//          callback: callback,
//          status:"request",
//          payload:""};
//
//   hub.send(JSON.stringify(msg));
//
//} // requestGeneSetNames
////--------------------------------------------------------------------------------------------
//function handleGeneSetNames(msg)
//{
//   newNames = msg.payload;
//   addGeneSetNamesToMenu(newNames);
//
//} // handleGeneSetNames
//--------------------------------------------------------------------------------------------
function demoPcaCalculateAndDraw(msg)
{
  if(msg.status != "success"){
     alert("demoPCA failed: " + msg.payload);
     return;
     }

  var currentGeneSet = geneSetMenu.val();
  if(currentGeneSet == null)
      currentGeneSet = "tcga.GBM.classifiers";

  console.log("demoPCA, currentGeneSet: " + currentGeneSet);
  payload = {ids: "", geneSet: currentGeneSet};
  msg = {cmd: "calculate_mRNA_PCA", callback: "pcaPlot", status: "request", payload: payload};
  hub.send(JSON.stringify(msg));

} // demoPcaCalculateAndDraw
//----------------------------------------------------------------------------------------------------
function runTests()
{
  // the test does not currently depend upon any other tabs, but we want to add some
  // real world complexity to the situation, so we use tabs, including cpa (of course)
  // and the usual introcutory "Datasets" tab.  make sure it is there.
  // tests depend upon the presence of 2 tabs in addition to the present one.

  var datasetsTabPresent = $("#datasetsDiv").length > 0;

  if(!datasetsTabPresent){
     alert("Datasets tab needed for QUnit testing");
     return;
     } // check for other needed tabs

   testResultsOutputDiv.css({display: "block"});
   testLoadDataset();

} // runTests
//--------------------------------------------------------------------------------------------
function testLoadDataset()
{
   QUnit.test('choose DEMOdz dataset', function(assert) {
      hub.raiseTab("datasetsDiv");
      var desiredDataset = "DEMOdz";
      var dzNames = $("#datasetMenu option").map(function(opt){return this.value;});

      if($.inArray(desiredDataset, dzNames) < 0){
         alert("cannot run tests:  " + desiredDataset + " dataset not loaded");
         return;
         }

      $("#datasetMenu").val(desiredDataset);
      $("#datasetMenu").trigger("change");

      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      assert.expect(3);

      setTimeout(function(){
         assert.equal($("#datasetMenu").val(), desiredDataset);  done1();
         assert.ok($("#datasetsManifestTable tr").length >= 10); done2();
         assert.equal($("#datasetsManifestTable tbody tr").eq(0).find("td").eq(0).text(), 
                      "mRNA expression"); done3();
         $("#selectDatasetButton").click();
         hub.raiseTab(thisModulesOutermostDiv);
         testCalculate();
         }, 5000);
      });

} // testLoadDataset
//----------------------------------------------------------------------------------------------------
function testCalculate()
{
   hub.raiseTab(thisModulesOutermostDiv);
   console.log("starting testCalculate");

     // enable the calculate button, change its color, then click
   QUnit.test('testPcaCalculate', function(assert) {
      $("#pcaCalculateButton").prop("disabled", false);
      $("#pcaCalculateButton").css({"background-color": "red", "color": "green"});
      $("#pcaGeneSetSelector").val("random.24")
      assert.expect(1);   // tests (assertions) in next function, testContentsOfPcaPlot
      setTimeout(function(){
         $("#pcaCalculateButton").click();
         testContentsOfPcaPlot();
         }, 6000);
      });

} // testCalculate
//----------------------------------------------------------------------------------------------------
function testContentsOfPcaPlot()
{
   console.log("--- testContentsOfPcaPlot");

      // wait 5 seconds
      // make sure there are the right number of circles
      // check the coordinates of two, selected arbitrarily
   QUnit.test('testPcaContents', function(assert) {
      assert.expect(5);
      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      var done4 = assert.async();
      var done5 = assert.async();
      setTimeout(function(){
         assert.ok($("circle").length > 120); done1();
         var c0 = $("circle")[0];
         var xPos = Number(c0.getAttribute("cx"));
         var yPos =  Number(c0.getAttribute("cy"));
         var radius = Number(c0.getAttribute("r"));
         console.log(xPos + "  " + yPos + "  " + radius);
         assert.ok(xPos > 0); done3();
         assert.ok(yPos > 0); done4();
         assert.equal(radius, 3); done5();
         }, 5000);
      });


} // testContentsOfPcaPlot
//----------------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
//
function runAutomatedTestsIfAppropriate()
{
   var msg = {cmd: "getUserId",  callback: "pcaAssessUserIdForTesting",
              status: "request", payload: ""};

   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   var userID = msg.payload;

   if(userID.indexOf("autoTest") === 0){
      console.log("plsr/Module.js running tests for user " + userID);
      for(var i=0; i < 3; i++)
          runTests();
      } // if autoTest

} // assessUserIdForTesting
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   hub.addOnDocumentReadyFunction(initializeUI);
   hub.registerSelectionDestination(selectionDestinationsOfferedHere, thisModulesOutermostDiv);
   hub.addMessageHandler("datasetSpecified", datasetSpecified);
   hub.addMessageHandler("sendSelectionTo_PCA", handlePatientIDs);
   hub.addMessageHandler("sendSelectionTo_PCA (highlight)", highlightPatientIDs)
   hub.addMessageHandler("pcaObjectCreated", pcaObjectCreated);
   hub.addMessageHandler("pcaHandleGeneSetNames", handleGeneSetNames);
   hub.addMessageHandler("pcaPlot", pcaPlot);
   hub.addMessageHandler("demoPcaCalculateAndDraw", demoPcaCalculateAndDraw);
   hub.addMessageHandler("pcaAssessUserIdForTesting", assessUserIdForTesting);
   hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);

   //hub.addMessageHandler("handlePatientClassification", handlePatientClassification)
   // hub.addSocketConnectedFunction(getPatientClassification);

} // initializeModule
//----------------------------------------------------------------------------------------------------
return{
  init: initializeModule,
  demo: demo
  };
    
}); // PCAModule
//----------------------------------------------------------------------------------------------------
pca = PCAModule();
pca.init();

var plsrXXX;
//----------------------------------------------------------------------------------------------------
var PLSRModule = (function () {

  var plsrDisplay;
  var d3plsrDisplay;
  var statusDiv; 

  var geneLoadings = [];
  var geneNames = [];
  var vectors = [];
  var vectorNames = [];

  var firstTime = true;
  var sendSelectionMenu;

      // these are reported by the server, from an inspection of the data
  var ageAtDxMin=0, ageAtDxMax=1000, survivalMin=0, survivalMax=1000;

      // 4 sliders and their readout
  var ageAtDxSlider, ageAtDxMinSliderReadout, ageAtDxMaxSliderReadout;
  var survivalSlider, survivalMinSliderReadout, survivalMaxSliderReadout;

      // the current values specifying the subsets
      // set as 1/3 from min and max initially, subsequently read
      // from the sliders
  var ageAtDxMinThreshold, ageAtDxMaxThreshold, survivalMinThreshold, survivalMaxThreshold;

  var calculateButton;
  var clearSelectionButton;
  var d3brush;
  var currentlySelectedRegion;
  var thisModuleName = "PLSR";
  var geneSetMenu;

  var thisModulesName = "PLSR";
  var thisModulesOutermostDiv = "plsrDiv";
  var testResultsOutputDiv;
  var currentAbsoluteMaxValue; // most recent max value, used for scaling

  var sendSelectionsMenuTitle = "Send selection...";
  var selectionDestinationsOfferedHere = ["PLSR (highlight)"];
 
  var expressionDataSetName = "";

//--------------------------------------------------------------------------------------------
function initializeUI () 
{
   plsrDisplay = $("#plsrDisplay");
   d3plsrDisplay = d3.select("#plsrDisplay");

   statusDiv = $("#plsrStatusDiv");

   ageAtDxSlider = $("#plsrAgeAtDxSlider");
   ageAtDxMinSliderReadout = $("#plsrAgeAtDxMinSliderReadout");
   ageAtDxMaxSliderReadout = $("#plsrAgeAtDxMaxSliderReadout");

   survivalSlider = $("#plsrSurvivalSlider");
   survivalMinSliderReadout = $("#plsrSurvivalMinSliderReadout");
   survivalMaxSliderReadout = $("#plsrSurvivalMaxSliderReadout");

   calculateButton = $("#plsrCalculateButton");
   calculateButton.button();
   calculateButton.click(requestPLSRByOnsetAndSurvival);
   hub.disableButton(calculateButton);

   geneSetMenu = $("#plsrGeneSetSelector");

   clearSelectionButton = $("#plsrClearSelectionButton");
   clearSelectionButton.button();
   clearSelectionButton.click(clearSelection);
   hub.disableButton(clearSelectionButton);

   sendSelectionMenu = hub.configureSendSelectionMenu("#plsrSendSelectionsMenu", 
                                                        selectionDestinationsOfferedHere,
                                                        sendSelections,
                                                        sendSelectionsMenuTitle);
   //hub.disableButton(sendSelectionMenu);
   
   //setupSliders();

   testResultsOutputDiv = $("#plsrTestingOutputDiv");

   $(window).resize(handleWindowResize);
   handleWindowResize();
   
   hub.disableTab(thisModulesOutermostDiv);


} // initializeUI
//--------------------------------------------------------------------------------------------
function addGeneSetNamesToMenu (geneSetNames)
{
   geneSetMenu.empty();
   if(geneSetNames.length === 0) {
      return;
      }
   
  if(typeof geneSetNames == "string") 
   	 geneSetNames = [geneSetNames] 

      
   for(var i=0; i < geneSetNames.length; i++){
      optionMarkup = "<option>" + geneSetNames[i] + "</option>";
      geneSetMenu.append(optionMarkup);
      } // for i

} // addGeneSetNamesToMenu
//--------------------------------------------------------------------------------------------
function getAgeAtDxAndSurvivalInputRanges()
{
   msg = {cmd: "summarizePLSRPatientAttributes", callback: "handleAgeAtDxAndSurvivalRanges", 
          status: "request", payload: ["AgeDx", "Survival"]};

   hub.send(JSON.stringify(msg));

} // getAgeAtDxAndSurvivalInputRanges
//----------------------------------------------------------------------------------------------
function handleAgeAtDxAndSurvivalRanges(msg)
{
   console.log("=== Module.plsr, handleAgeAtDxAndSurvivalRanges");

   if(msg.status != "success"){
		//error message should be issued 
		return;
	}
   ageAtDxMin = Math.floor(msg.payload.AgeDx[0]/365.24);
   ageAtDxMax = Math.floor(msg.payload.AgeDx[4]/365.24);
   survivalMin = Math.floor(msg.payload.Survival[0]/365.24);
   survivalMax = Math.floor(msg.payload.Survival[4]/365.24);

   //ageAtDxMin = Math.floor(msg.payload.AgeDx[0])-1;
   //ageAtDxMax = Math.floor(msg.payload.AgeDx[4])+1;
   //survivalMin = Math.floor(msg.payload.Survival[0])-1;
   //survivalMax = Math.floor(msg.payload.Survival[4])+1;
   setupSliders();

     // now that sliders are set up, setup the geneSetName selector
   requestGeneSetNames();

} // handleAgeAtDxAndSurvivalRanges 
//--------------------------------------------------------------------------------------------------
function sendSelections()
{
  var destination = sendSelectionMenu.val();
  selectedIDs = identifyEntitiesInCurrentSelection();

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: selectedIDs, count: selectedIDs.length, source: "plsr module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------------
function requestPLSRByOnsetAndSurvival()
{
  ageAtDxMinThreshold = Number(ageAtDxMinSliderReadout.val()) * 365.24;
  ageAtDxMaxThreshold = Number(ageAtDxMaxSliderReadout.val()) * 365.24;
  survivalMinThreshold = Number(survivalMinSliderReadout.val()) * 365.24; 
  survivalMaxThreshold = Number(survivalMaxSliderReadout.val()) * 365.24;

  var currentGeneSetName = geneSetMenu.val();

  factor1 = {name: "AgeDx", 
             low: ageAtDxMinThreshold, 
             high: ageAtDxMaxThreshold};

  factor2 = {name: "Survival", 
             low: survivalMinThreshold,
             high: survivalMaxThreshold};
  
  payload = {genes: currentGeneSetName, 
             factorCount: 2, 
             factors: [factor1, factor2]};
  
  msg = {cmd: "calculatePLSR", callback: "handlePlsrResults", status: "request", payload: payload};
  msg.json = JSON.stringify(msg);

  hub.send(msg.json);
  $("#plsrInstructions").css("display", "none");
  $("#plsrDisplay").css("display", "block");
}  // requestPLSRByOnsetAndSurvival
//--------------------------------------------------------------------------------------------------
function setupSliders()
{
   var ageAtDxSpan = ageAtDxMax - ageAtDxMin;
   var survivalSpan = survivalMax - survivalMin;

   ageAtDxMinThreshold = Math.floor(ageAtDxMin + (ageAtDxSpan/3));
   ageAtDxMaxThreshold = Math.floor(1 + ageAtDxMax - (ageAtDxSpan/3));
   survivalMinThreshold = Math.floor(survivalMin + (survivalSpan/3));
   survivalMaxThreshold = Math.floor(1 + survivalMax - (survivalSpan/3));
 
   ageAtDxSlider.slider({
      range: true,
      slide: function(event, ui) {
          if(ui.values[0] > ui.values[1]){
            return false;
         }          
         ageAtDxMin = Number(ui.values[0]);
         ageAtDxMinSliderReadout.text (ui.values[0]);
         ageAtDxMax = Number(ui.values[1]);
         ageAtDxMaxSliderReadout.text (ui.values[1]);
         },
      min: ageAtDxMin,
      max: ageAtDxMax,
      values: [ageAtDxMinThreshold.toFixed(0), ageAtDxMaxThreshold.toFixed(0)]
      });
     ageAtDxMinSliderReadout.text(ageAtDxMinThreshold);
     ageAtDxMaxSliderReadout.text(ageAtDxMaxThreshold);

   survivalSlider.slider({
      range: true,
      slide: function(event, ui) {
         if(ui.values[0] > ui.values[1]){
            return false;
         }          
         survivalMin = ui.values[0];
         survivalMinSliderReadout.text(survivalMin);
         survivalMax = ui.values[1];
         survivalMaxSliderReadout.text(survivalMax);
         },
      min: survivalMin,
      max: survivalMax,
      //step: 0.1,
      values: [survivalMinThreshold, survivalMaxThreshold]
      });
   survivalMinSliderReadout.text(survivalMinThreshold);
   survivalMaxSliderReadout.text(survivalMaxThreshold);

} // setupSliders
//--------------------------------------------------------------------------------------------------
function handlePlsrResults (msg)
{
   firstTime = false;
   if(msg.status == "error"){
      alert(msg.payload);
      return;
      }

   var payload = msg.payload;

   var absMaxValue = payload.maxValue;
   vectors = payload.vectors;
   vectorNames = payload.vectorNames;
   geneLoadings = payload.loadings;
   geneNames = payload.loadingNames;

   currentAbsoluteMaxValue = absMaxValue; // most recent max value, used for scaling

   svg = d3PlsrScatterPlot(geneLoadings, geneNames, vectors, vectorNames, absMaxValue);
   postStatus("scatterplot complete");

} // handlePlsrResults
//--------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function d3PlotBrushReader () {

  currentlySelectedRegion = d3brush.extent();
  x0 = currentlySelectedRegion[0][0];
  x1 = currentlySelectedRegion[1][0];
  width = Math.abs(x0-x1);
  selectedIDs = identifyEntitiesInCurrentSelection();

  console.log("=== plsr d3PlotBrushReader");
  console.log("  selectedIDs: " + selectedIDs.length);
  console.log("   destinations: " + sendSelectionMenu.children().length);

  //hub.disableButton(sendSelectionMenu);

  //if(selectedIDs.length === 0) 
  //   hub.disableButton(sendSelectionMenu);
  //else{
  //   if(sendSelectionMenu.children().length > 1)  // always at least one entry, the menu title
  //    hub.disableButton(sendSelectionMenu);
  //  }

} // d3PlotBrushReader
//-------------------------------------------------------------------------------------------
function d3PlsrScatterPlot(genes, geneNames, vectors, vectorNames, absMaxValue)
{
   var padding = 70;
   var width = plsrDisplay.width();
   var height = plsrDisplay.height();

   d3plsrDisplay.select("#plsrSVG").remove();  // so that append("svg") is not cumulative

   geneDataset = genes;

   absMaxValue = 1.2 * absMaxValue;
   var negAbsMaxValue = -1.0 * absMaxValue;

   var xScale = d3.scale.linear()
                  .domain([negAbsMaxValue, absMaxValue])
                  .range([padding, width - padding * 2]);

   var yScale = d3.scale.linear()
                  .domain([negAbsMaxValue, absMaxValue])
                  .range([height - padding, padding]); // note inversion 

   var xAxis = d3.svg.axis()
                 .scale(xScale)
                 .orient("bottom")
                 .ticks(5);

   var yAxis = d3.svg.axis()
                 .scale(yScale)
                 .orient("left")
                 .ticks(5);

   d3brush = d3.svg.brush()
                   .x(xScale)
                   .y(yScale)
                   .on("brushend", d3PlotBrushReader);

   function transform(d) {
      return "translate(" + xScale(d.Comp1) + "," + yScale(d.Comp2) + ")";
      } //transform

   var assignColor = d3.scale.ordinal()
                             .domain(["gene",     "vector"])
                             .range (["gray",     "red"]);

   var svg = d3plsrDisplay.append("svg")
               .attr("id", "plsrSVG")
               .attr("width", width)
               .attr("height", height)
               .call(d3brush);
               //.append("g");
               //.attr("transform", "translate(" + padding + "," + padding + ")");

   var tooltip = d3plsrDisplay.append("div")
                              .attr("data-toggle", "tooltip")
                              .style("position", "absolute")
                              .style("z-index", "10")
                              .style("visibility", "hidden")
                              .text("a simple tooltip");


        // draw the genes

   var circle= svg.selectAll("circle")
                  .data(geneDataset)
                  .enter()
                  .append("circle")
                  .attr("cx", function(d,i) {return xScale(d[0]);})
                  .attr("cy", function(d,i) {return yScale(d[1]);})
                  .attr("r",  function(d)   {return 3;})
                  .text(function(d,i){
                     return(geneNames[i]);
                     })
                  .style("fill", function(d) { return assignColor(d.category); })
                  .on("mouseover", function(d,i){
                     tooltip.text(geneNames[i]);
                     return tooltip.style("visibility", "visible");
                     })
                  .on("mousemove", function(){
                      return tooltip.style("top", (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");})
                  .on("mouseout", function(){return tooltip.style("visibility", "hidden");});

   var line = svg.selectAll("line")
                 .data(vectors)
                 .enter().append("line")
                         .attr("class", "line")
                         .style("stroke-width", 1)
                         .style("stroke", "red")
                         .attr("x1", xScale(0))
                         .attr("y1", yScale(0))
                         .attr("x2", function(v) { return xScale(v[0]); })
                         .attr("y2", function(v) { return yScale(v[1]); });

   var text = svg.selectAll("text")
                 .data(vectors)
                 .enter().append("text")
                         .attr("class", "text")
                         .attr("x", function(v) { return xScale(v[0]); })
                         .attr("y", function(v) { return yScale(v[1]); })
                         .text( function(v, i) {return vectorNames[i];})
                         .attr("text-anchor", "middle")
                         .style("fill", "black") ;
   return(svg);

} // d3PlsrScatterPlot
//--------------------------------------------------------------------------------------------
function handleWindowResize ()
{
   plsrDisplay.width($(window).width() * 0.95);
   plsrDisplay.height($(window).height() * 0.75);

   if(!firstTime)  // easiest way to handle resize: redraw from scratch
      d3PlsrScatterPlot(geneLoadings, geneNames, vectors, vectorNames, currentAbsoluteMaxValue);

} // handleWindowResize
//--------------------------------------------------------------------------------------------
function identifyEntitiesInCurrentSelection ()
{
   x1 = currentlySelectedRegion[0][0];
   y1 = currentlySelectedRegion[0][1];
   x2 = currentlySelectedRegion[1][0];
   y2 = currentlySelectedRegion[1][1];
   ids = [];
   for(var i=0; i < geneLoadings.length; i++){
     x = geneLoadings[i][0];
     y = geneLoadings[i][1];
     geneSymbol = geneNames[i];
     if(x >= x1 & x <= x2 & y >= y1 & y <= y2)         
       ids.push(geneSymbol);
      } // for i

   return(ids);
    
} // identifyEntitiesInCurrentSelection
//--------------------------------------------------------------------------------------------
function selectPoints(ids, clearIDs)
{
   d3.selectAll("circle")
     .filter(function(d,i){
         match = ids.indexOf(geneNames[i]);
         if(match >= 0){
            console.log("PLSR select match: " + geneNames[i]);
            }
         return (match >= 0);
         }) // filter
     .classed("highlighted", true)
     .transition()
     .attr("r", 20)
     .style("fill", "red")
     .duration(500);

  hub.enableButton(clearSelectionButton);

} // selectPoints
//----------------------------------------------------------------------------------------------------
function clearSelection()
{

  d3.selectAll("circle")
    .classed("highlighted", false)
    .attr("r", 3);

  d3brush.clear();
  svg.selectAll('.brush').call(d3brush);
  handleWindowResize();

} // clearSelection
//----------------------------------------------------------------------------------------------------

function highlightGenes(msg)
{
   hub.raiseTab(thisModulesOutermostDiv);

   var candidates = msg.payload.value;
   console.log("PLSR highlight genes, candidates: " + candidates.length);
   console.log("                  currently held: " + geneNames.length);

   var intersection = hub.intersectionOfArrays(candidates, geneNames);
   console.log("                    intersection: " + intersection.length);
   console.log(JSON.stringify(intersection));

   if(intersection.length === 0){
     count = candidates.length;
     errorMessage = "None of the incoming ids were recognized: ";
     for(var i=0; i < count; i++){
       errorMessage += candidates[i] + " ";
       }
     title = "Unrecognized Identifiers";
     $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
     } // if intersection
   else
     selectPoints(candidates, true);

} // highlightGenes
//----------------------------------------------------------------------------------------------------
function requestGeneSetNames()
{
   callback = "plsrHandleGeneSetNames";

   msg = {cmd:"getGeneSetNames",
          callback: callback,
          status:"request",
          payload:""};

   hub.send(JSON.stringify(msg));

} // requestGeneSetNames
//--------------------------------------------------------------------------------------------
function handleGeneSetNames(msg)
{
   newNames = msg.payload;
   addGeneSetNamesToMenu(newNames);
   hub.enableButton(calculateButton);
   hub.enableTab(thisModulesOutermostDiv);

   postStatus("plsr ui now configured");

} // handleGeneSetNames
//--------------------------------------------------------------------------------------------
// when a dataset is specified, this module 
//  1) extracts the name of the dataset from the payload of the incoming msg
//  2) (for now) extracts the name of the matrices, from the manifest (also in the payload
//     of the incoming msg, chooses the first mtx.mrna entry it finds
//  3) sends a "createPLSR" message to the server, with dataset & matrix name specified
//  4) asks that the server, upon successful completion of that createPLSR request, callback
//     here so that the sliders can be set
function datasetSpecified(msg)
{
   console.log("==== Module.plsr, datasetSpecified");
   console.log(msg);

   plsrXXX = msg;
   var dataPackageName = msg.payload.datasetName;
 
       // ["mtx.cn.RData", "history.RData", "mtx.mrna.RData", "mtx.mrna.ueArray.RData", 
       // "mtx.mut.RData", "mtx.prot.RData", "mtx.meth.RData", "markers.json.RData", 
       // "genesets.RData", "g.markers.json"]
   var dataElementNames = msg.payload.rownames;

      // for now, and very temporarily, use the first match (if any are found)
   var hits = dataElementNames.map(function(name) {if(name.indexOf("mtx.mrna") >= 0) return(name);});
   hits = hits.filter(function(n){ return (n !== undefined); });

   var matrixName = null;

   if(hits.length > 0){
        // for now always grab the last hit, remove the trailing .RData
        // the PLSR constructor wants both dataPacakgeName & a matrix name
        // our convention is that the maniftest rowname is the same as
        // its name, with ".RData" appended
      var lastHit = hits.length - 1;
      matrixName = hits[lastHit].replace(".RData", "");
      }
   else{
      hub.disableButton(calculateButton);
      return;
      }
   d3plsrDisplay.select("#plsrSVG").remove();  // so that old layouts aren't mistaken for new dataset
      
   createPlsrObjectOnServer(dataPackageName, matrixName);

} // datasetSpecified
//--------------------------------------------------------------------------------------------
function createPlsrObjectOnServer(dataPackageName, matrixName)
{
  console.log("create PLSR on server " + dataPackageName + ": " + matrixName);
  payload = {dataPackage: dataPackageName, matrixName: matrixName};

  msg = {cmd: "createPLSR", callback: "plsrObjectCreated", status: "request", payload: payload};

  msg.json = JSON.stringify(msg);
  hub.send(msg.json);

} // createPlsrObjectOnServer
//--------------------------------------------------------------------------------------------
function requestSliderRanges(msg)
{
   console.log("--- requestSliderRanges");
   console.log(msg);
   msg = {cmd: "summarizePLSRPatientAttributes",
          callback: "handleAgeAtDxAndSurvivalRanges",
          status: "request", payload: ["AgeDx", "Survival"]};

   hub.send(JSON.stringify(msg));

} // requestSliderRanges
//--------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
function runAutomatedTestsIfAppropriate()
{
   var msg = {cmd: "getUserId",  callback: "plsrAssessUserIdForTesting",
              status: "request", payload: ""};

   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   var userID = msg.payload;

   if(userID.indexOf("autoTest") === 0){
      console.log("plsr/Module.js running tests for user " + userID);
      var plsrTester = PlsrTestModule();
      plsrTester.run();
      } // if autoTest

} // assessUserIdForTesting
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   hub.addOnDocumentReadyFunction(initializeUI);
   hub.registerSelectionDestination(selectionDestinationsOfferedHere, thisModulesOutermostDiv);
   hub.addMessageHandler("plsrHandleGeneSetNames", handleGeneSetNames);
   hub.addMessageHandler("handlePlsrResults", handlePlsrResults);
   hub.addMessageHandler("handleAgeAtDxAndSurvivalRanges", handleAgeAtDxAndSurvivalRanges);
   hub.addMessageHandler("datasetSpecified", datasetSpecified);
   hub.addMessageHandler("sendSelectionTo_PLSR (highlight)", highlightGenes);
   hub.addMessageHandler("plsrObjectCreated", requestSliderRanges);
   hub.addMessageHandler("plsrAssessUserIdForTesting", assessUserIdForTesting);
   hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);

} // initializeModule
//--------------------------------------------------------------------------------------------
return{
   init: initializeModule,
   };

}); // PLSRModule
//----------------------------------------------------------------------------------------------------
plsr = PLSRModule();
plsr.init();

//----------------------------------------------------------------------------------------------------
var LinkoutModule = (function () {

  var thisModulesName = "linkout";
  var selectionDestinations = ["DGIdb", "Wikipedia", "Google", "GeneCards"];
  var thisModulesOutermostDiv = null;

//--------------------------------------------------------------------------------------------
function handleSelections_google(msg)
{
   console.log(JSON.stringify(msg));
   var ids = msg.payload.value;
   var searchString = ids[0];   // just one term for google

   var url = 'http://www.google.com/search?q="' + searchString + '"';
   window.open(url);

} // handleSelections_google
//----------------------------------------------------------------------------------------------------
function handleSelections_DGIdb(msg)
{
   console.log(JSON.stringify(msg));
   var ids = msg.payload.value;
   var searchString = ids[0];
   for(var i=1; i < msg.payload.value.length; i++)
     searchString = searchString + "," + ids[i];

   var url = "http://dgidb.genome.wustl.edu/interaction_search_results?genes=" + searchString; //=EGFR,MET
   url = url + "&limit_drugs=true";
   window.open(url);

} // handleSelections_DGIdb
//----------------------------------------------------------------------------------------------------
function handleSelections_wikipedia(msg)
{
   console.log(JSON.stringify(msg));
   var baseUrl = "https://en.wikipedia.org/wiki/";
   var ids = msg.payload.value;
   var searchString = ids[0];
   var url = baseUrl + searchString;
   window.open(url);

} // handleSelections_wikipedia
//----------------------------------------------------------------------------------------------------
function handleSelections_genecards(msg)
{
   console.log(JSON.stringify(msg));
   var baseUrl = "http://www.genecards.org/cgi-bin/carddisp.pl?gene=";
   var ids = msg.payload.value;
   var searchString = ids[0];
   var url = baseUrl + searchString;
   window.open(url);

} // handleSelections_genecards
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
   //hub.addOnDocumentReadyFunction(initializeUI);
   hub.addMessageHandler("sendSelectionTo_DGIdb", handleSelections_DGIdb);
   hub.addMessageHandler("sendSelectionTo_Wikipedia", handleSelections_wikipedia);
   hub.addMessageHandler("sendSelectionTo_Google", handleSelections_google);
   hub.addMessageHandler("sendSelectionTo_GeneCards", handleSelections_genecards);

} // initializeModule
//----------------------------------------------------------------------------------------------------
return{
   init: initializeModule
   }; // LinkoutModule return value

//----------------------------------------------------------------------------------------------------
}); // LinkoutModule

linkoutModule = LinkoutModule();
linkoutModule.init();


//----------------------------------------------------------------------------------------------------
    // observers used in QUnit testing
  var datasetsStatusObserver = null;
  var pcaStatusObserver = null;


var OncoscapeAppTestModule = (function () {


//--------------------------------------------------------------------------------------------
runTests = function()
{
   var datasetNames; 
   
   QUnit.test("all expected tabs present?", function(assert){
     console.log("starting 'all expected tabs present?' test");
     assert.equal($("#oncoscapeTabs").length, 1);               
     assert.equal($("#datasetsDiv").length, 1);
     assert.equal($("#patientHistoryDiv").length, 1);
     assert.equal($("#markersAndPatientsDiv").length, 1);
     assert.equal($("#gbmPathwaysDiv").length, 1);
     assert.equal($("#survivalDiv").length, 1);
     assert.equal($("#pcaDiv").length, 1);
     assert.equal($("#plsrDiv").length, 1);
     assert.equal($("#userDataStoreDiv").length, 1);
     });
 
   QUnit.test("determine available datasets", function(assert) {
      console.log("determine available datasets");
      datasetNames = $("#datasetMenu option").map(function(opt){return this.value})
      datasetNames = datasetNames.filter(function(e){return e});
      assert.ok(datasetNames.length > 0);        
      });

   console.log(datasetNames);
   console.log("datasetNames length: " + datasetNames.length);

   //for(var i=0; i < datasetNames.length; i++){
   //   console.log("about to start testing with dataset '" + datasetNames[i] + "'");
      testDisplayDataSetManifest("DEMOdz");
   //   }


}; // runTests
//----------------------------------------------------------------------------------------------------
//
// setup a mutation observer watching the datasetsStatusDiv
// raise the datasets tab
// select the named dataset
// mutation observer will call qunit_testManifestTableDisplayed
//
function testDisplayDataSetManifest(datasetName)
{
   var testTitle = 'display dataset manifest for ' + datasetName;

   console.log(testTitle);

   $("#datasetMenu").val(datasetName);
   $("#datasetMenu").trigger("change");
   
   var target = document.querySelector("#datasetsStatusDiv");
   console.log(" new mutobs target: " + target.id);

   if(datasetsStatusObserver == null) {
   datasetsStatusObserver = new MutationObserver(function(mutations) {
     datasetsStatusObserver.disconnect();
      //mutations.forEach(function(mutation) {
        var mutation = mutations[0];
        var id = mutation.target.id;
        var msg = $("#datasetsStatusDiv").text();
        console.log(id + " status changed: " + msg);
        QUnit.test(testTitle, function(assert) {
           assert.equal($("#datasetMenu").val(), datasetName);
           assert.ok($("#datasetsManifestTable tr").length >= 10);
           var firstRowTitle = $("#datasetsManifestTable tbody tr td")[0].innerHTML;
           var expectedTitles = ["mRNA expression", "mutations", "copy number", "history", 
                                 "protein abundance", "methylation", "geneset", "network"];
           assert.ok(jQuery.inArray(firstRowTitle, expectedTitles) >= 0);
           console.log("dispalyDataSetManifest test complete, now calling loadDataSet");
           firstTime = true;
           datasetsStatusObserver.disconnect();
           hub.raiseTab("datasetsDiv");
           testLoadDataSet(datasetName);
           }); // Qunit.test
         });  // new MutationObserver
      } // not null
   var config = {attributes: true, childList: true, characterData: true};
   datasetsStatusObserver.observe(target, config);
   console.log("observing " + target.id);

}; // testDisplayDataSetManifest
//----------------------------------------------------------------------------------------------------
function testLoadDataSet(datasetName)
{
   var testTitle = 'testLoadDataSet: ' + datasetName;
   console.log(testTitle);

   $("#selectDatasetButton").trigger("click");

     // patientHistory, PCA, PLSR tabs all respond to the "datasetSelected" message

   var pcaTarget = document.querySelector("#pcaStatusDiv");
   console.log(" new mutobs target: " + pcaTarget.id);

   if(pcaStatusObserver == null){
   pcaStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        pcaStatusObserver.disconnect();
        pcaStatusOvserver = null;
        var id = mutation.target.id;
        var msg = $("#pcaStatusDiv").text();
        console.log("======== ----- =========== " + id + " status changed: " + msg);
        QUnit.test("PCA button enabled after loading dataset", function(assert) {
           assert.equal($("#datasetMenu").val(), datasetName);
           assert.equal($("#pcaCalculateButton").prop("disabled"), false);
           });
      }) // new MutationObserver
     } // if null

   var config = {attributes: true, childList: true, characterData: true};
   pcaStatusObserver.observe(pcaTarget, config);
   console.log("observing " + pcaTarget.id);

   hub.raiseTab("pcaDiv");
 
}; // testLoadDataSet
//----------------------------------------------------------------------------------------------------
function testDEMOdzPLSRConfiguration()
{
   QUnit.test('testDEMOdzPLSRConfiguration', function(assert) {
      var minAge = $("#plsrAgeAtDxMinSliderReadout").val();
      assert.ok(minAge == "45");
      var maxAge = $("#plsrAgeAtDxMaxSliderReadout").val();
      assert.ok(maxAge == "66");
      var minSurvival = $("#plsrSurvivalMinSliderReadout").val();
      console.log("  minSurvival: " + minSurvival);
      assert.ok(minSurvival == "3");
      var maxSurvival = $("#plsrSurvivalMaxSliderReadout").val();
      console.log("  maxSurvival: " + maxSurvival);
      assert.ok(maxSurvival == "7"); 
      assert.ok($("#plsrGeneSetSelector").val() == "random.40");
      testRunPLSR();
      });

} // testDEMOdzPLSRConfiguration
//----------------------------------------------------------------------------------------------------
function testRunPLSR()
{
   QUnit.test('testRunPLSR', function(assert) {
      $("#plsrCalculateButton").trigger("click");
       assert.expect(6); 
       var done1 = assert.async();
       var done2 = assert.async();
       var done3 = assert.async();
       var done4 = assert.async();
       var done5 = assert.async();
       var done6 = assert.async();
       setTimeout(function(){
          assert.ok($("circle").length > 10); done1();
          assert.ok($("circle").length > 10); done2();
          var c0 = $("circle")[0];
          var geneName = c0.innerHTML;
          assert.ok(geneName == "PRRX1"); done3();
          var xPos = Number(c0.getAttribute("cx"));
          var yPos =  Number(c0.getAttribute("cy"));
          var radius = Number(c0.getAttribute("r"));
          assert.ok(xPos > 0); done4();
          assert.ok(yPos > 0); done5();
          assert.ok(radius > 0); done6();
          }, 5000);
      });

} // testRunPLSR
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   console.log("initializing scripts/apps/oncoscape");

} // initializeModule
//----------------------------------------------------------------------------------------------------
return{
   init: initializeModule,
   run: runTests
   }; // module return value

//----------------------------------------------------------------------------------------------------
}); // OncoscapeAppTestModule
oat = OncoscapeAppTestModule();
oat.init();


</script>

<body>

  <div id="qunit" style="display:none"></div>
  <div id="qunit-fixture"></div>

<div id="oncoscapeTabs">
   <ul>
     <li><a href="#datasetsDiv">Datasets</a></li>
     <li><a href="#patientHistoryDiv">Patient History</a></li>
     <li><a href="#patientTimeLinesDiv">Timelines</a></li>
     <li><a href="#markersAndPatientsDiv">Markers &amp; Patients</a></li>
     <li><a href="#gbmPathwaysDiv">GBM Pathways</a></li>
     <li><a href="#survivalDiv">Survival</a></li>
     <li><a href="#pcaDiv">PCA</a></li>
     <li><a href="#plsrDiv">PLSR</a></li>

   </ul>

<style>
</style>

<div id="datasetsDiv" style="height:auto">
  <div id="datasetsStatusDiv" style="display:none"></div>
  <div id="dataSummaryControlsDiv">
     <span id="selectDataSetMenuLabel" style="margin-left: 20px;">Available Datasets</span>
     <select type="button" id="datasetMenu" style="margin: 5px;"><option> </option></select>
     <button id="selectDatasetButton">Use Dataset</button>
	 <span id="loadingDatasetMessage" style="display:none; margin-left:10px">Loading Dataset...</span>
     <select type="button" id="datasetsSendSelectionsMenu" style="float:right; margin:15px; display: none"></select>
    <div id="oncoscapeLogo" style="float:right; margin-right:0.5em">	<img width="175" src="http://oncoscape.sttrcancer.org/oncoscape/images/oncoscape_logo_TM.png" alt="Oncoscape"/></div>
  </div>

   <div id="dataSetNamesOutputDiv" style="margin: 20px;"></div>

   <div id="dataSummaryOutputDiv" style="margin: 20px;overflow-x:auto">
      <div id="datasetInstructions">Please select a dataset from the above menu.</div>
      <table id="datasetsManifestTable" class="display" cellpadding="0" cellspacing="0" style="margin:0px; width:auto; display:none; border:none"></table>
   </div>
</div>

<style>


#patientHistoryDiv{
   width: 600px;
   height: 400px;
   background-color: #ffffff;
   margin: auto;
   padding: 5px;
   }


#patientHistoryControlsDiv {
  background-color: #FFFFFF;
  position: relative;
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  border-radius: 5px;
  margin-right: auto;
  margin-left: auto;
  margin-top: 10px;
  margin-bottom: 5px;
  padding: 0px;
  }

#patientHistoryTableDiv {
  background-color: #FFFFFF;
  position: relative;
  height: 400px;
  width: 600px;
  overflow-x:auto;
  margin-right: auto;
  margin-left: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  padding: 0px;
  }

.patientDataFilterSliderReadout {
  font-family:"Courier";
  color: #0000FF;
  background-color: #FFF;
  font-size: 12px;
  border: 2px solid #DDD;
  width: 50px;
  height: 25px;
  resize: none;
  margin-top: 5px;
  margin-left: 1px;
  }

.patientDataFilterSliderTitleDiv {
  font-family:"Arial";
  color: #000000;
  font-size: 12px;
  padding-top: 0px;
  padding-right:0px;
  }

.ColVis_collection{
width:auto;
}

</style>


<div id="patientHistoryDiv">
  <div id="patientHistoryStatusDiv" style="display:none"></div>
  <div id="patientHistoryControlsDiv">  


        <div id="ageSliderDiv" class="nav navbar-nav navbar-form navbar-left"  style="display: inline-block">
           <div id="ageAtDxSliderTitleDiv" class="patientDataFilterSliderTitleDiv" style="text-align: center; width=100%">Age at Dx</div>
           <div style="width: 280px; overflow: hidden;">
               <div id="ageAtDxMsgBox1" style="float: left; margin-left: 5px; margin-right: 15<px; width: 40px" >
  
                  <textarea id="ageAtDxMinSliderReadout" style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
               <div style="width: 120px; height: 6px; float: left; margin-top: 10px; 
                           margin-left: 30px; margin-right: 15px;" 
                   id="ageAtDxSlider" class="slider patientDataFilterSlider">
                   </div>
               <div id="ageAtDxMsgBox2" style="float: left">  
                  <textarea id="ageAtDxMaxSliderReadout" style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
              </div>
           </div>


        <div id="survivalSliderDiv" class="nav navbar-nav navbar-form navbar-left" style="display: inline-block">
           <div id="survivalSliderTitleDiv" class="patientDataFilterSliderTitleDiv" style="text-align: center; width=100%">Survival</div>
           <div style="width: 280px; overflow: hidden;">
               <div id="survivalMsgBox1" style="float: left" >  
                  <textarea id="survivalMinSliderReadout" style="font-size: 12px; height:16px"
                             readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
               <div style="width: 120px; height: 6px; float: left; margin-top: 10px; margin-left: 15px;
                            margin-right: 15px;" 
                   id="survivalSlider" class="slider patientDataFilterSlider">
                   </div>
               <div id="survivalMsgBox2" style="float: left">  
                  <textarea id="survivalMaxSliderReadout"  style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
              </div>
           </div>

     <button id="patientHistoryShowAllRowsButton" type="button">Reset</button>
     <select class="SelectionMenu" type="button" id="patientHistorySendSelectionsMenu" style="float:right; margin:15px"></select>


  </div>

  <div id="patientHistoryTableDiv">  
    <table id="patientHistoryTable" cellpadding="0" cellspacing="0" border="0" class="display">
    </table>
 </div>

</div>

<style>

.x.axis line {
  stroke: #fff;
}

.x.axis .minor {
  stroke-opacity: .5;
}

.x.axis path {
  fill: none;
  stroke: #000;
}
.y.axis line, .y.axis path {
  fill: none;
  stroke: #000;
}

.path {
  opacity: 0.7 ;
}

.path:hover {
  opacity: 1 ;
}

.eventNoHover {
	visibility: hidden;
}
.eventHover {
	visibility: visible !important;
}
.tooltipNoHover{
	visibility: hidden;
}
.tooltipHover{
	visibility: visible !important;
}

</style>

<div id="patientTimeLinesDiv" >
	<div id="ArrangeDataDiv" class="navbar navbar-default" role="navigation">
	<div class="navbar-collapse collapse navbar-inner">
	
	<div class="nav navbar-nav navbar-form navbar-left"  style="float:left">  
	     <span id="SideBarMenu">Features: </span>
	     <select type="button" id="SideBarOptions" style="margin: 5px;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
	     	<option selected="selected">--</option>
<!--	     	<option> Add+ </option>  -->
	     	<optGroup label='Category' class="plotCategoryOptions"></optGroup>
	     	<optGroup label='Value' class="plotValueOptions"></optGroup>	     
	     </select>
	     <span id="AlignByMenu" >Align By: </span>
	     <select type="button" id="AlignOptions"  name="AlignOptions" style="margin: 5px;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
	     	<option value="--" selected="selected">--</option>
	     </select>
	     <span id="OrderByMenu" >Order By: </span>
	     <select type="button" id="OrderOptions" name="OrderOptions" style="margin: 5px;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
	     	<option value="--" selected="selected">--</option>
<!--	     	<option> Add+ </option>  -->
	     	<optGroup label='Date' class="OrderByDateOptions"></optGroup>
	     	<optGroup label='Value' class="OrderByValueOptions"></optGroup>
	     </select>
	     <input type="checkbox" id="FitToPage" checked>Fit to Page </input>
	     
    </div>
    <div class="infoDiv nav navbar-nav navbar-form navbar-right"  style="float:right">
        <select class="btn btn-primary selectpicker SelectionMenu" id="timeLineSendSelectionsMenu" name="SendSelectionToModule" >Send Selection to...</select>
    </div>
       
       
       
    </div>
    </div>
    <br>
    <div id="TimeLineDisplay" class="content" style="margin:0 auto" >
    </div>
     
     <div id="AddCalculatedEvent" class="Modal" style="display:none">
     <form>
          <label for="Name">Name: </label>
          <input type="text" id="Name" value="e.g. Survival"><br>
          <label for="Event1">Event 1: </label>
          <select id="Event1"></select><br/>
          <label for="Event2">Event 2: </label>
          <select id="Event2"></select><br/>
          <label for="TimeScale"> Time Scale: </label>
          <select id="TimeScale" value="Days, Months, Years">
        		<option value="Days">Days</option>
        		<option value="Months">Months</option>
        		<option value="Years">Years</option>
          </select>
  	</form>
     </div>
     
    <svg>
      <defs>
        <pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="4" height="4">
		  <path d="M-1,1 l2,-2
 		           M0,4 l4,-4
      			   M3,5 l2,-2" style="stroke:black; stroke-width:1; fill:grey border-radius:20px" />
		</pattern>      
      </defs>
	</svg>
 	
 
</div>

<style>

div {
   display: block;
   }

#gbmPathwaysDiv {
  }

#cyGbmPathwaysDiv {
  background-color: #FFFFFF;

  position: relative;

  height: 400px;
  width: 600px;

  border: 1px solid #aaa;

  margin-top: 0px;
  margin-left: 0px;

  padding: 0px;
  }

.gbmButton {
   font-size: 8pt;
   }

#gbmPathwaysMouseOverReadoutDiv{
  border: 1px solid #aaa;
  width: 800px;
  height: 20px;
  margin: 0px;
  }

#gbmPathwaysButtonDiv{
  margin-top: 0px;
  margin-bottom: 0px;
  }

#gbmPathwaysMovieSpeedReadout{
   border: 1px solid #aaa;
   width: 50px;
   height: 20px;
   margin: 0px;
   }
#bottomMargin{
   height:18px;
}
</style>
<script>
$("#gbmPathwaysMovieButton").click(function(){
    $(this).text("Stop");
});
</script>

<div id="gbmPathwaysDiv">
   <div id="gbmPathwaysStatusDiv" style="display:none"></div>
   <div id="gbmPathwaysButtonDiv" style="margin-bottom: 0px;bottom: 8px;">
      <!--
      <label id="gbmPathwaysSelectLabel" class="text-muted" for="select">Select a sample:</label>
      <select class="navbar-form selectpicker" id="gbmPathwaysSampleSelector"></select>
      -->
      <input type="text" id="gbmPathwaysSearchBox" value="search"></input>
      <!--
      <button id="gbmPathwaysMovieButton" style="width:100px"  type="button" class="btn btn-info navbar-btn  btn-xs"></button>
      <button id="gbmPathwaysSlowerMovieButton" type="button" class="btn btn-info navbar-btn btn-xs"> + </button>
      <span id="gbmPathwaysMovieSpeedReadout" class="navbar-btn btn-lg badge"></span> &nbsp;
      <button id="gbmPathwaysFasterMovieButton" type="button" class="btn btn-info navbar-btn btn-xs"> - </button>
      -->
      <button id="gbmViewAbstractsButton" type="button" class="btn btn-info navbar-btn btn-xs">Enable Abstracts</button>
      <button id="gbmZoomSelectedButton" type="button" class="btn btn-info navbar-btn btn-xs">Zoom Selected</button>
      <select class="SelectionMenu" type="button" id="gbmPathwaysSendSelectionMenu" style="float:right; margin-right:15px"></select>
    </div>

   <div id="cyGbmPathwaysDiv" class="content" style="margin:0 auto" ></div>

</div>




<style>

div {
   display: block;
   }

body.wait, body.wait *{
   cursor: wait !important;   
}

#markersAndPatientssDiv{
  }

button {font-size:10pt !important;}

#cyMarkersDiv {
  background-color: #FAFAFA;  // light gray
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  margin-top: 2px;
  margin-left: 0px;
  padding: 0px;
  }

#markersAndTissuesSearchBox{
  border: 1px solid #aaa;
  width: 80px;
  height: 20px;
  }

markersAndTissuesMouseOverReadout{
  border: 1px solid #aaa;
  width: 400px !important;
  height: 24px;
  font-size: 12pt !important;
  font-weight: bold;
  }


#cyMarkersClearSelectionButton #cyMarkersHideEdgesButton #cyMarkersShowEdgesButton #cyMarkersShowAllEdgesButton {
   font-size:8pt  !important;
   }

#markersAndTissuesbuttonDiv{
  margin-top: 1px;
  margin-bottom: 1px;
  }

#hiddenmarkersEdgeTypeSelector {
  width: 100% !important;
  }

.chosen-container, .chosen-drop, .chosen-drop .chosen-search, .chosen-drop .chosen-search input {
  width: 100% !important;
  -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
}

.chosen-container { width:350px !important; 
                    height:auto;
                    font-size:8pt;}
iframe {
display: initial !important;
}


#MTNavForm{
  padding:4px !important;
  margin-top:4px !important;
  margin-bottom:0px !important;
  margin-left:0px !important;
}
#bottomMargin{
  height:18px;
}
</style>


<div id="markersAndPatientsDiv" class="container-fluid">
   <div id="markersAndTissuesButtonDiv" style="margin-bottom: 0px; margin-top: 8px;">
      <input type="text" id="markersAndTissuesMouseOverReadout" disabled value="(names displayed here)"></input>

     <select id="cyMarkersOperationsMenu" type="button" class="btn btn-primary navbar-form selectpicker SelectionMenu" style="font-size:11pt"></select>
     <select id="cyMarkersTumorCategorizationsMenu" class="SelectionMenu" style="font-size:8pt;"></select>
      
     <select class="chosen-select form-control dropdown navbar-form selectpicker SelectionMenu" 
                    style="width:280px;font-size:12pt"
                    data-placeholder="Select edge types to display" 
                    multiple id="markersEdgeTypeSelector">
           <option value="mutation" class="btn-info" selected>Mut</option>
           <option value="cnGain.2" class="btn-info" selected>Copy+2</option>
           <option value="cnLoss.2" class="btn-info" selected>Copy-2</option>
           <option value="cnGain.1" class="btn-info" selected>C+1</option>
           <option value="cnLoss.1" class="btn-info" selected>C-1</option>
       </select>
     
 
   <input  type="text" id="markersAndTissuesSearchBox" placeholder="search" style="width:100px;font-size:11pt"></input>
   <select class="SelectionMenu" type="button" id="cyMarkersSendSelectionsMenu" style="float:right; margin-right:15px"></select>
 
   <select class="btn btn-primary selectpicker SelectionMenu" type="button" id="markerLayouts"
            name="markerLayoutMenu"></select>
   <button id="markersSubSelectButton">Subselect</button>
 
   </div>
   
   
 <div id="cyMarkersDiv" data-toggle="tooltip" class="content" style="margin:0 auto" ></div>
 <div id="bottomMargin" style="width:100%;height:30px margin:0 auto"></div>

</div>




<style>

#survivalCurveDiv{
   width: 1000px;
   height: 500px;
   border: 1px solid #aaa;
}
#bottomMargin{
  height:18px;
}
</style>


<div id="survivalDiv" class="container-fluid">
  <div id="survivalInstructions"><p></p>Please select and send a group of patients to compare against the remaining population.</p>
  <p>Note that all patients with clinical histories are used in this comparison.</p>
  </div>
  <div id="survivalStatusDiv" style="display:none"></div>
  <div id="survivalCurveDiv" class="content" style="margin:0 auto" >
     <img id="survivalImageArea" width="800" height="800"></img>
  </div>

</div>


<style>

.domain { 
  fill: none; 
  stroke: black; 
  stroke-width; 1; 

  } 


.extent {
  fill-opacity: .1;
  stroke: #f00;
}


.axis path, .axis line {
    stroke: black;
    stroke-width: 1px;
    }

circle {
   opacity: 1;
   }

circle.highlighted {
   fill: orange;
   opacity: 1;
   }

#pcaDisplay {
   border: 1px solid #aaa;
   width: 50px;
   height: 50px;
   background-color: #FAFAFA;
   margin-top: 1px;
   margin-left: 19px;
   margin-right: 0;
   margin-bottom: 1px;
   padding: 1px;
   padding-bottom: 0px;
   }

#pcaBroadcastSelectionToClinicalTable{
   font-size: 10pt;
   }

#pcaHighlight{
   font-size: 10pt;
   }

.pcaButton {
   font-size: 8pt;
   }

.pcaDownload{
padding-left:10px;
color: #808080;
 cursor: pointer;
}


</style>

<div id="pcaDiv" class="container-fluid">
   <div id="pcaStatusDiv" style="display:none"></div>
   <div id="pcaControlsDiv">
       <button id="pcaClearSelectionButton" style="margin-bottom: 5px;">Clear Selection</button>
       <select class="SelectionMenu" id="pcaGeneSetSelector" style="margin-bottom: 5px;"></select>
       <button id="pcaCalculateButton" style="margin-bottom: 5px;">Calculate</button>
       <button id="pcaUseAllSamplesButton" style="margin-bottom: 5px;">Use All Samples in Current Dataset</button>
       <select class= "SelectionMenu" type="button" id="pcaSendSelectionsMenu" style="float:right; margin-right:15px"></select>
   </div>

   <div id="pcaInstructions">Please select a gene set from the above menu and click the 'Calculate' button.</div>
   <div id="pcaOutputDiv">
      <div id="pcaDisplay"></div>
      <div id="pcaLegend"></div>
      <div id="pcaTextDisplayDiv"></div>
   </div>

</div>

<style>


.domain { 
  fill: none; 
  } 

.extent {
  fill-opacity: .1;
  stroke: #f00;
}


.axis path, .axis line {
    stroke: black;
    stroke-width: 1px;
    }

#plsrControlsDiv {
   border: 1px solid #aaa;
   font-family: sans-serif;
   font-size: 12px;
   margin-top: 2px;
   margin-left: 5px;
   margin-right: 10px;
   margin-bottom: 5px;
   height: 80px;
   background-color: #E8E8E8;
   }

#plsrPlotDiv {
   border-style: solid;
   border-width: 1px;
   width: 800px;
   height: 500px;
   margin: 5px;
   }

.plsrSlider { 
   margin-left:0px; 
   margin-right:0px; 
   margin-top:0px;
   border: 3px solid #FFF;
   background-color: #FFF;
   height: 20px;
   max: 0;  min: 10; 
   orientation: 'horizontal';

   }

.plsrSliderReadout {
  font-family:"Courier";
  color: #00F;
  background-color: #FFF;
  font-size: 12px;
  border: 2px solid #DDD;
  width: 40px;
  height: 18px;
  resize: none;
  margin-top: 5px;
  margin-left: 1px;
  }

.plsrSliderTitleDiv {
  font-family:"Arial";
  color: #000000;
  font-size: 14px;
  padding-top: 0px;
  }


#plsrButtonDiv {
   padding-botton: 30px;
   }
#plsrAgeAtDxSlider .ui-widget-header { border: 1px solid #fff; background: #fff; }
#plsrAgeAtDxSlider {  background: #E8E8E8; }
#plsrSurvivalSlider .ui-widget-header { border: 1px solid #fff; background: #fff; }
#plsrSurvivalSlider {  background: #E8E8E8; }

#plsrAgeAtDxSlider {
background:#ABD3E8;
}
#plsrSurvivalSlider {
background:#ABD3E8;
}

</style>


<div id="plsrDiv" style="padding:0px; padding-top: 5px;">
   <div id="plsrStatusDiv" style="display:none"></div>
   <div id="plsrControlsDiv" class="flex-container">

          <div id="plsrAgeSliderDiv" style="display: inline-block; margin-top: 3px; margin-right: 20px; width:250px;">
             <div id="plsrAgeSliderTitleDiv" class="plsrSliderTitleDiv" style="text-align: center; width:100%">Age at Dx</div>
             <div id="plsrAgeSliderBodyDiv" style="overflow: hidden; display: inline-block">
                <div id='msgBox1' style="float:left; display: inline-block" >  
                   <textarea id="plsrAgeAtDxMinSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                </div>
                <div id="plsrAgeAtDxSlider" style="width: 120px; height: 6px; float: left; margin-top: 12px;" class="slider plsrSlider"></div>
                <div id='msgBox2' style="float: left" >  
                  <textarea id="plsrAgeAtDxMaxSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                 </div>
             </div>
         </div>

        <div id="plsrSurvivalSliderDiv" style="display: inline-block; margin-top: 3px; margin-left: 3px; margin-right: 10px; width:250px;">
           <div id="plsrSurvivalSliderTitleDiv" class="plsrSliderTitleDiv" style="text-align: center; width=100%">Survival</div>
           <div id="plsrSurvivalSliderBodyDiv" style="overflow: hidden; display: inline-block">
               <div id='msgBox3' style="float: left" >  
                  <textarea id="plsrSurvivalMinSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                </div>
               <div id="plsrSurvivalSlider" style="width: 120px; height: 6px; float: left; margin-top: 12px;" class="slider plsrSlider"></div>
               <div id='msgBox4' style="float: left; display: inline-block" >  
                    <textarea id="plsrSurvivalMaxSliderReadout" readonly class="plsrSliderReadout"></textarea> 
               </div>
           </div>
       </div>

       <div id="plsrCalculateButtonDiv" class="flex-container" style="margin-right: auto; margin-top:15px;">
          <button id="plsrClearSelectionButton" style="height:50px;">Clear<br>Selection</button>
          <button id="plsrCalculateButton" style="height:50px;">Calculate</button>
          <select class="SelectionMenu" id="plsrGeneSetSelector" style="height:20px; margin-top:15px; margin-left:3px;" class="navbar-form selectpicker" ></select>
       </div>
      <div id="plsrSendSelectionsMenuDiv" style="margin-right:10px; margin-top: 25px;">
         <select class="SelectionMenu" id="plsrSendSelectionsMenu" type="button" style="margin-top: 7px;"></select>
      </div>
  </div>
  <div id="plsrInstructions">
    <p>Please adjust the sliders specifying Age at Diagnosis and Survival ranges, select the desired gene set from dropdown menu, then click 'Calculate' to display the PLSR result.</p>
  </div>
  <div id="plsrDisplay" style="margin:0 auto; display: none"></div>

</div>


</div>

<div id="footer-logos" style="margin-left:auto; margin-right:auto">
	<span style="float:left; width:33%">
	  <a href="http://www.fredhutch.org" target="_blank"><img width="235" height="80" src="http://oncoscape.sttrcancer.org/oncoscape/images/FredHutch_h_tag_4col_RBG_tm.png" alt="Fred Hutch"/></a>
	</span>

</div>

<script>
hub.hideTab("blank tab", "#blankTabDiv");
</script>


</body>
</html>
